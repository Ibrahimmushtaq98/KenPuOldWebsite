<html>

    
<!-- Mirrored from db.science.uoit.ca/library/teaching/compilers by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 06 Apr 2020 22:34:34 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
        <meta name="viewport" content="width=device-width, initial-scale=1 maximum-scale=1">
        <link rel="icon" href="../static/favicon.png"/>
        <title>compilers</title>
        <!--
        <link rel="stylesheet" href="/library/static/yeti-bootstrap.min.css">
        -->
        <link rel="stylesheet" href="../static/font-awesome/css/font-awesome.min.css">
        <link rel="stylesheet" href="../static/css/fonts/fonts.css">
        <link rel=stylesheet href="../static/prism/prism.css">
        <link rel=stylesheet href="../static/client/css/app.css">
        <link rel=stylesheet href="../static/client/css/bookie.css">
    </head>

<body>
<div id="app"></div>
<div id="app-resources" style="display: none">
    <ul>
        
        <li><a href="./dragon-book.html">dragon-book.jpg</a></li>
        
        <li><a href="./antlr-book.html">antlr-book.png</a></li>
        
        <li><a href="index.clj">index.clj</a></li>
        
        <li><a href="00.introduction/index.html">00.introduction/index.clj</a></li>
        
        <li><a href="07.compiler/index.html">07.compiler/index.clj</a></li>
        
        <li><a href="07.compiler/programming-bytecode/7.html">07.compiler/programming-bytecode/7.png</a></li>
        
        <li><a href="07.compiler/programming-bytecode/1.html">07.compiler/programming-bytecode/1.png</a></li>
        
        <li><a href="07.compiler/programming-bytecode/2.html">07.compiler/programming-bytecode/2.png</a></li>
        
        <li><a href="07.compiler/programming-bytecode/8.html">07.compiler/programming-bytecode/8.png</a></li>
        
        <li><a href="07.compiler/programming-bytecode/Base.html">07.compiler/programming-bytecode/Base.j</a></li>
        
        <li><a href="07.compiler/programming-bytecode/4.html">07.compiler/programming-bytecode/4.png</a></li>
        
        <li><a href="07.compiler/programming-bytecode/5.html">07.compiler/programming-bytecode/5.png</a></li>
        
        <li><a href="07.compiler/programming-bytecode/index.html">07.compiler/programming-bytecode/index.clj</a></li>
        
        <li><a href="07.compiler/programming-bytecode/6.html">07.compiler/programming-bytecode/6.png</a></li>
        
        <li><a href="07.compiler/programming-bytecode/3.html">07.compiler/programming-bytecode/3.png</a></li>
        
        <li><a href="07.compiler/basics-of-jvm/9.html">07.compiler/basics-of-jvm/9.png</a></li>
        
        <li><a href="07.compiler/basics-of-jvm/7.html">07.compiler/basics-of-jvm/7.png</a></li>
        
        <li><a href="07.compiler/basics-of-jvm/1.html">07.compiler/basics-of-jvm/1.png</a></li>
        
        <li><a href="07.compiler/basics-of-jvm/2.html">07.compiler/basics-of-jvm/2.png</a></li>
        
        <li><a href="07.compiler/basics-of-jvm/8.html">07.compiler/basics-of-jvm/8.png</a></li>
        
        <li><a href="07.compiler/basics-of-jvm/4.html">07.compiler/basics-of-jvm/4.png</a></li>
        
        <li><a href="07.compiler/basics-of-jvm/5.html">07.compiler/basics-of-jvm/5.png</a></li>
        
        <li><a href="07.compiler/basics-of-jvm/index.html">07.compiler/basics-of-jvm/index.clj</a></li>
        
        <li><a href="07.compiler/basics-of-jvm/6.html">07.compiler/basics-of-jvm/6.png</a></li>
        
        <li><a href="07.compiler/basics-of-jvm/3.html">07.compiler/basics-of-jvm/3.png</a></li>
        
        <li><a href="05.grammar-design/index.html">05.grammar-design/index.clj</a></li>
        
        <li><a href="05.grammar-design/sdd/parse-tree-with-data.html">05.grammar-design/sdd/parse-tree-with-data.png</a></li>
        
        <li><a href="05.grammar-design/sdd/index.html">05.grammar-design/sdd/index.clj</a></li>
        
        <li><a href="05.grammar-design/calc/index.html">05.grammar-design/calc/index.clj</a></li>
        
        <li><a href="05.grammar-design/intro/index.html">05.grammar-design/intro/index.clj</a></li>
        
        <li><a href="02.grammars/index.html">02.grammars/index.clj</a></li>
        
        <li><a href="02.grammars/ambiguity/ambig-1.html">02.grammars/ambiguity/ambig-1.png</a></li>
        
        <li><a href="02.grammars/ambiguity/parse-tree.html">02.grammars/ambiguity/parse-tree.png</a></li>
        
        <li><a href="02.grammars/ambiguity/index.html">02.grammars/ambiguity/index.clj</a></li>
        
        <li><a href="02.grammars/ambiguity/ambig-2.html">02.grammars/ambiguity/ambig-2.png</a></li>
        
        <li><a href="02.grammars/parse/index.html">02.grammars/parse/index.clj</a></li>
        
        <li><a href="02.grammars/transformations/index.html">02.grammars/transformations/index.clj</a></li>
        
        <li><a href="02.grammars/intro/index.html">02.grammars/intro/index.clj</a></li>
        
        <li><a href="01.lexer/index.html">01.lexer/index.clj</a></li>
        
        <li><a href="01.lexer/lexer/index.html">01.lexer/lexer/index.clj</a></li>
        
        <li><a href="01.lexer/automaton/re-a.html">01.lexer/automaton/re-a.png</a></li>
        
        <li><a href="01.lexer/automaton/re-or.html">01.lexer/automaton/re-or.png</a></li>
        
        <li><a href="01.lexer/automaton/re-empty.html">01.lexer/automaton/re-empty.png</a></li>
        
        <li><a href="01.lexer/automaton/index.html">01.lexer/automaton/index.clj</a></li>
        
        <li><a href="01.lexer/automaton/re-concat.html">01.lexer/automaton/re-concat.png</a></li>
        
        <li><a href="01.lexer/automaton/re-star.html">01.lexer/automaton/re-star.png</a></li>
        
        <li><a href="01.lexer/automaton/automaton.html">01.lexer/automaton/automaton.png</a></li>
        
        <li><a href="01.lexer/java-lexer/index.html">01.lexer/java-lexer/index.clj</a></li>
        
        <li><a href="01.lexer/antlr-lexer/index.html">01.lexer/antlr-lexer/index.clj</a></li>
        
        <li><a href="01.lexer/intro/morse-alphabet.html">01.lexer/intro/morse-alphabet.png</a></li>
        
        <li><a href="01.lexer/intro/morse-string.html">01.lexer/intro/morse-string.png</a></li>
        
        <li><a href="01.lexer/intro/chinese-alphabet.html">01.lexer/intro/chinese-alphabet.png</a></li>
        
        <li><a href="01.lexer/intro/index.html">01.lexer/intro/index.clj</a></li>
        
        <li><a href="06.interpreters/interpreter_livecoding.html">06.interpreters/interpreter_livecoding.ipynb</a></li>
        
        <li><a href="06.interpreters/index.html">06.interpreters/index.clj</a></li>
        
        <li><a href="06.interpreters/interpreter_reference.html">06.interpreters/interpreter_reference.ipynb</a></li>
        
        <li><a href="03.topdown-parsing/index.html">03.topdown-parsing/index.clj</a></li>
        
        <li><a href="03.topdown-parsing/parser/index.html">03.topdown-parsing/parser/index.clj</a></li>
        
        <li><a href="03.topdown-parsing/first-follow/index.html">03.topdown-parsing/first-follow/index.clj</a></li>
        
        <li><a href="03.topdown-parsing/intro/a.html">03.topdown-parsing/intro/a.png</a></li>
        
        <li><a href="03.topdown-parsing/intro/b.html">03.topdown-parsing/intro/b.png</a></li>
        
        <li><a href="03.topdown-parsing/intro/index.html">03.topdown-parsing/intro/index.clj</a></li>
        
    </ul>
</div>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    elements: [],
    skipStartupTypeset: true,
    /*
    "HTML-CSS": {
        scale: 83,
    },
    */
    //showMathMenu: false,
    //zoom: "None",
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
      processEscapes: true,
      skipTags: ["script", 
      "noscript", 
      "style", 
      "textarea", 
      "nomath", 
      //"pre",
      ],
      // nomathjax used by (code ...) component
      ignoreClass: "nomath|nomathjax|tex2jax_ignore", 
    },
    /*
    TeX: {
        equationNumbers: {autoNumber: "AMS"},
    },
    */
  });
</script>
<script>
(function() {
var throttle = function(type, name, obj) {
    obj = obj || window;
    var running = false;
    var func = function() {
        if (running) { return; }
        running = true;
         requestAnimationFrame(function() {
            obj.dispatchEvent(new CustomEvent(name));
            running = false;
        });
    };
    obj.addEventListener(type, func);
};
throttle("resize", "__resize__");
throttle("scroll", "__scroll__");
})();
</script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js"></script>
    <!--
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
    -->
<!--
Prism from CDN does not come with line number plugin
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/prism.min.js"></script>
-->
<script src="../static/prism/prism.js"></script>
<script src="../static/prism/prism-extension.js"></script>
<script src="../static/client/main.js"></script>

<script>
                var sitemap = {
                "": {
                    "children": ["00.introduction", "01.lexer", "02.grammars", "03.topdown-parsing", "05.grammar-design", "06.interpreters", "07.compiler"],
                    "content": "{:title \"Compilers\"\n :categories [:course]\n :label \"4020\"\n :rank \"9999\"\n :summary #md {{{\n                 This course provides a detailed study of the compilation\n                 process for a procedural language. Students will develop an\n                 understanding of compiler design and put these principles into\n                 practice through the construction of a fully functioning\n                 compiler for a small procedural language using widely available\n                 tools for compiler construction and a general-purpose\n                 programming language.\n                 }}}}\n\n(page (:h1 \"About this course\") \n      (row 6 3 3\n           #md {{{ \n                  The lecture notes will largely follow the textbook of this course.\n                  }}}\n           (image \"dragon-book.jpg\")\n           (image \"antlr-book.png\"\n                  #md {{{ Strongly recommended }}}))\n      ); page\n",
                    "istop": false,
                    "path": ""
                },
                "00.introduction": {
                    "children": [],
                    "content": "{:title \"Outline of Course\"\n :summary #md {{{\n                 An overview of the course.\n                 }}}\n }\n\n(:h1 \"Part I: Languages\")\n\n(page (:h1 \"Regular languages\")\n\n      #md {{{\n             - Definition of regular expressions\n             - Programming with regular expressions\n             - Algorithms on regular expressions\n             }}})\n\n(page (:h1 \"Context free languages\")\n\n      #md {{{\n             - Definition of context free grammar (CFG)\n             - Theories of CFG\n             - Designing languages using CFG\n             }}})\n\n(:h1 \"Part II: Parsing\")\n\n(page #md {{{\n             # Theory\n\n             - Top-down parsers\n             - _Syntax directed programming_ techniques\n             }}}\n      #md {{{\n             # Practice\n\n             - Parser generator\n             - Programming with Syntax Directed Definition (SDD)\n             }}})\n\n;(page (:h1 \"Bottom-up parsing\")\n;      #md {{{\n;             - Theory\n;             - Practice\n;             }}})\n\n(:h1 \"Part III: Interpreters\")\n\n(page (:h1 \"Syntax design\")\n      #md {{{\n             - Expressions and scopes\n             - Functions\n             - Turing complete interpreters\n                - Functional languages\n                - Procedural languages\n             }}}\n             )\n\n(:h1 \"Part IV: Compilers\")\n\n(page (:h1 \"JVM Bytecode\")\n\n      #md {{{\n             - Three address code\n             - Programming in Java bytecode\n             }}}\n      (:h1 \"Code generation\")\n      #md {{{\n             - Interpreter vs compiler\n             - Generating Java bytecode\n             }}}\n      \n      )\n\n(:h1 \"Learning Objectives\")\n\n(page #md {{{\n             - Able to parse structured text (including code and markup languages)\n             - Able to program using syntax directed definitions\n             - Understand and construct interpreters\n             - Understand and construct compilers\n             }}}\n      )\n",
                    "istop": false,
                    "path": "00.introduction"
                },
                "01.lexer": {
                    "children": ["01.lexer/antlr-lexer", "01.lexer/automaton", "01.lexer/intro", "01.lexer/java-lexer", "01.lexer/lexer"],
                    "content": "{:title \"Lexical Analysis\"\n :summary #md {{{\n                 We will define regular expressions, regular languages\n                 and automata. We will also explore how they work\n                 in practice with several libraries.\n                 }}}\n }\n \n",
                    "istop": false,
                    "path": "01.lexer"
                },
                "01.lexer/antlr-lexer": {
                    "children": [],
                    "content": "{:title \"Lexical Analysis with ANTLR\"\n :rank 4\n :status :ready\n ; :label \"\u003ci class=\u0027fa fa-code\u0027\u003e\u003c/i\u003e\"\n :summary #md {{{\n                 We will look at a library, **ANTLR**, that performs\n                 _lexical analysis_. In particular, we will see how ANTLR\n                 makes it easier to build maintainable and scalable\n                 lexical analyzers.\n                 }}}\n }\n\n(page (:h1 \"Introduction to ANTLR\")\n\n      (rows :sep 4 8\n            (:h2 \"What is ANTLR?\")\n            #md {{{\n                   __ANTLR__ is a _parser generator_.\n                   Instead of programmatically crafting the\n                   parsing strategy (as we did with regexp),\n                   ANTLR\u0027s approach is to specify the\n                   patterns as _rules_ in a _grammar_ file.\n                   }}}\n\n            (:h2 \"Using ANTLR\")\n            #md {{{\n                   ANTLR is a _tool_.  It converts _grammar files_\n                   to _.java files_.  The generated Java source code\n                   will perform parsing.\n\n                   ANTLR is invoked as a _command line_ command.\n                   }}}\n\n            (:h2 \"Getting ANTLR\")\n            #md {{{\n                   ANTLR is written in Java.  It comes as an\n                   _executable_ Java archive _(.jar)_ file.\n\n                   At the time of writing, we use [Antlr 4.7.x](https://www.antlr.org/download.html).\n                   }}}\n            ); rows\n      ); pages\n\n(page (:h1 \"The Antlr toolchain\")\n\n      #md {{{\n             Let\u0027s explore the Antlr toolchain.\n             }}}\n\n      (rows 4 8\n            (:h2 \"Downloading Antlr\")\n            (:div #md {{{\n                         As of **2019-01**, you can download the latest version\n                         of Antlr at here:\n\n                         https://www.antlr.org/download/antlr-4.7.2-complete.jar\n                         }}}\n                  (code {{{\n                           $ ls\n                           antlr-4.7.2-complete.jar\n                           }}})\n                  (code :sm\n                        {{{\n                           $ java -jar antlr-4.7.2-complete.jar\n                           ANTLR Parser Generator  Version 4.7.2\n                           -o ___              specify output directory where all output is generated\n                           -listener           generate parse tree listener (default)\n                           -no-listener        don\u0027t generate parse tree listener\n                           -visitor            generate parse tree visitor\n                           -no-visitor         don\u0027t generate parse tree visitor (default)\n                           ...\n                           }}})\n                  )\n            (:h2 \"Overview of antlr workflow\")\n            (:div #md {{{\n                         Antlr compiles special _grammar_ files\n                         into Java classes.\n                         }}}\n                  #md {{{\n                         The grammar files specify _languages_.\n\n                         - Lexer grammar\n                         - Parser grammar\n                         }}}\n                  #md {{{\n                         The generated Java source files\n                         are used in user application to perform parsing.\n                         }}}\n                  )\n            )\n      )\n\n(page (:h1 \"An Example\")\n      (rows 4 8\n            (:h2 \"A simple lexer specification\")\n            (:div #md {{{\n                         Let\u0027s write a simple lexer by\n                         specifying:\n\n                         - Token types\n                         - Patterns for each token type\n                         }}}\n                  (code :antlr\n                        {:label \"SampleLexer.g4\"}\n                        {{{\n                           lexer grammar SampleLexer;\n\n                           WS      : [ \\t]+ ;\n                           NEWLINE : [\\r\\n]+;\n                           NUM     : [0-9]+ ;\n                           WORD    : [a-zA-Z]+ ;\n                           }}})\n                  #md {{{\n                         So we have two files:\n\n                         \u003e ```\n                         \u003e .\n                         \u003e \u251c\u2500\u2500 SampleLexer.g4\n                         \u003e \u2514\u2500\u2500 antlr-4.7.2-complete.jar\n                         \u003e ```\n                         }}}\n                  )\n            (:h2 \"Generating Lexer Java class source\")\n            (:div #md {{{\n                         We need to generate the Java class\n                         from the `.g4` grammar file.\n                         }}}\n                  (code :bash\n                        {{{\n                           $ java -jar antlr-4.7.2-complete.jar *.g4\n                           }}}) \n                  #md {{{\n                         Antlr just generates a bunch of files.  The one\n                         _SampleLexer.java_ is the only useful one to us.\n\n                         \u003e ```\n                         \u003e  .\n                         \u003e  \u251c\u2500\u2500 SampleLexer.g4\n                         \u003e  \u251c\u2500\u2500 SampleLexer.interp\n                         \u003e  \u251c\u2500\u2500 SampleLexer.java\n                         \u003e  \u251c\u2500\u2500 SampleLexer.tokens\n                         \u003e  \u2514\u2500\u2500 antlr-4.7.2-complete.jar\n                         \u003e ```\n                       }}}\n                  )\n            (:h2 \"Compiling Java class\")\n            (:div #md {{{\n                         The generated Java class requires Antlr runtime library\n                         to be included in the classpath.\n                         }}}\n                  (code :bash\n                        {{{\n                           $ javac -cp antlr-4.7.2-complete.jar:. *.java\n                           $ ls\n                           SampleLexer.class        SampleLexer.interp       SampleLexer.tokens\n                           SampleLexer.g4           SampleLexer.java         antlr-4.7.2-complete.jar\n                           }}})\n                  )\n            )\n      )\n\n(page (:h1 \"Using Antlr Lexer\")\n\n      (rows 4 8\n            (:h2 \"The generated lexer class\")\n            (code :java\n                  {{{\n                     // Generated from SampleLexer.g4 by ANTLR 4.7.2\n                     import org.antlr.v4.runtime.Lexer;\n                     ...\n                     public class SampleLexer extends Lexer {\n                       public SampleLexer(CharStream input) ...\n                       public String[] getRuleNames() ...\n                       public static final int\n                         WS=1,\n                         NUMBER=2,\n                         WORD=3;\n                       ...\n                     }\n                     }}})\n\n            (:h2 \"Performing lexical analysis\")\n            (:div (code :java\n                        {{{\n                         import org.antlr.v4.runtime.*;\n\n                         CharStream input = CharStreams.fromFileName(\"...\");\n                               \u2193\n                               \u2193\n                               \u2193\n                         SampleLexer lexer = new SampleLexer(input);\n                               \u2193\n                               \u2193\n                               \u2193\n                         CommonTokenStream stream = new CommonTokenStream(lexer);\n                               \u2193\n                               \u2193\n                               \u2193\n                         stream.fill();\n                         List\u003cToken\u003e tokens = stream.getTokens();\n                         }}})\n                  (code :java\n                        {{{\n                           class Token {\n                             int getType()\n                             int getTokenIndex()\n                             String getText()\n                           }\n                           }}})\n                  )\n            )\n      )\n\n\n(page (:h1 \"Authoring Lexer Grammar\")\n\n      (rows 4 8\n            (:h2 \"Overall structure of the .g4 file\")\n            (code :java\n                  {{{\n                     lexer grammar \u003cName\u003eLexer;\n\n                     +-------------------------+\n                     | optional declarations   |\n                     +-------------------------+\n\n                     +-------------------------+\n                     | Rules                   |\n                     | ...                     |\n                     +-------------------------+\n                     }}})\n            (:h2 \"Rules\")\n            (:div #md {{{\n                         Each rule must follow the Antlr lexer grammar syntax.\n                         }}}\n                  (code :java\n                        {{{\n                           \u003cToken Type\u003e : \u003cPattern\u003e (actions);\n                           }}})\n                  #md {{{\n                         The token type must satisfy the following\n                         1. It must be a valid Java identifier.\n                         2. It must start with a _capital_ letter.\n                         \n                         \u003e ```\n                         \u003e Whitespace\n                         \u003e ```\n                         }}}\n                  #md {{{\n                         The pattern is regular expression.\n\n                         It\u0027s different from the Java regex syntax.\n\n                         \u003e ```\n                         \u003e Whitespace : (\u0027 \u0027 | \u0027\\t\u0027 | \u0027\\r\u0027 | \u0027\\n\u0027) ;\n                         \u003e Number : (\u00270\u0027 .. \u00279\u0027)+ ;\n                         \u003e ```\n                         }}}\n                  #md {{{\n                         We can have _actions_ attached to the lexical rule.\n                         This is used to suppress certain types of tokens.\n\n                         \u003e ```\n                         \u003e Whitespace : (\u0027 \u0027 | \u0027\\t\u0027 | \u0027\\r\u0027 | \u0027\\n\u0027) -\u003e skip;\n                         \u003e ```\n                         }}}\n                  )\n            (:h2 \"Why yet another syntax to learn?\")\n            #md {{{\n                   - Antlr lexer does not contain any _boilerplate_ code\n                   for lexical analysis.\n                   - We write minimal amount of code, and generates maximal performance.\n\n                   | File             | Line Count | Word Count | Byte Count |\n                   |------------------|------------|------------|------------|\n                   | SampleLexer.g4   | 5          | 13         | 81         |        \n                   | SampleLexer.java | 120        | 321        | 3551       |        \n                   }}}\n            )\n      )\n\n(page :wide\n      (:h1 \"Lexical Analysis in Java\")\n      (file :codewalk \"src/ExampleLexer.g4\")\n      (file :codewalk \"src/Main.java\"))\n\n(page (:h1 \"TestRig\")\n\n      (rows 4 8\n            (:h2 \"What is the test rig?\")\n            #md {{{\n                   - Rig: a platform, as in \"oil rig\"\n                   - Test rig is a platform for testing\n                   - org.antlr.v4.gui.TestRig is an executable Java class performs testing\n                   of Antlr grammars.\n                   }}}\n            (:h2 \"Run TestRig\")\n            (code :bash\n                  :sm\n                  {{{\n                     $ java -cp antlr-4.7.2-complete.jar org.antlr.v4.gui.TestRig\n\n                         java org.antlr.v4.gui.TestRig GrammarName startRuleName\n                         [-tokens] [-tree] [-gui] [-ps file.ps] [-encoding encodingname]\n                         [-trace] [-diagnostics] [-SLL]\n                         [input-filename(s)]\n                         Use startRuleName=\u0027tokens\u0027 if GrammarName is a lexer grammar.\n                         Omitting input-filename makes rig read from stdin.\n                     }}})\n            (:h2 \"Try out the test rig\")\n            (:div (code :bash\n                        :sm\n                        {{{\n                           $ java -cp antlr-4.7.2-complete.jar org.antlr.v4.gui.TestRig ExampleLexer tokens -tokens\n                           }}})\n                  #md {{{\n                         This is great - no need for user application to drive Antlr grammars for the purpose\n                         of testing.\n                         }}})\n            )\n      )\n\n(page (slide (:h1 \"Conclusion\")\n             #md {{{\n                    - Antlr lexical analyzer allows us to\n                    very efficiently describe complex lexical analyzers.\n                    }}}\n\n             #md {{{\n                    - Antlr lexer _becomes_ a Java class which we can use\n                    if we need a lexer.\n                    }}}\n\n             #md {{{\n                    - But we hardly ever just need a lexer.  We will see\n                    that Antlr lexer grammars will be part of a\n                    greater grammar.\n                    }}}\n             )\n      )\n",
                    "istop": false,
                    "path": "01.lexer/antlr-lexer"
                },
                "01.lexer/automaton": {
                    "children": [],
                    "content": "{:title \"Automata\"\n :status :ready\n :rank 5\n :summary #md {{{\n                 Automata are mathematical constructs that form the foundation\n                 of the regular expression based algorithms.\n                 }}}\n }\n\n(:h1 \"Motivation\")\n\n(page (:h1 \"Algorithms of regular expressions\")\n      #md {{{\n             Some regular expressions are extremely\n             complex.\n\n             This is a RE to define URLs.\n\n             ```python\n             ^(http|https|ftp)\n             :[\\/]{2}\n             ([a-zA-Z0-9\\-\\.]+\\.[a-zA-Z]{2,4})\n             (:[0-9]+)?\\/?([a-zA-Z0-9\\-\\._\\?\\,\\\u0027\\/\\\\\\+\u0026%\\$#\\=~]*)\n             ```\n             }}}\n\n      #md {{{\n             1. How is any arbitrary RE converted to _an object_ `Pattern`?\n\n             2. How can we perform matching using the `Matcher` methods?\n             }}}\n      ); page\n\n(page (:h1 \"Automaton to the rescue\")\n      (row 6 6\n        #md {{{\n               Singular: _Automaton_\n\n               Plural: _Automata_\n\n               We also call them:\n\n               - Finite state machines (FSM)\n               - Finite Automata (FA)\n               }}}\n\n        (banner #md {{{\n               FA defines strings\n\n               RE defines strings\n\n               ---\n\n               FA = RE\n               }}}))\n      ); page\n\n(:h1 \"Languages\")\n\n(page (:h1 \"Definitions\")\n\n      (rows :sep 4 8\n            (:h2 \"Symbols and alphabet\")\n            #md {{{\n                   An _alphabet_ $\\Sigma$ is an _finite_\n                   collection of _symbols_.\n                   }}}\n\n            (:h2 \"String\")\n            #md {{{\n                   A string a _finite_ sequence of symbols.\n                   }}}\n\n            (:h2 \"All finite strings\")\n            (:div (note :side\n                        #md {{{\n                               The notation is called _Kleene star_\n                               for historic reasons.\n\n                               The asterisk `*` has the same meaning\n                               as in RE.\n                               }}})\n                  #md {{{\n                         The set of all finite strings made up\n                         by symbols from an alphabet $\\Sigma$\n                         is denoted as: $\\Sigma^*$\n                         }}})\n            ); rows\n\n      #md {{{\n             This course will continuously come back to the task\n             of defining _infinite_ languages.\n             }}}\n      ); page\n\n(page (:h1 \"RE revisited\")\n\n      (rows :sep 4 8\n            (:h2 \"Core RE\")\n            #md {{{\n                   Suppose we have an alphabet $\\Sigma$.\n\n                   - $\\epsilon$ is a RE.\n\n                   - Any symbol $a\\in\\Sigma$ is a RE.\n\n                   - More complex RE can be built from\n                   simpler onces.\n\n                     Given two RE `$e_1$ and `$e_2$`, the following are\n                     all RE:\n\n                      - $e_1 e_2$\n                      - $e_1 | e_2$\n                      - `$( e_1 )$`\n                      - $e_1^*$\n                   }}}\n\n            (:h2 \"Languages defined by RE\")\n            (:div\n              #md {{{\n                     RE defines languages.  Let\u0027s define\n                     the languages of RE using induction.\n                     }}}\n              (note :side\n                    #md {{{\n                           $$\\mathrm{Lang}(\\Sigma) = \\mathrm{Powerset}(\\Sigma^*)\n                           $$ }}})\n              #md {{{\n                     `$$ L : \\mathrm{RE} \\to \\mathrm{Lang}(\\Sigma) $$`\n                     where $\\mathrm{Lang}(\\Sigma)$ is all the languages\n                     over the alphabet $\\Sigma$.\n                     }}}\n              #md {{{\n                     - `$L(\\epsilon) = \\emptyset$`\n                     - `$L(a) = \\{a\\}$`\n                     - `$L(e_1 e_2) = \\{st : s\\in L(e_1),\\ t\\in L(e_2)\\}$`\n                     - `$L(e_1|e_2) = L(e_1) \\cup L(e_2)$`\n                     - `$L(e^*) = \\{\\underbrace{s_1s_2\\cdots s_n}_{n}: \n                        s_i\\in L(e),\\ n\\geq 0\\}$`\n                       }}})\n\n              (:h2 \"Matching\")\n              #md {{{\n                     We say that a RE $e$ matches a string $s$ if\n                     $$ s\\in L(e) $$\n                     }}}\n            ); rows\n\n      #md {{{\n             *Definition*\n\n             \u003e A language $X$ is called _regular_\n             if there exists a RE $e$ such that $X = L(e)$.\n             }}}\n      ); page\n\n(:h1 \"Automaton\")\n\n(page (:h1 \"Definitions\")\n\n      (rows 8 4\n            #md {{{\n                   - We start with a collection of states.\n\n                   - One state is the _initial state_.\n\n                   - One or more states are the _accepting states_.\n\n                      \u003e They are also called _final states_.\n\n                   - Transitions are edges that connect _two_ states.\n\n                      - Each transition is labeled by a symbol from\n                        the alphabet `{a, b, c}` or a special symbol $\\epsilon$.\n\n                      - The source state and target state of a transition\n                        can be _different_ or _the same_.\n                   }}}\n            (image \"automaton.png\")\n            ))\n\n(page (:h1 \"Formal Definition\")\n      (box\n        #md {{{\n               *Definition*\n\n               An automaton is given by:\n\n               - A set of states: $S$\n\n               - An initial state: $s_0$\n\n               - An set of accepting states: $F\\subseteq S$\n\n               - An alphabet $\\Sigma$\n\n               - A transition function: \n                 `$\\Delta: S\\times (\\Sigma\\cup\\{\\epsilon\\})\\to\\mathbf{set}(S)$`\n\n               Any automaton can be written as a tuple:\n\n               `$$ A = \\left\u003c S,\\Sigma,\\Delta, s_0, F \\right\u003e$$`\n               }}})\n\n      #md {{{\n             This is also known as a _non-deterministic finite automaton_ (NFA).\n             }}}\n      ); page\n\n(page (:h1 \"Deterministic Finite Automaton (DFA)\")\n\n      #md {{{\n             An NFA is deterministic if:\n\n             1. There is no transitions labeled by $\\epsilon$.\n             2. For each state $s\\in S$, and a symbol $\\sigma\\in\\Sigma$, we have\n                $|\\Delta(s, a)| \\leq 1$.\n             }}}\n\n      #md {{{\n             So, the transition function is a _partial function_:\n\n             $$\\delta:S\\times \\Sigma\\to S$$\n             }}}\n\n      (banner #md {{{ DFA $\\subset$ NFA }}})\n      ); page\n\n(:h1 \"Defining Languages\")\n\n(page (:h1 \"Acceptance by NFA\")\n\n      #md {{{\n             Consider an automaton $A\\in\\mathbf{NFA}$, and a string $x\\in\\Sigma^*$.\n             \n             We say that $x$ is _accepted_ by $A$ if it is possible\n             for $A$ to make a series of transitions from the initial\n             state.\n             }}}\n\n      (box\n        #md {{{\n               *Definition*: Acceptance by NFA without $\\epsilon$.\n\n               Let $x\\in\\Sigma^*$ be a string with simples:\n               $$ x = x_1 x_2 \\dots x_n $$\n               \n               We say that $x$ is _accepted_\n               by an NFA `$A = \\left\u003cS,\\Sigma,\\Delta,s_0, F\\right\u003e$` if\n               there exists a sequence of states $s_0, s_1, s_2, \\dots s_n$\n               such that:\n\n               - $s_0$ is the initial state of $A$.\n               - $s_{i+1}\\in \\Delta(s_i, x_i)$ for all $i \u003e 0$.\n               - $s_n\\in F$.\n               }}})\n\n      (box\n        #md {{{\n               *Definition*: Language of NFA\n\n               `$$ L(A) = \\{x\\in\\Sigma^*: x\\mathrm{\\ is\\ accepted\\ by\\ } A\\}$$`\n               }}})\n      ); page\n\n\n(page (:h1 \"Acceptance by DFA\")\n      #md {{{\n             Recall that a DFA is a NFA without any $\\epsilon$ transitions\n             and each $\\Delta(s, \\sigma) = \\{s\u0027\\}$.\n\n             We can define the acceptance condition by DFA.\n             }}}\n      (box\n           #md {{{\n              *Definition*: Acceptance by DFA.\n\n               Let $x\\in\\Sigma^*$ be a string with simples:\n               $$ x = x_1 x_1 \\dots x_n $$\n               \n               We say that $x$ is _accepted_\n               by a DFA `$A = \\left\u003cS,\\Sigma,\\delta,s_0, F\\right\u003e$` if\n               there exists a sequence of states $s_0, s_1, s_2, \\dots s_n$\n               such that:\n\n               - $s_0$ is the initial state of $A$.\n               - $s_{i+1} = \\delta(s_i, x_i)$ for all $i\u003e0$.\n               - $s_{n}\\in F$.\n               }}})\n      ); page\n\n(page (:h1 \"Test for acceptance.\")\n\n      #md {{{\n             Can you design an algorithm to test the acceptance\n             of strings w.r.t.:\n\n             1. a NFA\n             2. a DFA\n             }}}\n      #md {{{\n             For NFA-acceptance and DFA-acceptance,\n             analyze the time complexity and space\n             complexity.\n             }}})\n\n(page (:h1 \"Questions to think about\")\n\n      #md {{{\n             - Compare $L(\\mathrm{DFA})$ \n             with $L(\\mathrm{NFA})$ with $L(\\mathrm{RE})$.\n             }}})\n\n(page (:h1 \"Equivalence of DFA and NFA-$\\\\epsilon$\")\n\n      #md {{{\n             ## `$\\epsilon$`-closure\n\n             An epsilon-closure of a state is a set of states\n             that can be reached only by taking epsilon transitions.\n\n             `$$\\mathrm{Closure}_\\epsilon(s) = \n             \\{s\u0027\\in S: s\\underset{\\epsilon^*}{\\longrightarrow} s\u0027\\}\n             $$`\n\n             For a set of sets $T\\subseteq S$, we define:\n             `$$\\mathrm{Closure}_\\epsilon(T) = \n             \\bigcup_{s\\in T}\\mathrm{Closure}_\\epsilon(s)$$`\n             }}}\n\n      (--*--)\n\n      #md {{{\n             ## NFA-$\\epsilon$ to DFA\n\n             Let $A$ be a NFA with epsilon transitions.  We will construct\n             a DFA $B$ with a (very) different set of states, but over the same\n             alphabet, and $L(A) = L(B)$.\n             }}}\n\n      #md {{{\n             Write $S^B = \\mathrm{Powerset}(S^A)$.\n\n             - Initial state: `$s^B_0 = \\{s^A_0\\}$`.\n             - Final states: `$F^B = \\{T\\subseteq S^A: T\\cap F^A\\not=\\emptyset\\}$`\n             - Transition:\n               `$\\delta^B(T, \\sigma) = \n               \\mathrm{Closure}_\\epsilon(\\Delta^A(T, \\sigma))$`\n             }}}\n\n      (box\n        #md {{{\n               *Theorem*:\n\n               - $B$ is a DFA.\n               - $L(B) = L(A)$.\n               }}})\n      ); page\n\n(page (:h1 \"From RE to NFA-$\\\\epsilon$\")\n      #md {{{\n             Let\u0027s show that NFA-$\\epsilon$\n             has the expressive power of RE\n             comes to defining languages.\n             }}}\n\n      (:h2 \"Recursive structure of RE\")\n      #md {{{\n             Base cases:\n\n             - $\\epsilon$ is a RE\n             - $a$ is a RE for each $a\\in\\Sigma$.\n\n             Inducitve cases\n\n             - $e|e\u0027$ is a RE if $e$ and $e\u0027$ are RE.\n             - $e e\u0027$ is a RE if $e$ and $e\u0027$ are RE.\n             - $e^*$ is a RE if $e$ is a RE.\n             - $(e)$ is a RE if $e$ is a RE.\n             }}}\n\n      (:h2 \"Converting RE to NFA\")\n\n      #md {{{\n             This is known as the _McNaughton-Yamada-Thompson_ algorithm.\n\n             \u003e For each inductive case, build a larger NFA from\n             more basic ones.\n             }}}\n      (rows :sep 6 6\n            #md {{{\n                Empty string: $\\epsilon$\n            }}}\n            (image \"re-empty.png\")\n\n            #md {{{\n                Single symbol: $a$ where $a\\in\\Sigma$.\n            }}}\n            (image \"re-a.png\")\n\n            #md {{{\n                   Alternation: $e_1 | e_2$.\n\n                   \u003e We construct two NFA `$N_1$` and `$N_2$`\n                   for each `$e_i$` respectively.  Then, we\n                   construct a larger NFA from $N_1$ and $N_2$\n                   as shown.\n                   }}}\n            (image \"re-or.png\")\n\n            #md {{{\n                   Concatenation: $e_1 e_2$\n                   }}}\n            (image \"re-concat.png\")\n\n            #md {{{\n                   Kleene star: $e^*$\n\n                   \u003e We short circuit the final state of $N(e)$\n                   to its initial state using $\\epsilon$ transition.\n                   }}}\n            (image \"re-star.png\")\n            ); rows\n      ); page\n\n(page (:h1 \"An Algorithm For RE Matching\")\n\n      (note #md {{{\n                   Complete the missing\n                   blocks yourself.\n                   }}})\n      (rows :sep 4 8\n            (:h2 \"A matching procedure\")\n            (code :python\n                  {{{\n                     def decide_match(pattern, string):\n                        # pattern : a RE\n                        # string: sequence of symbols\n                        ?\n                  }}})\n            #md {{{\n                   ## Compiling NFA\n\n                   First we convert RE pattern to NFA.\n                   }}}\n            (code :python\n                  {{{\n                     def pattern_to_NFA(pattern):\n                        ...\n                  }}})\n            #md {{{\n                   ## NFA Acceptance\n                   }}}\n            (code :python\n                  {{{\n                     def decide_acceptance(A, string):\n                        # A is a NFA\n                        # string is a sequence of symbols\n                        ...\n                  }}})\n\n            #md {{{\n                   ## Implementing RE matching\n                   }}}\n            (code :python\n                  {{{\n                     def decide_match(pattern, string):\n                        return decide_acceptance(\n                                 pattern_to_NFA(pattern),\n                                 string\n                               )\n                  }}})\n            ))\n",
                    "istop": false,
                    "path": "01.lexer/automaton"
                },
                "01.lexer/intro": {
                    "children": [],
                    "content": "{:title \"Regular Expressions, Languages \u0026 Parsing\"\n :status :ready\n :rank 1\n :summary #md {{{\n                 Regular expressions are patterns of _strings_.\n                 }}}\n}\n\n(page (:h1 \"Strings \u0026 Languages\")\n      (banner\n        #md {{{\n               This course is about communication.  In particular,\n               we are interested in the _communication with machines_\n               and _communication between machines_.\n               }}})\n\n      (:h2 \"Symbols \u0026 Strings\")\n\n      (rows :sep 8 4\n            #md {{{\n                   - An alphabet is a collection of symbols.\n                   - Some alphabets are quite small:\n                     \u003e Morse code has two symbols\n                   - Some alphabets are quite large:\n                     \u003e Literate Chinese alphabet has over 4000 symbols.\n                     }}}\n            (:div (image \"chinese-alphabet.png\")\n                  (image \"morse-alphabet.png\"))\n\n            #md {{{\n                   No matter how large an alphabet is, as long as it\u2019s finite,\n                   we cannot encode messages using _single_ symbols.\n\n                   - There are _infinite_ meaningful messages.\n                   - We need strings.\n                   }}}\n            (image \"morse-string.png\")\n            ); rows\n      (rows :sep 4 8\n            (:h2 \"Some Definitions\")\n            (:div\n            #md {{{\n                   An alphabet $\\Sigma$ is a finite set of symbols.\n                   }}}\n            #md {{{\n                   A _string_ is a _finite_ sequence of symbols\n                   from some alphabet.\n                   }}}\n            #md {{{\n                   A _language_ is a set of strings.  Most useful languages\n                   are _infinite_ sets.\n                   }}}\n            #md {{{\n                   The set of all possible strings from an alphabet $\\Sigma$\n                   is denoted $\\Sigma^*$.\n                   }}}\n\n            (note #md {{{\n                         The `*` in `$\\Sigma^*$` means we are representing a finite\n                         repetition of taking symbols from $\\Sigma$.  This is, in fact,\n                         part of _regular expression_, known as the _Kleene star_.\n                         }}}))\n\n            (:h2 \"Facts\")\n            #md {{{\n                   Let $L$ be a language.  Then $L\\subseteq\\Sigma^*$.\n                   }}}\n\n            (:h2 \"More definitions\")\n            #md {{{\n                   - The string with zero symbols is written $\\epsilon$ (epsilon).\n\n                   - A string is _valid_ with respect to a language $L$ if $s\\in L$.\n                     Otherwise, we say that $s$ is not valid wrt $L$.\n                     }}}\n\n            (:h2 \"Examples\")\n            (:div #md {{{\n                         Let\u0027s look at how natural languages fit into this framework.\n\n                         - English: EN\n                         - French: FR\n                         }}}\n                  #md {{{\n                         **Alphabets**\n\n                         French and English are two distinct languages over the\n                         two similar alphabets.\n                         }}}\n                  #md {{{\n                         - `$\\Sigma_\\mathrm{EN} = \\{a, b, c, d, e, f, ... z, A, B, C, D, E, ... Z\\} \\cup \\mathrm{Puntunations}$`\n                         - `$\\Sigma_\\mathrm{FR} = \\{a, \u00e0, b, c, d, e, \u00e8, \u00e9, f, ... z, A, \u00c0, B, C, D, E, ... Z\\} \\cup \\mathrm{Puntunations}$`\n                         }}}\n                  #md {{{\n                         **Languages**\n\n                         - `$\\mathrm{English}\\subseteq\\Sigma_\\mathrm{EN}^*$`\n                         - `$\\mathrm{French}\\subseteq\\Sigma_\\mathrm{FR}^*$`\n                         }}}\n                  #md {{{\n                         **Sentences** are strings in their respective languages.\n\n                         - `Bonjour \u00e0 tous` $\\in$ French, so it\u2019s a valid French string.\n                         - `Bonjour \u00e0 tous` $\\not\\in$ English, so it\u2019s *not* a valid English string.\n                         }}})\n\n            (:h2 \"Complexity \u0026 Expressiveness of Languages\")\n            (:div (banner #md {{{ Not all languages are equal.  }}})\n                  #md {{{\n                         - Simple languages, but not expressive.\n                         - Complex languages can be very expressive.\n                         }}}\n                  #md {{{\n                         In this course, we will study several families of\n                         languages, starting with the family of very\n                         simple languages, known as _regular languages_.\n                         }}}\n                  )\n            ); rows\n      ); page\n\n(page (:h1 \"Finite Representation of Languages\")\n\n      (banner #md {{{ \n                     How do we learn and use languages?\n\n                     We need to have _finite_ representations of infinite languages.\n                     }}})\n\n      (rows 4 8\n            (:h2 \"Patterns\")\n            (:div #md {{{\n                         Suppose we want to describe some langauge $L\\subseteq\\Sigma^*$.\n                         }}}\n                  #md {{{\n                         - One way to describe a language is to list all the possible\n                         _patterns_ of the strings in the language.\n\n                         - Each pattern represents _many_ strings of the language.\n                         }}})\n\n            (:h2 \"Language for patterns\")\n            (:div #md {{{\n                         $\\newcommand{\\pattern}{\\mathrm{PATTERN}}$\n                         **Alphabet**\n\n                         Let\u0027s start with the language of _patterns_.\n\n                         $$\\Sigma_\\pattern = \\Sigma \\cup \\{...\\}$$\n                         }}}\n                  #md {{{\n                         - The patterns need to mention the symbols of the language of interest.\n                         - We will need _additional_ symbols.\n                         }}}\n\n                  #md {{{\n                         **Pattern Language**\n\n                         We will present a language $L_\\pattern$, known as _regular expressions_, of patterns.\n\n                         - Each string in $e\\in L_\\pattern$ is a _regular expression_.\n                         - Each regular expression represents zero or more strings of $\\Sigma$.\n                         }}}\n                  )\n\n            )\n      )\n\n(page (:h1 \"Regular Expressions\")\n\n      (rows :sep 4 8\n            (:h2 \"The syntax: matching a single character\")\n            (:div #md {{{\n                         Single letter:\n\n                         \u003e `a`, `b`, ...\n                         }}}\n                  #md {{{\n                         Matching a single letter with character class:\n\n                         \u003e - `[abc]`: uses `[...]` to represent a character class.\n                         \u003e - `[a-z]`: you can specify a range\n                         \u003e - `[^a-z]`: you can negate a character class\n                         \u003e - `.`: matches any single character\n                         }}}\n                  )\n            \n            \n            (:h2 \"Predefined character classes\")\n            #md {{{\n                   - `\\w`: a word character, equivalent to `[a-zA-Z0-9_]`\n                   - `\\W`: not a word character, equivalent to `[^\\w]`\n                   - `\\d`: a digit, equivalent to `[0-9]`\n                   - `\\D`: not a digit\n                   - `\\s`: a whitespace character, equivalent to `[ \\t\\r\\n]`\n                   - `\\S`: a non-whitespace character\n                   - `^`: matches the start of a string when it appears outside `[...]`\n                   - `$`: matches the end of a string\n                   }}}\n\n            (:h2 \"Matching multiple characters\")\n            (:div #md {{{\n                         We will define regular expressions recursively. \n                         }}}\n                  #md {{{\n                         - Any character class is a regular expression.\n                           \u003e Match strings of length **one**.\n\n                         - Alternation: `$e_1$ | $e_2$`\n                           \u003e Match either pattern `$e_1$` or pattern `$e_2$`.\n\n                         - Concatenation: `$e_1$ $e_2$`\n                           \u003e Match strings that starts with pattern `$e_1$` followed\n                           by patterns `$e_2$`.\n\n                         - Repetition: `$e$ *`\n                           \u003e Matchs strings that consisting of patterns $e$ repeatedly\n                           zero or more times.\n                         }}}\n                  )\n\n            (:h2 \"Extended regular expressions\")\n            (:div #md {{{\n                         A number of syntactic additions have been added\n                         for convenience, but they are not strictly necessary\n                         as they can be expressed using existing features.\n                         }}}\n                  #md {{{\n                         - Finite repetition: `$e${m}`\n                           \u003e Matches pattern $e$ exactly `m` times.\n                         \n                         - Finite repetition: `$e${m,n}`\n                           \u003e Matches patterns $e$ at least `m` times, but at most `n` times.\n                           }}})\n\n            (:h2 \"Putting it together\")\n            (:div #md {{{\n                         We build regular expressions by combining simple expressions to\n                         form complex expressions.\n                         }}}\n                  #md {{{\n                         - `e1 = \\d+` \u003cbr\u003e a number.\n                         - `e2 = e1 (\u0027.\u0027 e1)?` \u003cbr\u003e a decimal\n                         - `e3 = (e2 \u0027,\u0027)*` \u003cbr\u003e zero or more comma separated numbers (ends with comma)\n                         - `e4 = e3 e2` \u003cbr\u003e a list comma separated numbers (with at least one number)\n                         - `e5 = (e4 \u0027\\n\u0027)*` \u003cbr\u003e one or more lines of comman separated numbers.\n                         }}}\n                  )\n            ); rows\n      ); page\n\n",
                    "istop": false,
                    "path": "01.lexer/intro"
                },
                "01.lexer/java-lexer": {
                    "children": [],
                    "content": "{:title \"Regular Expression Libraries\"\n :rank 3\n :summary #md {{{\n                 We will look at how regular expressions are quite useful\n                 in practice.  In particular, we will introduce the\n                 Java regular expression library, and how RE can be\n                 used to perform simple information extraction.\n                 }}}\n }\n\n(page (:h1 \"Java Regular Expression Library\")\n\n      (rows 4 8\n            (:h2 \"RE are Java Strings\")\n\n            (:div #md {{{\n                         RE are represented as plain Java strings.\n                         }}}\n                  #md {{{\n                         The import statements.\n\n                         ```\n                         import java.util.*;\n                         import java.io.BufferedReader;\n                         ```\n                         }}}\n                  #md {{{\n                         The pattern can be specified as:\n\n                         - dot-separated words: \u003cbr\u003e\n                           `(\\w+\\.)*\\w+`\n                         - optional wildcard: \u003cbr\u003e\n                           `(\\.\\*)?`\n                         - putting it all together: \u003cbr\u003e\n                           `import (\\w+\\.)*\\w+(\\.\\*)?;`\n                         }}}\n                  #md {{{\n                         Note the slash required in the pattern\n                         to indicate:\n\n                         \u003e `\\.` $\\not=$ `.` \u003cbr\u003e\u003cbr\u003e\n                         \u003e `\\*` $\\not=$ `*`\n                         }}}\n                  #md {{{\n                         But we have to represent the pattern as Java string:\n\n                         ```\n                         \"import (\\\\w+\\\\.)*\\\\w+(\\\\.\\\\*)?;\"\n                         ```\n\n                         \u003e The double `\\\\` in Java string is the `\\` character.\n                         }}}\n                  )\n            )\n      )\n\n(page (:h1 \"Java Pattern\")\n\n      (rows 4 8\n            (:h2 \"Package\")\n            (code :java\n                  {{{\n                     import java.util.regex.*;\n                     }}})\n\n            (:h2 \"Class and method\")\n            (code :java\n                  {{{\n                     class Pattern {\n                       Pattern compile(String regex);\n                       Pattern compile(String regex, int flags);\n                     }\n                     }}})\n\n            (:h2 \"Construction\")\n            (code :java\n                  {{{\n                     Pattern p = Pattern.compile(\"....\");\n\n                     int flag = Pattern.CASE_INSENSITIVE | Pattern.MULTILINE;\n\n                     Pattern p = Pattern.compile(\"...\", flag);\n                     }}})\n            )\n      )\n\n(page (:h1 \"Matchers\")\n\n      (rows 4 8\n            (:h2 \"Classe and construction\")\n            (:div #md {{{\n                         Pattern objects are _compiled_ regular expressions that\n                         define an entire _regular language_.\n\n                         To work with an individual string $s$, we need to construct\n                         an _matcher_ object from both a pattern and the string $s$.\n                         }}}\n                  (code :java\n                        {{{\n                           Pattern p = ...;\n                           String s = ...;\n                           Matcher matcher = p.matcher(s);\n                           }}}))\n\n            (:h2 \"Checking validity of string\")\n            (:div #md {{{\n                         We can check if the string $s$ belongs to the language\n                         defined by the pattern.\n                         }}}\n                  (code :java\n                        {{{\n                           // Attempts to match the \n                           // entire region against \n                           // the pattern.\n                           boolean isValid = matcher.matches();\n                           }}})\n                  )\n\n            (:h2 \"Finding the next occurrence\")\n            (:div #md {{{\n                         A matcher keep track of the _current_ position in the string\n                         to perform matching.\n\n                         The matcher finds a string in $L(p)$ starting at the _current position_.\n                         }}}\n\n                  (code :java\n                        {{{\n                           Pattern p = Patter.compile(\"\\\\d+\\\\s*\");\n                           String content = \"123 456 678\";\n                           Matcher m = p.matcher(content);\n                           }}})\n                  (code :java\n                        {{{\n                           while(m.find()) {\n                             int s = m.start();\n                             int e = m.end();\n                             out.printf(\"match [%d, %d]: %s\\n\",\n                                            s, e, content.substring(s, e));\n                           }\n                           }}})\n                  )\n\n            (:h2 \"Information Extraction\")\n            (:div #md {{{\n                         An extension to regular expressions is regular expressions with _groups_.\n\n                         A _group_ is a part of a regular expression in brackets:\n\n                         \u003e `... ( \u003cgroup\u003e ) ...`\n                         }}}\n\n                  #md {{{\n                         - A RE can have multiple groups: `(\\d+)\\.(\\d+)`\n                         - The groups can even be nested: \u003cbr\u003e\n                           `My name is ((\\w+) (\\w+))`.\n                         }}}\n\n                  #md {{{\n                         Each group is indexed, and can be extracted by `m.group(i)`:\n\n                         - `m.group(0)` is the region that matches the _entire_ region.\n                         - `m.group(1), m.group(2), ...` are regions that match individual groups.\n                         - The index of the groups is determined by the order of their _open_ bracket.\n                         }}}\n                  )\n\n            )\n      )\n\n(:h1 \"Lexical Analysis With Java Expressions\")\n\n(page (:h1 \"Lexical Analysis With Java Expressions\")\n\n      #md {{{\n             Let\u0027s explore how we might be able to perform lexical analysis\n             using the standard Java regular expression API.\n             }}}\n\n      #md {{{\n             We will build an alphabet of tokens.  Let\u0027s focus on the Java\n             programming language.\n             }}}\n\n      (rows 4 8\n            (:h2 \"What are tokens?\")\n            (:div #md {{{\n                         * Verbatim tokens\n\n                         - Keywords: `class`, `interface`, `for`, `while`, ...\n                         - Puntuations: `,`  `.`  `(`  `)`  `{`  `}`  `[`  `]`, ...\n                         - Arithmetics: `+`  `-`  `*`  `/`  `\u003c\u003c`  `\u003e\u003e`  ...\n                         }}}\n\n                  #md {{{\n                         * Patterns\n\n                         - Identifiers `[a-zA-Z_][a-zA-Z0-9_]*`\n                         - Integer: `\u0027\\d+\u0027`\n                         - Float: `((\\d+\\.\\d*) | (\\.\\d+))[fF]?`\n                         - Double: ...\n                         - String: `\"\\\"[^\\\"]+\\\"\"`\n                         }}}\n                  )\n\n            (:h2 \"A token class\")\n            (:div #md {{{\n                         Here is a Java enum implemenation that represents\n                         tokens.\n                         }}}\n                  (code :java\n                        {{{\n                           public enum Token {\n                             KEYWORD_CLASS     (\"class\"),\n                             KEYWORD_INTERFACE (\"interface\"),\n                             KEYWORD_FOR       (\"for\"),\n                             KEYWORD_WHILE     (\"while\"),\n\n                             COMMA             (\",\"),\n                             STRING            (\"\\\\\\\"[^\\\\\\\"]*\\\\\\\"\"),\n                             ID                (\"[a-zA-Z]\\\\w*\"),\n                             \n                             WHITESPACE        (\"\\\\s+\");\n\n                             // -----------------------------------\n                             // Exercise: more token types for Java\n                             // -----------------------------------\n\n                             Pattern pattern;\n                             Token(String regex) {\n                               this.pattern = Pattern.compile(regex);\n                             }\n                           }\n                           }}})\n                  #md {{{\n                         A few words about Java enum classes:\n\n                         - Enum instances can be listed, as an array, by:\n                           ```\n                           Token.values()\n                           ```\n                         - It\u0027s safe to use `==` to perform comparison of enum instances.\n                         }}}\n                  (code :java\n                        {{{\n                           for(Token t: Token.values()) {\n                             out.printf(\"[%d]: %s\\n\", t.ordinal(), t.name());\n                           }\n                           }}})\n                  )\n            (:h2 \"Lexical analysis\")\n            (:div #md {{{\n                         Using Java regex, we can perform lexical analysis as follows:\n\n                         - Declare a list of token types.  Each token type has a regular expression as a _pattern_.\n                         - Given a string, we scan from _left to right_, and match the start of the string against\n                         all token types.  The token with the longest match will be reported.\n                         - Advance the string to the end of the previous match.\n                         }}}\n                  (code :java \n                        {{{\n                           class TokenWithLexeme {\n                             Token token;\n                             String lexeme;\n                           }\n\n                           // returns null if there is no match\n                           TokenWithLexeme matchPrefix(Token t, String s) {\n                             ...\n                           } \n                           }}})\n                  (code :java\n                        {{{\n                           // What\u0027s the next token\n                           Optional\u003cTokenWithLexeme\u003e next(String s) {\n                             return Arrays\n                                    .stream(Token.values())\n                                    .map(t -\u003e matchPrefix(t, s))\n                                    .filter(m -\u003e (m != null))\n                                    .max((m1, m2) -\u003e {\n                                          int a = m1.lexeme.length();\n                                          int b = m2.lexeme.length();\n                                          return Integer.compare(a, b);\n                                        });\n                           }\n                           }}})\n                  (code :java\n                        {{{\n                           // Generate all tokens\n                           Stream\u003cTokenWithLexeme\u003e analyze(StringBuilder s) \n                              throws Exception {\n                             Stream\u003cToken\u003e T = Stream.empty();\n\n                             while(s.length() \u003e 0) {\n                               Optional\u003cTokenWithLexeme\u003e tok = next(s.toString());\n\n                               if(! tok.isPresent())\n                                 throw new Exception();\n\n                               T = Stream.concat(T, Stream.of(tok));\n\n                               s.delete(0, tok.lexeme.length());\n                             }\n                             \n                             return T;\n                           }\n                           }}})\n\n                  (code :java\n                        {{{\n                           // Let\u0027s ignore whitespaces\n                           analyze(s).filter(t -\u003e t.token != Token.WHITESPACE)\n                           }}})\n                  )\n            )\n      )\n\n(page (:h1 \"Conclusion\")\n\n       #md {{{\n              - The RE API\n              - Stream API\n\n              ---\n\n              Java can be used to build a pattern based lexical analyzer.\n              }}}\n\n       (rows 6 6\n             #md {{{\n                    # Why?\n\n                    - No external tools or libraries required.\n                    - Maximum flexibility over the lexical analysis\n                    and token structures (e.g. source file position).\n                    }}}\n             #md {{{\n                    # Why not?\n\n                    - Lots of _boilerplate_ code.\n                    - We only want to indicate:\n                      - Token types and their patterns.\n                      - Ignore whitespace or not.\n                      }}})\n\n       #md {{{\n        **Did you know?**\n\n        \u003e The token generation can be done\n        much faster if we use automaton based recognizer.\n        }}})\n",
                    "istop": false,
                    "path": "01.lexer/java-lexer"
                },
                "01.lexer/lexer": {
                    "children": [],
                    "content": "{:title \"Lexical Analyzer\"\n :rank 2\n :summary #md {{{\n                 We will introduce the process of lexical analysis.\n                 }}}\n }\n\n(page (:h1 \"Choose the alphabet\")\n\n      #md {{{\n             $$ L \\subseteq \\Sigma^* $$\n\n             But what is the alphabet $\\Sigma$?\n             }}}\n\n      (rows 4 8\n            (:h2 \"Java as a formal language\")\n            #md {{{\n                   Let\u0027s consider the language $L$ to be Java.\n\n                   - Each string $L$ is a _valid_ Java program.\n                   - We don\u0027t have enough expressive power to describe $L$.\n                   - So, we will simply discuss the choice over $\\Sigma$.\n                   }}}\n            )\n      )\n\n(page (:h1 \"Character based alphabet\")\n\n      #md {{{\n             $\\newcommand{\\char}{\\mathrm{CHAR}}$\n             Let\u0027s consider the choice of the character based alphabet:\n\n             `$$\\Sigma_\\char = \\{a, b, c, d, \\dots, z, A, B, C, \\dots, Z, \\dots\\}$$`\n\n             Each _character_ is a **symbol**.\n             }}}\n\n      (rows 4 8\n            (:h2 \"A sample Java string\")\n            (code :java\n                  {{{\n                     interface Adder {\n                       int adder(int a, int b);\n                     }\n                     }}})\n\n            (:h2 \"Let\u0027s think in terms of symbols.\")\n            (:div #md {{{\n                         `interface ...` $\\to$ `i-n-t-e-r-f-a-c-e ...`\n                         }}}\n                  #md {{{\n                         **How many symbols in $s$?**\n\n                         \u003e 47 characters = 47 symbols (including whitespaces)\n                         }}}\n                  #md {{{\n                         Q: Does it matter?\n\n                         \u003e More on this later.\n                         }}}\n                  )\n            )\n      )\n\n(page (:h1 \"Binary alphabet\")\n\n      #md {{{\n             $\\newcommand{\\bin}{\\mathrm{BIN}}$\n             We will compare how things work out if we use a binary alphabet:\n             `$ \\Sigma_\\bin = \\{0, 1\\} $`\n             }}}\n\n      (rows 4 8\n            (:h2 \"Same sample Java program\")\n            (code :java\n                  {{{\n                     interface Adder {\n                       int adder(int a, int b);\n                     }\n                     }}})\n            #md {{{ ## What is $s$ over $\\Sigma_\\bin$? }}}\n            (:div #md {{{\n                         Each symbol is a bit.\n                         \u003e `i` $\\to$ 105 $\\to$ `01101001` \u003cbr\u003e\n                         \u003e `n` $\\to$ 110 $\\to$ `01101110` \u003cbr\u003e\n                         \u003e ...\n                         }}}\n                  (code {{{\n                           0110100101101110011101000110010101110010011001100110000\n                           1011000110110010100100000010000010110010001100100011001\n                           0101110010001000000111101100001010001000000010000001101\n                           0010110111001110100001000000110000101100100011001000010\n                           1000011010010110111001110100001000000110100100101100001\n                           0000001101001011011100111010000100000011010100010100100\n                           1110110000101001111101\n                           }}})\n                  #md {{{\n                         Q: How many symbols?\n\n                         \u003e 47 characters = 376 bits = 376 symbols\n                         }}}\n                  )\n            (:h2 \"Problems with this choice of alphabet\")\n            (:div #md {{{\n                         Communication using $\\Sigma_\\bin$ is almost impossible.\n\n                         \u003e We cannot write Java in binary...\n                         }}}\n                  #md {{{\n                         Inefficient for _algorithms_ to process long binary strings.\n                         }}}\n                  )\n            )\n      )\n\n(page (:h1 \"Changing alphabets\")\n\n      (rows 4 8\n            (:h2 \"Conversion\")\n            #md {{{\n                   If we have a Java program encoded over `$\\Sigma_\\bin$`, we can quite easily convert it\n                   a string in $\\Sigma_\\char$.\n                   }}}\n            (:h2 \"Conversion in Python\")\n            (code :python\n                  {{{\n                     def h(s):\n                       return [chr(int(s[i:i+8], 2)) for i in range(0, len(s), 8)]\n                     }}})\n\n            (:h2 \"Transformation\")\n            #md {{{\n                   Changing alphbet in this case is relatively easy:\n\n                   \u003e `$h: \\Sigma_\\bin^* \\to \\Sigma_\\char^*$` \u003cbr\u003e \u003cbr\u003e\n                   \u003e `$g: \\Sigma_\\char^* \\to \\Sigma_\\bin^*$` (exercise)\n                   }}}\n            )\n      )\n\n(page (:h1 \"Towards a better alphabet\")\n\n      #md {{{\n             Can we get _better_ representation of Java programs\n             than $\\Sigma_\\char$?\n\n             \u003e Yes.\n             }}}\n\n      (rows 4 8\n            (:h2 \"Objective\")\n            #md {{{\n                   $\\Sigma$ determines the string that represents\n                   our Java program (interface `Adder`).\n\n                   We want to better _describe_ the language of **Java**.\n                   }}}\n\n            (:h2 \"Alphabet for Java\")\n            #md {{{\n                   - `\u0027interface\u0027` as a single symbol.\n                   - `\u0027{\u0027`, `\u0027}\u0027`, `\u0027(\u0027`, `\u0027)\u0027`, `\u0027;\u0027`, `\u0027,\u0027`\n                   - `TYPE` - we use _one_ symbol for all Java data types.\n                   - `ID` - we use _one_ symbol for all Java identifiers (e.g. variable names).\n                   }}}\n\n            (:h2 \"New representation\")\n            (:div (code :java\n                  {{{\n                     interface Adder {\n                       int adder(int a, int b);\n                     }\n                     }}})\n                  #md {{{\n                         ```\n                         \u0027interface\u0027 ID \u0027{\u0027\n                             TYPE ID \u0027(\u0027 TYPE ID \u0027,\u0027 TYPE ID \u0027)\u0027 \u0027;\u0027\n                         \u0027}\u0027\n                         ```\n                         }}}\n\n                  #md {{{\n                         There are 14 symbols used in the representation.\n\n                         \u003e It will be the type of representation we will work with\n                         to reason about programs.\n\n                         Let\u0027s call this alphabet $\\Sigma_0$.\n                         \u003e `$h : \\Sigma_\\char^* \\to \\Sigma_0^*$`\n                         }}}\n              )\n\n            (:h2 \"Tokens and lexemes\")\n            (:div #md {{{\n                         But the new representation using $\\Sigma_0$ is _highly_ lossy.\n                         }}}\n                  #md {{{\n                         The solution is that we _annotate_ each symbol with additional information.\n                         }}}\n                  #md {{{\n                         ```\n                         \u0027interface\u0027   ID   \u0027{\u0027  TYPE      ID   ...\n                                      ----       ----     ----\n                                    \"Adders\"     \"int\"   \"adder\"\n                         ```\n                         }}}\n                  #md {{{\n                         **Token**\n\n                         \u003e A token is a symbol _with_ additional annotation.\n\n                         _Example_: \n                         \n                         - (`ID`, \"Adder\")\n                         - (`TYPE`, \"int\")\n                         }}}\n\n                  #md {{{\n                         **Lexeme**\n\n                         \u003e The lexeme of a token is the part of the characters that is\n                         associated with the token.\n                         }}}\n                  )\n            (:h2 \"Lexical Analyzer\")\n            (:div #md {{{\n                         **Lexical Analyzer**\n\n                         \u003e A lexical analyzer is a function that\n                         \u003e maps a character-based string to a string of _tokens_.\n                         \u003e \n                         \u003e $\\newcommand{\\lex}{\\mathrm{lex}}$\n                         \u003e `$$\\lex : \\Sigma_\\char^* \\to \\mathrm{Token}^* $$`\n                         }}}\n\n                  #md {{{\n                         Given a string $s\\in\\Sigma_\\char^*$, computing\n                         the sequence of tokens $\\lex(s)$ is called performing\n                         lexical analysis of $s$.\n                         }}}\n                  )\n            )\n      )\n\n(page (:h1 \"Building lexical analyzers with RE\")\n      (rows 4 8\n            (:h2 \"Defining token types\")\n            #md {{{\n                   We need to define the symbols of $\\Sigma_0$.\n\n                   - TYPE\n                   - ID\n                   - ...\n\n                   They are called _token types_.\n                   }}}\n            (:h2 \"Defining lexeme patterns\")\n            (:div #md {{{\n                         For each token type, we can define all possible lexemes using a regular expression.\n\n                         - `$\\mathrm{pattern}(\\mathrm{TYPE}) =$ int | float | double`\n                         - `$\\mathrm{pattern}(\\mathrm{ID}) = $ [a-zA-Z_] ([a-zA-Z0-9_])*`\n                         }}}\n                  #md {{{\n                         The patterns of lexeme are given as a mapping:\n\n                         \u003e $\\mathrm{patterns} : \\Sigma_0 \\to \\mathrm{RE}$\n                         \u003cbr\u003e\n                         }}})\n\n            (:h2 \"Lexical analysis with greedy matching\")\n            (:div #md {{{\n                         Given a string $s\\in\\Sigma_\\char^*$.\n\n                         - We scan a string left-to-right.\n                         - We try to match against the token patterns.\n                         - If one or more patterns match, we generate a token using the _longest_ lexeme.\n                         }}}\n                  )\n            )\n      )\n\n(slide (:h1 \"Conclusion\")\n\n      #md {{{\n             Source code is written in characters, so they are strings\n             in $\\Sigma_\\char^*$.\n             }}}\n\n      #md {{{\n             For the purpose of describing languages and analysis of programs, we choose to represent source code\n             in tokens.\n             }}}\n\n      #md {{{\n             Lexical analysis is the process of partitioning source code to a sequence of tokens.\n             }}}\n      )\n",
                    "istop": false,
                    "path": "01.lexer/lexer"
                },
                "02.grammars": {
                    "children": ["02.grammars/ambiguity", "02.grammars/intro", "02.grammars/parse", "02.grammars/transformations"],
                    "content": "{:title \"Context Free Grammars\"\n :summary #md {{{\n                 We introduce a more powerful\n                 formalism, known as _context free grammars_, to specify\n                 languages.\n                 }}}\n}\n",
                    "istop": false,
                    "path": "02.grammars"
                },
                "02.grammars/ambiguity": {
                    "children": [],
                    "content": "{:title \"Ambiguity revisited\"\n :rank 3\n :summary #md {{{\n                 We will look further into ambiguity in\n                 the context of grammar rewriting. We will\n                 show how one can _rewrite_ the productions\n                 to preserve the language, but remove\n                 ambiguities in the grammar.\n                 }}}\n }\n\n(:h1 \"Grammar rewrite\")\n\n(page (:h1 \"Grammars and ambiguity\")\n      \n      #md {{{\n             We say that two grammars\n             $G$ and $G\u0027$ are equivalent if\n             they define the same language\n\n             $$ L(G) = L(G\u0027) $$\n             }}}\n\n      (note #md {{{\n                   Recall that _ambiguity_\n                   is regarding parse trees\n                   of sentences, and has nothing to\n                   do with the senteneces themselves.\n                   }}})\n      #md {{{\n             Ambiguity is an (undesirable) property\n             of a grammar $G$, but not its language\n             $L(G)$.\n             }}}\n\n      #md {{{\n             So, can we rewrite the grammar to\n             preserve the language, but remove\n             the ambiguity?\n             }}}\n\n      (box (:h2 \"Limitations of computation\")\n\n           #md {{{\n                  *Theorem*: (Rohit Parikh, 1961)\n\n                  \u003e There exists an inherently ambiguous\n                  language.\n                  }}}\n\n           (--*--)\n\n           #md {{{\n                  *Theorem*: (Emil Post, 1946)\n\n                  \u003e Recognizing ambiguity in an arbitrary\n                  grammar is _undecidable_.\n                  }}}\n           )\n      ); page\n\n(page (:h1 \"Examples of ambiguity\")\n\n      (:h2 \"Arithmetics\")\n\n      #md {{{\n             We have seen the ambiguity in\n             arithmetic expressions if the grammar\n             is defined as:\n\n             ```\n             E : 0 | 1 | 2 | ... | 9\n               | E + E\n               | E * E\n             ```\n             }}}\n\n      #md {{{\n             Here are _two_ different parse trees\n             of the _same_ sentence in $L(E)$:\n\n             The sentence is $a + b * c$, where $a,b,c$\n             are digits.\n\n             ```\n                      E               E\n                    / | \\           / | \\\n                   E  *  E         E  +  E\n                 / | \\   |         |   / | \\\n                E  +  E  c         a  E  *  E\n                |     |               |     |\n                a     b               b     c\n             ```\n\n             Clearly, the two are very different\n             interpretations of the same expression.\n             }}}\n\n      (:h2 \"If-then-else\")\n\n      #md {{{\n             Another example of ambiguous grammar\n             is in the definition of `if-then-else`\n             in procedural languages.\n             }}}\n\n      (html {:class \"bookie-target markdown\"}\n            {{{\n          \u003cpre\u003e\n          stmt : \u003cb\u003eif\u003c/b\u003e expr \u003cb\u003ethen\u003c/b\u003e stmt\n               | \u003cb\u003eif\u003c/b\u003e expr \u003cb\u003ethen\u003c/b\u003e stmt \u003cb\u003eelse\u003c/b\u003e stmt\n               | \u003ci style=color:blue\u003eother...\u003c/i\u003e \n          \u003c/pre\u003e\n              }}})\n\n      #md {{{\n             Consider a sentence:\n\n             ```\n             if E$_1$ then S$_1$ else if E$_2$ then S$_2$ else S$_3$\n             ```\n             }}}\n\n      (row 3 9 \n           #md {{{ \n                  The parse tree as given.\n                  It is the _only_ parse tree for the given\n                  sentence.  So there is *no* ambiguity in\n                  interpreting the given sentence.\n                  }}}\n           (image \"parse-tree.png\"))\n\n      #md {{{\n             But now, let\u0027s consider another sentence.\n\n             ```\n             if E$_1$ then if E$_2$ then S$_1$ else S$_2$\n             ```\n\n             This is called the _dangling-else_ statement.\n\n             It has *two* distinct parse trees.\n             }}}\n\n      (rows :sep 3 9\n            #md {{{\n                   This is the first parse tree.\n                   }}}\n            (image \"ambig-1.png\")\n\n            #md {{{\n                   This is the second parse tree.\n                   }}}\n            (image \"ambig-2.png\")\n\n            (:h2 \"Challenge:\")\n            #md {{{\n                   Can you come up with an instance\n                   for E_$1$, E_$2$, S$_1$, S$_2$ such\n                   that the two parse trees\n                   execute very different statements.\n                   }}}\n            ); rows\n      ); page\n\n(page (:h1 \"Eliminating Ambiguity\")\n\n       #md {{{\n              The objective is to rewrite a grammar\n              to remove any ambiguity.\n              }}}\n\n       #md {{{\n              But this is not always possible for two reasons:\n\n              1. Inherent ambiguity -- Parikh\u0027s theorem\n              2. Ambiguity is undecidable -- Post\u0027s theorem\n              }}}\n\n       #md {{{\n              _Revised objective_\n\n              \u003e We want to identify _known_ ambiguous fragments\n              of the grammar, and fix them.\n              }}}\n\n       #md {{{\n              We are able to eliminate the ambiguity of arithmetic expressions\n              and if-then-else statements.\n              }}}\n\n       (:h2 \"Eliminating ambiguity in arithmetics\")\n\n       (rows :sep 4 8\n             (:h2 \"Intuition\")\n             (:div\n               #md {{{\n                      Consider a potentially ambiguous expression:\n\n                      ```\n                      1 + 2 * 3 + 4 * 5\n                      ```\n                      }}}\n               #md {{{\n                      We have been taught in school that `*`\n                      takes precedence over `+`, so tradition\n                      suggests the following order of evaluation:\n\n                      ```\n                      1 + (2 * 3) + (4 * 5)\n                      ```\n                      }}}\n               #md {{{\n                      Let\u0027s give some definition:\n\n                      - An _expression_ is one or more _terms_ added together.\n                      - A _term_ is one or more _factors_ multiplied together.\n                      - A _factor_ is either a number or an expression\n                      that is explicitly enclosed by parentheses.\n                      }}})\n             (:h2 \"The complete BAD ambiguous grammar\")\n             #md {{{\n                    ```\n                    E : Number\n                      | E * E\n                      | E / E\n                      | E + E\n                      | E - E\n                      | ( E )\n                    ```\n                    We have added a few productions to support\n                    richer arithmetics.\n                    }}}\n\n             (:h2 \"The unambiguous but equivalent rewrite\")\n             #md {{{\n                    ```\n                    E : Term\n                      | Term + E\n                      | Term - E\n\n                    Term : Factor\n                         | Factor * Term\n                         | Factor / Term\n\n                    Factor : Number\n                           | ( E )\n                    ```\n                    }}}\n\n             (:h2 \"Challenge\")\n             (:div\n               #md {{{\n                      Is `1 + 2 * 3` a sentence of the new grammar?\n                      }}}\n               #md {{{\n                      How many distinct parse trees can be construct\n                      for `1 + 2 * 3`?\n                      }}})\n             ); rows\n       ); page\n\n(page (:h1 \"Eliminating dangling-else ambiguity\")\n\n      (rows 4 8\n            (:h2 \"Intuition\")\n            #md {{{\n                   We distinguish two types of if-... statements\n\n                   1. matched statements\n                      \u003e It\u0027s either a non-if statement, or\n                      a if-then-else statement.\n\n                   2. open statements\n                      \u003e It\u0027s either a if-then statement (without else)\n                      or it\u0027s a if-then-else statement but\n                      with an open statement in the else.\n                      }}}\n\n            (:h2 \"The BAD ambiguous grammar\")\n            (html {:class \"bookie-target markdown\"}\n            {{{\n            \u003cpre\u003e\n            stmt : \u003cb\u003eif\u003c/b\u003e expr \u003cb\u003ethen\u003c/b\u003e stmt\n                 | \u003cb\u003eif\u003c/b\u003e expr \u003cb\u003ethen\u003c/b\u003e stmt \u003cb\u003eelse\u003c/b\u003e stmt\n                 | \u003ci style=color:blue\u003eother...\u003c/i\u003e \n            \u003c/pre\u003e\n              }}})\n\n            (:h2 \"The unambiguous grammar\")\n            (html {:class \"bookie-target markdown\"}\n                  {{{\n                     \u003cpre\u003e\n                     stmt : matched_stmt\n                          | open_stmt\n\n                     matched_stmt : \u003cb\u003eif\u003c/b\u003e expr \u003cb\u003ethen\u003c/b\u003e matched_stmt \u003cb\u003eelse\u003c/b\u003e matched_stmt\n                                  | \u003ci style=color:blue\u003eother...\u003c/i\u003e\n\n                     open_stmt : \u003cb\u003eif\u003c/b\u003e expr \u003cb\u003ethen\u003c/b\u003e stmt\n                               | \u003cb\u003eif\u003c/b\u003e expr \u003cb\u003ethen\u003c/b\u003e matched_stmt \u003cb\u003eelse\u003c/b\u003e open_stmt\n                     \u003c/pre\u003e\n                     }}})\n\n            (:h2 \"Challenge\")\n            (:div\n              #md {{{\n                     Is `if E1 then if E2 then S1 else S2` a sentence in the language?\n                     }}}\n              #md {{{\n                     Can you construct two distinct parse tree for it?\n                     }}})\n            ); rows\n      ); page\n\n(page (:h1 \"Grammar Design\")\n       #md {{{\n              Rewriting grammar to remove ambiguity is:\n\n              1. No fun.\n              2. Cannot be automated.\n              }}}\n       #md {{{\n              What if we can avoid ambiguity right at the beginning?\n              }}}\n\n       (rows 4 8\n             (:h2 \"Redesigning arithmetics\")\n             (:div\n               #md {{{\n                      ```\n                      E : F\n                        | F + F\n                        | F * F\n\n                      F : Number\n                        | ( E )\n                      ```\n                      }}}\n               #md {{{\n                      Is `1 + 2 * 3` a sentence of the language?\n\n                      - No.\n                      }}}\n               #md {{{\n                      Is the new language ambiguous?\n\n                      - No.\n                      }}}\n               #md {{{\n                      Is this new language design a good idea?\n\n                      - Probably not.\n                      }}}\n               )\n\n             (:h2 \"Redesigning if-then-else\")\n             (:div\n               #md {{{\n                      stmt : if expr then { stmt }\n                           | if else then { stmt } else { stmt }\n                           | other...\n                      }}}\n               #md {{{\n                      Is `if E1 then if E2 then S1 else S2`\n                      a sentence of the new language?\n\n                      - No.\n                      }}}\n               #md {{{\n                      Is the new language ambiguous?\n\n                      - No.\n                      }}}\n               #md {{{\n                      Is the new language design a good idea?\n\n                      - Probably.\n                      }}}\n               )\n             ); rows\n       ); page\n\n(page (slide (:h1 \"Summary\")\n             #md {{{\n                    - Ambiguity leads to unpredictable execution of code.\n\n                    - Sometimes, we can _eliminate_ the ambiguity by means of\n                    grammar rewriting while _preserving the language_.\n\n                    - Sometimes, we can _redesign_ the _language_ so the grammar\n                    does not contain any ambiguity at the first place.\n                    }}}))\n",
                    "istop": false,
                    "path": "02.grammars/ambiguity"
                },
                "02.grammars/intro": {
                    "children": [],
                    "content": "{:title \"Introducing Context Free Grammar\"\n :rank 1\n :summary #md {{{\n                 We define _context free grammar_ (CFG) as\n                 a new way of defining languages\n                 }}}\n }\n\n(:h1 \"A Need For Expressive Power\")\n(page (:h1 \"Programming Languages\")\n\n      (banner #md {{{\n                     _Q_: Is the Java programming language a regular language?\n                     }}})\n\n      #md {{{\n             We want to define the syntaxes of programming languages using\n             pattern based specifications.\n\n             - Define a pattern $\\mathcal{L}$.\n             - Given a source code $x$, we can check if it is well-defined\n             as a programming language by performing:\n\n                \u003e ```\n                \u003e decide_match($\\mathcal{L}$, $x$)\n                \u003e ```\n\n             - Can we define $\\mathcal{L}$ for Java using a RE pattern?\n             }}}\n\n      (banner #md {{{\n                     No...\n                     }}})\n      )\n(:style {{{\n           .symbol {padding: 4px; background: #555; color: white} \n        }}})\n(page (:h1 \"A non-regular language\")\n      #md {{{\n             Consider the language with `$\\Sigma$` having two symbols:\n             \u003cspan class=\"symbol\"\u003e(\u003c/span\u003e and \n             \u003cspan class=\"symbol\"\u003e)\u003c/span\u003e.\n             }}}\n      (rows :sep 4 8\n            (:h2 \"A language\")\n            #md {{{\n\n                   ```\n                   $\\epsilon$\n                   ()\n                   (())\n                   ((()))\n                   (...()...)\n                   ```\n                   }}}\n\n            (:h2 \"Definition\")\n            #md {{{\n                   `$L = \\{xy: x\\in\\{(\\}^*,\\ y\\in\\{)\\}^*, |x| = |y|\\}$`\n                   }}}\n\n            (:h2 \"Bounded Balanced Parenthesis\")\n            (:div\n              #md {{{\n                     `$L_n = \\{xy: x\\in\\{(\\}^*,\\ y\\in\\{)\\}^*, |x| = |y|,\\ |x|\\leq n\\}$`\n                     }}}\n              #md {{{\n                     *Theorem*:\n\n                     \u003e $L_n$ is regular, and requires $2n$ states.\n                     }}})\n\n            (:h2 \"Unbounded Balanced Parenthesis\")\n            (:div\n              #md {{{\n                     $L = \\lim_{n\\to\\infty} L_n$, and it requires unbounded number\n                     of states.\n\n                     Therefore no finite automaton can capture $L$.\n                     }}})\n\n            (:h2 \"Hinting the difficulties with programming languages\")\n            #md {{{\n                   Clearly, $L$ is a necessary sublanguage of any reasonable\n                   programming language.\n\n                   So, any nontrivial programming language is non-regular.\n                   }}}\n            ); rows\n      )\n\n(:h1 \"Context Free Grammar\")\n\n(page (:h1 \"Definition\")\n      (rows :sep 4 8\n            (:h2 \"Symbols\")\n            #md {{{\n                   We distinguish the alphabet into two types of symbols:\n\n                   - _Terminals_: $\\Sigma_0$\n\n                   - _Nonterminals_: $\\Sigma_1$.  They are also called _syntactic variables_.\n\n                   The alphabet `$\\Sigma = \\Sigma_0\\cup\\Sigma_1$`.\n                   }}}\n\n            (:h2 \"Start symbol\")\n            #md {{{\n                   There is a special syntactic variable $S\\in\\Sigma_1$.\n                   }}}\n\n\n            (:h2 \"Production rule\")\n            #md {{{\n                   A production rule is of the form:\n\n                   $A : \\alpha$, where\n\n                   - `$A\\in\\Sigma_1$` -- this is called the head of the production.\n                   - `$\\alpha\\in(\\Sigma_0\\cup\\Sigma_1)^*$` -- this is called the body of the production.\n                   }}}\n\n\n            (:h2 \"Context Free Grammar (CFG)\")\n            #md {{{\n                   A CFG is a collection of productions, and a start symbol.\n\n                   `$$G = \\left\u003cS, \\{A_i : \\alpha_i\\}_{i\\leq n}\\right\u003e$$`\n\n                   where:\n\n                   - $S\\in\\Sigma_1$,\n                   - Each $A_i\\in\\Sigma_1$\n                   - Each $\\alpha_i\\in\\Sigma^*$\n                   }}}\n            ); rows\n\n      #md {{{\n             $G$ defines a language $L(G)\\subseteq\\Sigma_0^*$.\n             }}}\n      ); page\n\n(page (:h1 \"Derivation\")\n      (rows :sep 4 8\n            (:h2 \"Intuition\")\n            #md {{{\n                   - Productions are rules describing how the head\n                   can be replaced by its body.\n\n                   - Given a sequence of symbols `$x_1 x_2 \\dots$`\n                   our objective is to _replace_ syntactic variables\n                   using some production. \n                   }}}\n\n            (:h2 \"Derivation\")\n            #md {{{\n                   Given a string $x = x_1 x_2 \\dots x_n$,\n                   where $x_i$ is either a terminal or a syntactic variable.\n\n                   We can perform _derivation_ using a production of the form:\n                   \n                   $$ p =  x_i : \\alpha $$\n\n                   `$$x \\underset{p, i}{\\longrightarrow} x_1x_2\\dots x_{i-1}\\ \\alpha\\ x_{i+1}x_{i+2}\\dots x_n$$`\n\n                   We may omit the subscripts in the derivation if it is clear.\n                   }}}\n\n            (:h2 \"Example\")\n            (:div\n              #md {{{\n                     Given the grammar:\n\n                     ```\n                     E : ab\n                     E : aEb\n                     ```\n                     }}}\n              #md {{{\n                     We can have the following derivations:\n\n                     ```\n                     E --\u003e aEb\n                     aEb --\u003e aabb\n                     aEb --\u003e aaEbb --\u003e aaabbb\n                     ```\n                     }}})\n\n            (:h2 \"More on derivation\")\n            #md {{{\n                   We generalize derivation $\\longrightarrow$ by taking one or more steps of derivation:\n\n                   - $x\\Rightarrow x$\n                   - If $x\\Rightarrow y$ and $y\\underset{p,i}{\\longrightarrow} z$, then\n                     $x\\Rightarrow z$.\n                   }}}\n\n            (:h2 \"Example\")\n            #md {{{ \n                   Recall:\n\n                   ```\n                   E --\u003e aEb\n                   aEb --\u003e aabb\n                   aEb --\u003e aaEbb --\u003e aaabbb\n                   ```\n\n                   We can conclude:\n                   ```\n                   E ==\u003e aabb\n                   E ==\u003e aaEbb\n                   E ==\u003e aaabbb\n                   ```\n                   }}}\n\n            (:h2 \"Notation\")\n            (:div\n              #md {{{\n                     Multiple productions can share the _same_ head.\n                     We can simplify the notation using _alternation_:\n                     }}}\n              (row 6 6\n                   (code {{{\n                            E : a E b\n                            E : ab\n                            }}})\n                   (code {{{\n                            E : a E b | ab\n                            }}})))\n            ); rows\n      ); page\n\n(page (:h1 \"Defining a language\")\n      (box\n        #md {{{\n               *Definition*\n\n               - A string $\\alpha\\in(\\Sigma_0\\cup\\Sigma_1)^*$ is called a sentential\n               form if $S\\Rightarrow\\alpha$.\n\n               - A string $\\alpha$ is a sentence if\n               $\\alpha$ is a sentential form, and it contains *only* terminal symbols.\n               Namely,\n                $$ S\\Rightarrow\\alpha \\mathrm{\\ and\\ } \\alpha\\in\\Sigma_0^* $$\n\n               - $L(G)$ is all the sentences of $G$.\n               }}})\n      ); page\n\n(page (:h1 \"Going beyond RE with CFG\")\n\n      #md {{{\n             Recall that \n             `$L = \\{ \\color{red}{(}^n \\color{blue})^n : n\\geq 0 \\} $`\n             is not regular.\n             }}}\n\n      #md {{{\n             We can use CFG to define this non-regular language:\n\n             ```\n             S : ( S )\n             S : $\\epsilon$\n             ```\n             }}}\n      ); page\n\n",
                    "istop": false,
                    "path": "02.grammars/intro"
                },
                "02.grammars/parse": {
                    "children": [],
                    "content": "{:title \"Parsing: an overview\"\n :rank 2\n :summary #md {{{\n                 Parsing is to convert a sequence of symbols to\n                 structured data according to a _grammar_.\n                 }}}\n }\n\n(banner #md {{{\n               Grammar is the language.\n\n               Strings are messages.\n\n               Parse trees are the meanings.\n               }}})\n\n(:h1 \"Parse Trees\")\n\n(page (:h1 \"Definition\")\n\n       #md {{{\n              Recall the definition of the language of $G$:\n\n              `$$ L(G) = \\{\\alpha\\in\\Sigma_0^*: S\\Rightarrow \\alpha\\} $$`\n              }}}\n\n       #md {{{\n              ## Example\n\n              Consider a grammar $G$ with the productions:\n\n              ```\n              S : a S S b\n                | 0\n                | 1\n              ```\n              }}}\n       #md {{{\n              It\u0027s easy to see that `a01b`$\\in L(G)$.\n\n              ```\n              S =\u003e a S S b\n                =\u003e a 0 S b\n                =\u003e a 0 1 b\n              ```\n              }}}\n       #md {{{\n              Parse trees are the record of which production\n              being applied to which symbols.\n              }}}\n      (row 4 4 4\n            (code\n              {{{\n                 S =\u003e a S S b\n                   =\u003e a 0 S b\n                   =\u003e a 0 1 b\n                   }}})\n            (code\n              {{{\n                            S\n                            |\n                    +----+--+--+----+\n                    |    |     |    |\n                    |    S     S    |\n                    |    |     |    |\n                    a    0     1    b\n                 }}})\n            #md {{{\n                   - The root of the tree is the start symbol.\n                   - The intermediate nodes are syntactic variables.\n                   - The leaf nodes are the terminals.\n                   - Each parent node is the head, and its children the body\n                   of a production.\n                   }}}\n            )\n       )\n\n(page (:h1 \"A functional grammar: Arithmetics\")\n\n      #md {{{\n             Let\u0027s consider some strings expressing arithmetics (+, *)\n             of single digits.\n\n             Here are some sample expressions:\n\n             - `0`\n             - `1 + 4 * 8`\n             - `8 * 3 + 5`\n             - `8 * 3 + 5 + 8 * 3 + 5 + 8 * 3 + 5`\n             }}}\n\n      #md {{{\n             We can define the grammar as follows with\n             the starting symbol as `E`:\n\n             ```\n             E : 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9\n               | E + E\n               | E * E\n             ```\n\n             - There is one syntactic variable,\n             - 12 terminals,\n             - and 12 productions.\n             }}}\n      #md {{{\n\n             Let\u0027s derive some strings on the language:\n\n             ```\n             E =\u003e E + E\n               =\u003e 1 + E\n               =\u003e 1 + E * E\n               =\u003e 1 + 4 * E\n               =\u003e 1 + 4 * 8\n             ```\n             }}}\n      #md {{{\n             The string is ambiguous to the interpretation:\n\n             ```\n             1 + 4 * 8\n             ```\n\n             _Do we add before multiply, or multiply before add?_\n             }}}\n\n      #md {{{\n             Here is the parse tree corresponding to the \n             derivation, and its significance:\n             }}}\n      (row 4 8\n           (code\n             {{{\n                      E\n                    / | \\\n                   E  +  E\n                   |     |\n                   1   / | \\\n                      E  *  E\n                      |     |\n                      4     8\n             }}})\n           #md {{{\n                  The parse tree gives the unambiguous interpretation to the string.\n\n                  - Multiple first (because it\u0027s a sub-tree before add)\n                  - Then add.\n                  }}})\n      ); page\n\n(page (:h1 \"Ambiguity\")\n      #md {{{\n             Users:\n\n             \u003e Produce a string that belong to a language:\n             \u003e $$ \\alpha\\in L(G) $$\n\n             Compiler:\n\n             \u003e Converts the program source code $\\alpha$ into\n             a parse tree $T$.  It is $T$ that is the interpretation\n             of the user program.\n\n             Computer:\n\n             \u003e Performs computation based on the parse tree $T$.\n             }}}\n\n      #md {{{\n             _Ambiguity_\n\n             What if the same program $\\alpha$ has *two* different\n             parse trees: `$T_1\\not=T_2$`.\n             }}}\n      \n      (box #md {{{\n                  *Definition*: Ambiguous Grammar\n\n                  \u003e A grammar is ambiguous if its language\n                  contains at least one string with two\n                  distinct parse trees.\n                  }}})\n\n      (:h2 \"An ambiguous grammar\")\n\n      #md {{{\n             The arithmetics grammar is _ambiguous_:\n\n             ```\n             E : 0 | 1 ... 9 | E + E | E * E\n             ```\n             }}}\n\n      #md {{{\n             Consider the program:\n\n             ```\n             1 + 4 * 8\n             ```\n\n             It has two parse trees:\n\n             ```\n                  E                    E           \n                / | \\                / | \\           \n               1  +  E              E  *  8           \n                   / | \\          / | \\           \n                  4  *  8        1  +  4           \n             ```\n             }}}\n\n      #md {{{\n             But they are not equivalent:\n             }}}\n      #md {{{\n\n             ```\n                  E               \n                / | \\               \n               1  +  E       ==\u003e 1+(4*8) = 33          \n                   / | \\         \n                  4  *  8         \n             ```\n             }}}\n      #md {{{\n             \n             ```\n                   E           \n                 / | \\           \n                E  *  8      ==\u003e (1+4)*8 = 40\n              / | \\           \n             1  +  4           \n             ```\n             }}}\n      )\n\n(page (:h1 \"Left and right-most parse trees\")\n      (box #md {{{\n                  *Definition*: Left-most and right-most derivation\n\n                  \u003e _Left-most_ derivation is a derivation in which\n                  every step only replaces the _left most_ syntactic variable.\n\n                  \u003e In the _right most_ derivation, each step replaces\n                  the _right most_ syntactic variable.\n                  }}})\n\n      (:h2 \"Example\")\n\n      #md {{{\n             Consider the grammar of arithmetics:\n\n             ```\n             E : num | E + E | E * E\n             ```\n\n             Here is the left-most derivation of `1 + 2 * 3`.\n\n             ```\n             E =\u003e E * E\n               =\u003e E + E * E\n               =\u003e 1 + E * E\n               =\u003e 1 + 2 * E\n               =\u003e 1 + 2 * 3\n             ```\n             }}}\n      #md {{{\n             Here is the right-most derivation of `1 + 2 * 3`.\n\n             ```\n             E =\u003e E + E\n               =\u003e E + E * E\n               =\u003e E + E * 3\n               =\u003e E + 2 * 3\n               =\u003e 1 + 2 * 3\n             ```\n             }}}\n\n      (box #md {{{\n                  *Definition*: Left-most and right-most parse trees\n\n                  \u003e The _left-most_ parse tree is the parse tree corresponding to\n                  the left-most derivation.\n\n                  \u003e The _right-most_ parse tree is the parse tree corresponding to\n                  the right-most derivation.\n                  }}})\n\n      (:h2 \"Example\")\n\n      #md {{{\n             Consider the grammar of arithmetics:\n\n             ```\n             E : num | E + E | E * E\n             ```\n\n             Here is the left-most derivation and parse tree of `1 + 2 * 3`.\n\n             ```\n             E =\u003e E * E                    E\n               =\u003e E + E * E              / | \\\n               =\u003e 1 + E * E             E  *  E\n               =\u003e 1 + 2 * E           / | \\   |\n               =\u003e 1 + 2 * 3          E  +  E  3\n                                     |     |\n                                     1     2\n             ```\n             }}}\n      #md {{{\n             Here is the right-most derivation and parse tree of `1 + 2 * 3`.\n\n             ```\n             E =\u003e E + E                   E\n               =\u003e E + E * E             / | \\\n               =\u003e E + E * 3            E  +  E\n               =\u003e E + 2 * 3            |   / | \\\n               =\u003e 1 + 2 * 3            1  E  *  E\n                                          |     |\n                                          2     3\n             ```\n             }}}\n\n      #md {{{\n             This grammar is ambiguous, and thus it\u0027s possible that\n             the left-most and right-most parse trees are **different**.\n             }}}\n      ); page\n\n\n(page (:h1 \"Parsing programs\")\n\n      (banner\n        #md {{{\n               Parsing is _hard_.\n               }}})\n        #md {{{\n               Ambiguity is dangerous because there is a potential \n               disagreement between:\n\n               1. The parse tree intented by the programmer,\n               2. and the parse tree generated by the compiler.\n               }}}\n        #md {{{\n               Solutions:\n\n               1. Fix the grammar to remove ambiguity (not always possible).\n               2. Have a deep understanding of the parsing algorithm so we always\n               known which parse tree to expect (Humanly impossible).\n               3. Hope for the best, and remain vigilant (current state of things).\n               }}}\n      ); page\n\n",
                    "istop": false,
                    "path": "02.grammars/parse"
                },
                "02.grammars/transformations": {
                    "children": [],
                    "content": "{:title \"Grammar Transformation\"\n :status :ready\n :rank 4\n :summary #md {{{\n                 We will be focusing on several grammar transformations.\n\n                 - Removal of left-recursion\n                 - Creating left-factored grammar\n                 }}}\n }\n\n(page (:h1 \"Some properties of a grammar\")\n      #md {{{\n             Consider a grammar $G$.  We will define a number of\n             properties of $G$.  These properties will be\n             important when we build a parser.\n             }}}\n\n      (box\n        (:h2 \"Left-recursion\")\n        #md {{{\n               The grammar $G$ is _left recursive_ if\n               there exists a syntactic variable\n               `$X\\in\\Sigma_1(G)$` such that:\n\n               `$$ X\\Rightarrow X\\alpha$$`\n\n               for some $\\alpha\\in\\Sigma^*$.\n               }}}\n\n        (--*--)\n\n        (:h2 \"Immediate left-recursion\")\n        #md {{{\n               The grammar $G$ is immediately left-recursive\n               if there exists a production in the form of:\n\n               `$$ X : X\\alpha $$`\n               }}}\n        )\n      )\n\n(page (:h1 \"Examples of recursions\")\n\n      (rows :sep 6 6\n        #md {{{\n               Here is a left-recursive grammar.  In fact, it\u0027s\n               immediately left-recursive.\n\n               ```\n               expr : expr + expr\n                    | expr * expr\n                    | NUMBER\n               ```\n               }}}\n        #md {{{\n               There are two left-recursive productions:\n\n               ```\n               expr : expr + expr\n               expr : expr * expr\n               ```\n\n               where the syntactic variable that\n               is left-recursive is `expr`.\n               }}}\n        \n        #md {{{\n               Here is a recursive grammar.\n\n               ```\n               A : B\n               B : Aa\n               ```\n\n               The alphabet is:\n\n               - Syntactic variables: `A`, `B`\n               - Terminals: `a`\n               }}}\n        #md {{{\n               There is no left-recursive productions, but we\n               have two left-recursive derivations:\n\n               ```\n               A =\u003e B =\u003e Aa\n               B =\u003e Aa =\u003e Ba\n               ```\n               }}})\n\n      ); page\n\n(page (:h1 \"Left-factored grammars\")\n      (box\n        #md {{{\n               *Definition*: Prefix of string\n\n               \u003e Given two strings $\\alpha$ and $\\beta$,\n               we say that $\\alpha$ is a *prefix* of $\\beta$\n               if $\\beta$ *starts with* $\\alpha$:\n\n               $$\\exists \\delta: \\beta = \\alpha \\delta $$\n\n               The set of *all* prefixes of $\\beta$ is\n               denoted as: $\\mathrm{pre}(\\beta)$.\n               }}}\n\n        (--*--)\n        \n        #md {{{\n\n               For all strings $\\beta$, the empty string\n               $\\epsilon$ is always a prefix of $\\beta$:\n\n               $$\\forall\\beta\\in\\Sigma^*,\\ \\epsilon\\in\\mathrm{pre}(\\beta)$$\n               }}})\n\n      (:h2 \"Example\")\n      #md {{{\n             For a string $\\beta = abc$.\n             }}}\n      (rows 6 6\n            #md {{{\n             There are four _prefixes_:\n             \n             1. $\\epsilon$\n             2. $a$\n             3. $ab$\n             4. $abc$\n             }}}\n            #md {{{\n                   There are *three* **non-empty** prefixes:\n\n                   2. $a$\n                   3. $ab$\n                   4. $abc$\n                   }}})\n\n      (box #md {{{\n                  *Definition*: Common prefix\n\n                  \u003e The common prefixes of two strings $\\beta$ and $\\beta\u0027$ are given by\n                  \u003e $$ \\mathrm{pre}(\\beta)\\cap\\mathrm{pre}(\\beta\u0027) $$\n                  \u003e\n                  \u003e It\u0027s written as:\n                  \u003e $$\\mathrm{pre}(\\beta, \\beta\u0027)$$\n                  }}})\n\n      (box\n        #md {{{\n               *Definition*: Left-factored grammar\n\n               \u003e A grammar $G$ is _left-factored_\n               if productions with the _same_\n               head syntactic variable, their bodies\n               do not have any non-empty common prefix.\n\n               `$$\\forall (X:\\alpha)\\in G, (Y:\\beta) \\in G,\n               \\mathrm{if}\\ X=Y\\ \\mathrm{then}\\ \\mathrm{pre}(\\alpha,\\beta)=\\{\\epsilon\\}\n               $$`\n               }}})\n\n      (:h2 \"Example\")\n\n      #md {{{\n             Let\u0027s review the grammar of simplified arithmetics:\n\n             \u003e ```\n             \u003e expr : expr + expr\n             \u003e      | expr * expr\n             \u003e      | Number\n             \u003e ```\n             }}}\n\n      #md {{{\n             There are three productions.\n\n             \u003e ```\n             \u003e expr : expr + expr\n             \u003e expr : expr * expr\n             \u003e expr : Number\n             \u003e ```\n             }}}\n\n      #md {{{\n             The grammar is *not* left-factored because the following two productions:\n\n             \u003e - `expr : expr + expr`  \n             \u003e - `expr : expr * expr`  \n\n             They share the same head: `expr`, and their bodies share a non-empty\n             prefix:\n\n             \u003e ```\n             \u003e pre(expr + expr, expr * expr) = { expr }\n             \u003e ```\n             }}}\n      ); page\n\n(page (:h1 \"Significance\")\n\n      #md {{{\n             We have defined two properties:\n\n             1. Left-recursive grammar\n             2. Left-factored grammar\n\n             Why bother?\n             }}}\n\n      #md {{{\n             The next topic in the course is to construct\n             a parsing algorithm.\n\n             - Parsing is hard.\n\n             - We will construct a parsing algorithm that\n             can handle grammars that are:\n                1. free of left-recursion, and\n                2. left-factored.\n             }}}\n\n      (--*--)\n\n      #md {{{\n             ## Objective:\n\n             1. If the grammar *is left-recursive*, we want to transform\n             the grammar to *remove* the left-recursion *without* changing\n             the underlying language.\n\n             2. If the grammar *is NOT left-factored*, we want to\n             transform the grammar to make it left-factored *without* changing\n             the underlying language.\n             }}}\n      ); page\n\n(:h1 \"Transformation Algorithms\")\n\n(page (:h1 \"Left factoring\")\n      #md {{{\n             What if a grammar is not left-factored?\n\n             _A_: we can always rewrite the grammar so that it becomes\n             left-factored.\n             }}}\n\n      #md {{{\n             Suppose that a grammar is not left-factored.  Then,\n             there exists two productions of the form:\n\n             `$$\n             \\begin{eqnarray}\n             A \u0026:\u0026 \\alpha \\beta_1 \\\\\n             A \u0026:\u0026 \\alpha \\beta_2 \n             \\end{eqnarray}\n             $$`\n\n             where\n\n             - $\\alpha$ is not empty, and\n             - `$\\beta_1$` and `$\\beta_2$` do not have any non-empty common prefix.\n             }}}\n      \n      #md {{{\n             We can rewrite the grammar:\n\n             1. Define a new syntactic variable: $A\u0027 : \\beta_1 | \\beta_2$\n\n             2. Replace the two production rules with a single rule: $A = \\alpha A\u0027$.\n             }}}\n\n      (:h2 \"Procedure\")\n\n      (rows :sep 4 8\n            (:h2 \"Types\")\n            (code :java\n                  {{{\n                     class Grammar\n                     class Symbol\n                     class SyntacticVar extends Symbol\n                     class Terminal extends Symbol\n\n                     class Production {\n                       SyntacticVar head()\n                       Symbol[]     body()\n                     }\n                     }}})\n\n            (:h2 \"Left factoring\")\n            (code :java\n                  {{{\n                     class Grammar {\n                       void leftFactor()\n                     }\n                     }}}))\n\n      (:h2 \"Example\")\n      #md {{{\n             Consider the grammar of arithmetic expressions.\n\n             ```\n             expr : expr + expr \n                  | expr - expr\n                  | expr * expr\n                  | expr / expr\n                  | Number\n             ```\n\n             where\n\n             - `$\\Sigma_0 = \\{\\mathrm{Number}, +, -, *, /\\}$`\n             - `$\\Sigma_1 = \\{\\mathrm{expr}\\}$`\n             }}}\n\n      #md {{{\n             The grammar is *not* left-factored.\n             }}}\n\n      #md {{{\n             1. The prefix of all the productions of `expr` is `expr`\n             2. Introduce a new syntactic variable `x` and define\n                ```\n                x : + expr \n                  | - expr \n                  | * expr \n                  | / expr\n                ```\n             }}}\n      #md {{{\n             The transformed grammar is:\n\n             \u003e ```\n             \u003e expr : expr x | Number\n             \u003e x    : + expr | - expr | * expr | / expr\n             \u003e ```\n             }}}\n      )\n\n(page (:h1 \"Dealing with immediate left-recursion\")\n      #md {{{\n             *Reminder* on notation:\n\n             Given a grammar $G$, and some string $\\alpha\\in\\Sigma^*$,\n             the language $L(\\alpha)$ is all the sentences that can\n             be derived from the string $\\alpha$:\n\n             `$$ L(\\alpha) = \\{s\\in\\Sigma_0^*: \\alpha\\Rightarrow s\\} $$`\n             }}}\n\n      #md {{{\n             Consider a grammar with an immediately left-recursive\n             production:\n\n             `$$ A : A\\alpha\\ |\\ \\beta_1\\ |\\ \\beta_2\\ |\\ \\dots\\ |\\ \\beta_n $$`\n             }}}\n\n      (:h2 \"Removing immediate left-recursion\")\n\n      (rows :sep 4 8\n            (:h2 \"The language of $A$\")\n            #md {{{\n                   The language of $A$ is given by:\n\n                   `$L(A) = \\left(\\bigcup_{1\\leq i\\leq n} L(\\beta_i)\\right) L(\\alpha)^*$`\n\n\n                   _Challenge_:\n\n                   \u003e Can you prove it?\n                   }}}\n\n            (:h2 \"A bit language identity\")\n            #md {{{\n                   The following are equivalent:\n\n                   `$$\\begin{eqnarray*}\n                        L(A) \u0026=\u0026 \\left(\\bigcup_{1\\leq i\\leq n} L(\\beta_i)\\right) L(\\alpha)^* \\\\\n                        \u0026=\u0026 \\left(\\bigcup_{1\\leq i\\leq n} L(\\beta_i) L(\\alpha)^*\\right)\n                        \\end{eqnarray*}$$`\n                   }}}\n\n            (:h2 \"Grammar rewrite\")\n            (:div #md {{{\n                         We can take the new language apart, and rewrite it\n                         free of immediate left-recursion.\n\n                         Given,\n\n                         `$$ L(A) = \\left(\\bigcup_{1\\leq i\\leq n} L(\\beta_i) L(\\alpha)^*\\right) $$`\n                         }}}\n                  #md {{{\n                         Define: $A\u0027 : \\epsilon\\ |\\ \\alpha A\u0027$\n\n                         so we have $L(A\u0027) = L(\\alpha)^*$\n                         }}}\n                  #md {{{\n                         Then, we get:\n\n                         `$$ \\underbrace{L(\\beta_i)}_{\\beta_i} \\underbrace{L(\\alpha)^*}_{A\u0027}$$`\n                         }}}\n                  #md {{{\n                         This leads to:\n\n                         `$$\n                         \\begin{eqnarray}\n                         A \u0026:\u0026 \\beta_1 A\u0027\\ |\\ \\beta_2 A\u0027\\ |\\ \\dots\\  |\\ \\beta_n A\u0027 \\\\\n                         A\u0027 \u0026:\u0026 \\epsilon\\ |\\ \\alpha A\u0027\n                         \\end{eqnarray}\n                         $$`\n                         }}}\n                  )\n            )\n\n      (:h2 \"Grammar rewrite as a procedure\")\n\n      (rows :sep 4 8\n            (:h2 \"Types\")\n            (code :java\n                  {{{\n                     class Grammar\n                     class Symbol\n                     class SyntacticVar extends Symbol\n                     class Terminal extends Symbol\n\n                     class Production {\n                       SyntacticVar head()\n                       Symbol[]     body()\n                     }\n                     }}})\n\n            (:h2 \"Rewriting\")\n            (code :java \n                  {{{\n                     class Grammar {\n                       void removeImmediateLeftRecursion(SyntacticVar A)\n                     }\n                     }}})\n            ); rows\n\n\n      (:h2 \"Example\")\n      #md {{{\n             Consider the grammar:\n\n             \u003e ```\n             \u003e expr : expr + expr\n             \u003e       | Number\n             \u003e ```\n             }}}\n      #md {{{\n             We observe that it\u0027s is immediately left-recursive\n             and in terms of the pattern:\n\n             `$$ A : A\\alpha\\ |\\ \\beta_1\\ |\\ \\beta_2\\ |\\ \\dots\\ |\\ \\beta_n $$`\n\n             We have:\n\n             - `$A$ = expr`\n             - `$\\alpha$ = + expr`\n             - `$\\beta_1$ = Number`\n             }}}\n      #md {{{\n             Applying the rewrite rule, we need to introduce a new\n             syntactic variable:\n\n             \u003e ```\n             \u003e expr2 = $\\epsilon$ | + expr expr2\n             \u003e ```\n\n             and rewrite the `expr` productions as:\n\n             \u003e ```\n             \u003e expr : Number expr2\n             \u003e ```\n             }}}\n      ); page\n\n(page (:h1 \"Dealing with general left-recursion\")\n      (rows 8 5\n        #md {{{\n\n               1. Ensure that $G$ is left-factored.\n\n               2.  Sort the syntactic variables: $A_1, A_2, \\dots, A_n$\n\n               ```\n               for $i\\in 1 \\to n$:\n               \u250a   for $j\\in 1\\to i-1$:\n               \u250a   \u250a   // Look for violations in ranks, i.e. $j \u003c i$\n               \u250a   \u250a   let $P = \\{A_i : A_j\\alpha\\}$ \n               \u250a   \u250a   if $P\\not=\\emptyset$:\n               \u250a   \u250a   \u250a   Consider $\\{A_j : \\beta_k,\\ k=1\\dots n\\}$ in $G$\n               \u250a   \u250a   \u250a   for $A_i: A_j\\alpha$ in $P$:\n               \u250a   \u250a   \u250a   \u250a   replace with  $A_i:\\beta_1\\alpha$\n               \u250a   \u250a   \u250a   \u250a                    $|\\ \\beta_2\\alpha$\n               \u250a   \u250a   \u250a   \u250a                    $|\\ \\beta_3\\alpha$\n               \u250a   \u250a   \u250a   \u250a                    $\\dots$\n               \u250a   \u250a   \u250a   \u250a                    $|\\ \\beta_n\\alpha$\n               \u250a   eliminate_immediate_left_recursion($G$)\n               ```\n              }}}\n        (:div\n          #md {{{\n                 *Rank*:\n\n                 \u003e For each symbol $A_i$, the index $i$ is its rank.\n                 }}}\n          #md {{{\n                 *Goal*:\n\n                 \u003e We want rewrite the grammar such that\n                 \u003e all productions are of the form:\n                 \u003e $A_i : a\\alpha$ where `$a\\in\\Sigma_0$` or\n                 \u003e $A_i : A_j\\alpha$ where $j \u003e i$.\n                 }}}\n          #md {{{\n                 *Loop invariance*\n\n                 \u003e We ensure that up to `$A_i$`, there\n                 is no _rank_ violations.\n                 }}})\n        ); rows\n\n      (banner :right\n        #md {{{\n               # Challenge\n\n               Consider the grammar:\n\n               ```\n               expr : expr + expr\n                    | expr * expr\n                    | ( expr )\n                    | Number\n               ```\n\n               Remove left-recursion.\n               }}})\n      ); page\n\n",
                    "istop": false,
                    "path": "02.grammars/transformations"
                },
                "03.topdown-parsing": {
                    "children": ["03.topdown-parsing/first-follow", "03.topdown-parsing/intro", "03.topdown-parsing/parser"],
                    "content": "{:title \"Topdown Parsing\"\n :summary #md {{{\n                 We will discuss a parsing algorithm behind some\n                 of the most popular programming languages.\n\n                 The top-down parsing algorithm handles a specific\n                 type of grammars, known as LL(1) grammars.  We will\n                 be able to build a complete parser for any\n                 languages that can be defined by a LL(1) grammar.\n                 }}}\n }\n",
                    "istop": false,
                    "path": "03.topdown-parsing"
                },
                "03.topdown-parsing/first-follow": {
                    "children": [],
                    "content": "{:title \"First \u0026 Follow Sets\"\n :rank 2\n :summary #md {{{\n                 We present two concepts: _first_ and _follow_\n                 sets.  They are computable properties of\n                 a grammar, and will help us to build\n                 the top-down parser.\n                 }}}\n }\n\n(:h1 \"Theory\")\n\n(page (:h1 \"Prototypes\")\n      (rows 8 4\n        (box #md {{{\n                    _Definition_:\n\n                    \u003e The `first` function maps \n                    \u003e strings in `$(\\Sigma_1\\cup\\Sigma_0)^*$`\n                    \u003e to sets of terminals.\n\n                    \u003e $$ \\mathrm{first}:\\Sigma^*\\to\\mathbf{SET}(\\Sigma_0) $$\n                    }}})\n        #md {{{\n               The intuition is that `first($x$)` is all possible\n               terminals that might be the first symbol\n               in a string that can be derived from $x$.\n               }}}\n\n        (box #md {{{\n                    _Definition_:\n\n                    The `follow` function maps syntactic variables\n                    to sets of terminals.\n\n                    $$ \\mathrm{follow}:\\Sigma_1\\to\\mathbf{SET}(\\Sigma_0) $$\n                    }}})\n\n        #md {{{\n               The intution is that `follow($Z$)` is all possible\n               terminals $c$ that can be derived in the form of $Zc\\dots$.\n               }}})\n\n      #md {{{\n             The `first` and `follow` functions will\n             be instrumental in the design of the top-down\n             parser.\n             }}}\n      )\n\n(page (:h1 \"Definition: First Sets\")\n\n      #md {{{\n             First we define a function:\n             `$\\mathrm{first}_0 : \\Sigma^*\\to\\mathbf{SET}(\\Sigma_0)$`\n             as follows:\n\n             `$$\\mathrm{first}_0(\\alpha) = \n             \\{a\\in\\Sigma_0: \\alpha\\Rightarrow a\\dots\\}$$`\n\n             }}}\n\n      (banner #md {{{\n                     What if `$\\alpha\\Rightarrow\\epsilon$`?\n\n                     There wouldn\u0027t be a first terminal.\n                     }}})\n\n      #md {{{\n             Extending to `first`:\n\n             `$$\\mathrm{first}(\\alpha) =\n              \\left\\{\\begin{array}{ll}\n              \\mathrm{first}_0(\\alpha)\\cup\\{\\epsilon\\} \u0026\\mathrm{if}\\ \\alpha\\Rightarrow\\epsilon \\\\\n              \\mathrm{first}_0(\\alpha) \u0026\\mathrm{else}\n              \\end{array}\\right.\n              $$`\n             }}}\n      )\n\n(page (:h1 \"Definition: Follow Sets\")\n\n      #md {{{\n             Let\u0027s start with \n             `$\\mathrm{follow}_0 : \\Sigma_1\\to\\mathbf{SET}(\\Sigma_0)$` as:\n\n             `$$\\mathrm{follow}_0(Z) = \n               \\{a\\in\\Sigma_0 : S\\Rightarrow \\dots Za \\dots\\}\n               $$`\n             }}}\n\n      (banner #md {{{\n                     What if $S\\Rightarrow \\dots Z$?\n\n                     There wouldn\u0027t be a following terminal.\n                     }}})\n\n      #md {{{\n             Extending to `follow`:\n\n             `$$\n             \\mathrm{follow}(Z) = \\left\\{\\begin{array}{ll}\n             \\mathrm{follow}_0(Z) \\cup \\{$\\} \u0026 \\mathrm{if}\\ S\\Rightarrow \\dots Z \\\\\n             \\mathrm{follow}_0(Z) \u0026 \\mathrm{else}\n             \\end{array}\\right.\n             $$`\n             }}}\n      )\n\n(:h1 \"Algorithms\")\n\n(page (:h1 \"Computing FIRST sets\")\n      #md {{{\n             We first begin with computing\n             the first sets of a single symbol.\n             }}}\n\n      (rows 8 4\n            #md {{{\n                   ```\n                  def first$_0$(X):\n                  \u2506  return first(X) - $\\{\\epsilon\\}$\n\n                   def first($X\\in\\Sigma$):\n                   \u2506  let $F=\\emptyset$\n                   \u2506  if $X\\in\\Sigma_0$:\n                   \u2506  \u2506  $F = \\{X\\}$\n                   \u2506  else:\n                   \u2506  \u2506  for each production $X\\to Y_1 Y_2\\dots Y_k$ in $G$:\n                   \u2506  \u2506  \u2506  if $k=0$:\n                   \u2506  \u2506  \u2506  \u2506  $F = F\\cup\\{\\epsilon\\}$\n                   \u2506  \u2506  \u2506  else:\n                   \u2506  \u2506  \u2506  \u2506  for $i$ in $1\\to k$:\n                   \u2506  \u2506  \u2506  \u2506  \u2506  $F = F \\cup \\mathrm{first}_0(Y_i)$\n                   \u2506  \u2506  \u2506  \u2506  \u2506  if $\\epsilon\\not\\in\\mathrm{first}(Y_i)$:\n                   \u2506  \u2506  \u2506  \u2506  \u2506  \u2506  break\n                   \u2506  \u2506  \u2506  \u2506  if $i$ == $k$:\n                   \u2506  \u2506  \u2506  \u2506  \u2506  $F = F\\cup\\{\\epsilon\\}$\n                   \u2506  return F\n                   ```\n                   }}}\n            (:div #md {{{ \n                         This algorithm is _recursive_.  \n                         }}}\n                  #md {{{\n                         It checks each production of $X$ to\n                         see if:\n\n                         - what are the possible first terminals,\n                         - if it\u0027s possible to derive $\\epsilon$ from $X$.\n                         }}})\n            )\n\n      #md {{{\n             How we can extend the algorithm to handle\n             arbitrary strings.\n             }}}\n\n      (row 8 4\n           #md {{{\n                  ```\n                  def first($\\alpha$):\n                  \u2506  let $X_1 X_2 \\dots X_n = \\alpha$\n                  \u2506  let $F=\\emptyset$\n                  \u2506  for $i = 1\\to k$:\n                  \u2506  \u2506  $F = F\\cup\\mathrm{first}_0(X_i)$\n                  \u2506  \u2506  if $\\epsilon\\not\\in\\mathrm{first}(X)$:\n                  \u2506  \u2506  \u2506  break\n                  \u2506  if $i$ == $n$:\n                  \u2506  \u2506  $F = F\\cup\\{\\epsilon\\}$\n                  \u2506  return F\n                  ```\n                  }}}\n           #md {{{\n                  Actually, this function is _not_ recursive\n                  because it\u0027s only calling the `first`\n                  of single symbols.\n                  }}})\n      )\n\n(page (:h1 \"Termination Condition for first(...)\")\n      #md {{{\n             Since the function $\\mathrm{first}(X)$\n             is recursive, we need to be aware of its\n             termination condition.\n\n             **It is not guaranteed to terminate.**\n             }}}\n\n      (rows 8 4\n            #md {{{\n                   ```\n                   def first($X\\in\\Sigma$):\n                   ...\n                   \u2506  \u2506  for each production $X\\to Y_1 Y_2\\dots Y_k$ in $G$:\n                   ...\n                   \u2506  \u2506  \u2506  \u2506  for $i$ in $1\\to k$:\n                   \u2506  \u2506  \u2506  \u2506  \u2506  $F = F \\cup \\mathrm{first}_0(Y_i)$\n                   \u2506  \u2506  \u2506  \u2506  \u2506  if $\\epsilon\\in\\mathrm{first}(Y_i)$:\n                   \u2506  \u2506  \u2506  \u2506  \u2506  \u2506  break\n                   ...\n                   ```\n                   }}}\n            (:div #md {{{\n                         What happens if there is a production:\n\n                         - $ X : X \\dots $?\n                         }}}\n                  #md {{{\n                         What if we have:\n\n                         - $X : Y \\dots$\n                         - $Y : Z \\dots$\n                         - $Z : X \\dots$\n                         }}})\n            )\n      (box #md {{{\n                  Fact:\n\n                  \u003e The algorithm `first($X$)` terminates if and only if\n                  the grammar is *not* left-recursive.\n                  }}})\n      )\n\n(page (:h1 \"Computing FOLLOW Sets\")\n      #md {{{\n             The follow-sets are computed\n             by an iterative algorithm that\n             uses the `first` sets.\n\n             The algorithm computes **all**\n             follow sets simultanenously.\n             }}}\n\n      (rows 8 4\n            #md {{{\n                   ```\n                   def all_follow_sets($G$, $S$):\n                   \u2506  let $F$ = hashmap$\\left\u003c\\Sigma_1 \\to \\mathrm{SET}(\\Sigma_0)\\right\u003e$\n                   \u2506  $F[S] = \\{\\$\\}$\n                   \u2506  loop:\n                   \u2506  \u2506  foreach production $X: Y_1 Y_2 \\dots Y_k$ in $G$:\n                   \u2506  \u2506  \u2506  for $i$ = $1\\to k$:\n                   \u2506  \u2506  \u2506  \u2506  if $Y_i\\in\\Sigma_1$:\n                   \u2506  \u2506  \u2506  \u2506  \u2506  $F\u0027[Y_i] = F[Y_i]\\cup(\\mathrm{first}_0(Y_{i+1}\\dots Y_k))$\n                   \u2506  \u2506  \u2506  \u2506  \u2506  if $i$ == $k$ or $\\epsilon\\in\\mathrm{first}(Y_{i+1}\\dots Y_k)$:\n                   \u2506  \u2506  \u2506  \u2506  \u2506  \u2506  $F\u0027[Y_i] = F[Y_i]\\cup F[X]$\n                   \u2506  \u2506  if $F\u0027$ == $F$:\n                   \u2506  \u2506  \u2506  break\n                   \u2506  \u2506  else:\n                   \u2506  \u2506  \u2506  $F = F\u0027$\n                   \u2506  \u2506  \u2506  continue\n                   \u2506  return F\n                   ```\n                   }}}\n            (:div\n              #md {{{\n                     At each iteration, we update the table of follow-sets.}}}\n              #md {{{\n                     - At `$Y_i$`, it\u0027s follow-set is the first`$_0$`-sets\n                     of `$Y_{i+1}\\dots Y_{k}$`. \n\n                     - If `$Y_{i+1}\\dots Y_k\\Rightarrow\\epsilon$`, then\n                     `$Y_i$` can be followed by what follows $X$.\n                     }}}))\n\n      )\n",
                    "istop": false,
                    "path": "03.topdown-parsing/first-follow"
                },
                "03.topdown-parsing/intro": {
                    "children": [],
                    "content": "{:title \"Overview of top-down parsing\"\n :summary #md {{{\n                 We will provide the overview of top-down\n                 parsing.\n                 }}}\n :rank 1}\n\n(page (:h1 \"Top-down parsing\")\n\n      #md {{{\n             We start with:\n\n             - A grammar and its start symbol $(G, S)$\n             where $G$ is a set of productions of the form:\n             $ X : \\alpha $.\n             - An input string `$x = x_1 x_2 \\dots x_n$`\n             where `$x_i\\in\\Sigma_0$`.\n             }}}\n\n      #md {{{\n             We want to generate a parse tree $T$\n             such that its root is $S$, and the leaf  nodes\n             are $x_1 \\dots x_n$.\n\n             ```\n                  S\n                 /|\\\n                .....\n              /        \\\n             |   |   |  |\n             $x_1$ $x_2$ ... $x_n$\n             ```\n             }}}\n\n      #md {{{\n             At each intermediate node, we have:\n\n             ```\n                   X\n                 / | \\\n               $z_1$ ... $z_k$\n             ```\n\n             where `$X:z_1 \\dots z_k$` is a production\n             in $G$.\n             }}}\n\n      (rows 6 6\n            #md {{{\n                   Top-down parsing _grows_ the tree\n                   from the root at the top downwards\n                   to the leaf nodes.\n                   }}}\n            (image \"a.png\"))\n      )\n\n(page (:h1 \"Top-down Parsing Strategy\")\n      #md {{{\n             We need a way to select a production\n             from $G$.\n\n             $$\\mathrm{select} : (X, \\Omega)\\mapsto (X:\\alpha)$$\n\n             where \n\n             - $X\\in\\Sigma_1$ \n             - $(X:\\alpha)\\in G$\n             - **and** $\\Omega$ is any additional information\n             that we have that can help us to select the production.\n             }}}\n\n      (rows 8 4\n            (image \"b.png\")\n            (:div #md {{{\n                         During the top-down parsing, we will\n                         need to decide which production to\n                         use to expand syntactic variables.\n                         }}}\n                  (box\n                    #md {{{\n                           We need to know additional information\n                           $\\Omega$ to select the right\n                           production.\n                           }}}))\n            \n            #md {{{\n                   ```\n                   def Topdown($G$, $S$, $x$):\n                   |  where $\\color{red} G$ is the grammar\n                   |        $\\color{red} S$ is the start symbol\n                   |        $\\color{red} x$ is the sentence to be parsed\n                   |\n                   \u2506  let $\\Omega$ = initial_state()\n                   \u2506  let $T$ = root_node($S$)\n                   \u2506  while $x\\not=\\epsilon$:\n                   \u2506  \u2506  let $F$ = frontier($T$)\n                   \u2506  \u2506  let vertex($Z$) = pick_syn_var($F$, $x$)\n                   \u2506  \u2506  let $Z:\\alpha$ = select($Z$, $x$)\n                   \u2506  \u2506  grow_tree(vertex($Z$), $\\alpha$)\n                   \u2506  \u2506  consume_sym($x$, $\\alpha$)\n                   ```\n                   }}}\n\n            #md {{{\n                   We iteratively expand the tree\n                   while consuming **terminal** symbols from\n                   the input $x$.\n\n                   What are missing are the functions:\n\n                   - `pick_syn_var($F$, $x$)`\n                   - `select($Z$, $x$)`\n                   }}}\n            )\n\n      (box #md {{{\n                  ## Challenge:\n\n                  \u003e Consider the grammar as:\n\n                  \u003e ```\n                  \u003e expr : expr + expr\n                  \u003e expr : expr - expr\n                  \u003e expr : ( expr )\n                  \u003e expr : 0 | 1 | 2 \n                  \u003e ```\n\n                  \u003e The input is \"1 + (2 - 0)\"\n\n                  \u003e Come up with your own `pick_syn_var`\n                  \u003e and `select` functions so that\n                  \u003e the top down parser success.\n                  }}})\n      )\n\n(page (:h1 \"Effective Heuristics\")\n\n      #md {{{\n             We are going to look at some _heuristics_\n             in implementing `pick_syn_var` and `select`.\n             }}}\n\n      (:h2 \"Picking left-most syntactic variable\")\n\n      (rows :sep 8 4\n            #md {{{\n                   ```\n                   def pick_syn_var($F$, $x$):\n                   |  where $\\color{red} F$ is a frontier in parse tree $T$\n                   |        $\\color{red} x$ is the sentence to be parsed\n                   |  selected_node = NULL\n                   |  for $v\\in F$:\n                   |  \u2506  if symbol($v$)$\\in\\Sigma_1$:\n                   |  \u2506  \u2506  selected_node = $v$\n                   |  \u2506  \u2506  break\n                   |  return selected_node\n                   ```\n                   }}}\n            #md {{{\n                   We always pick the **left-most** syntactic variable\n                   in the frontier $F$.\n                   }}})\n\n      (:h2 \"Selecting the production to use\")\n\n      (row 8 4\n           #md {{{\n                  ```\n                  def select($Z$, $x$):\n                  |  where $\\color{red} Z$ is a syntactic variable to expand\n                  |        $\\color{red} x$ is the $\\textbf{remaining}$ sentence to parse\n                  |  $c$ = first($x$)\n                  |  // select the production to use based\n                  |  // on the character $c$\n                  ```\n\n                  \u003cbr\u003e\n\n                  We need to spend the next few lectures\n                  to construct \u003cbr\u003e\n                  `select(X: $\\Sigma_1$, c: $\\Sigma_0$)`.\n                  }}}\n           #md {{{\n                  We make the decision of which production to\n                  pick based on the next symbol `$c$ = first($x$)`.\n                  }}})\n\n      (box #md {{{\n                  - We scan the input symbols from **left** to right:\n                  `$x_1 x_2 \\dots $`.\n\n                  - We expand the **left-most** syntactic variable\n                  on the frontier.\n\n                  - We choose the production based on the next **one**\n                  symbol in the input.\n\n                  ---\n\n                  This type of heuristics is known as: __LL(1)__\n                  }}})\n      )\n\n\n",
                    "istop": false,
                    "path": "03.topdown-parsing/intro"
                },
                "03.topdown-parsing/parser": {
                    "children": [],
                    "content": "{:title \"Recursive Descendent Parser\"\n :rank 3\n :summary #md {{{\n                 We will complete the parser.\n                 }}}\n }\n\n(page (:h1 \"First and Follow Sets Revisited\")\n      #md {{{\n             Let\u0027s review the intuition behind\n             the FIRST and FOLLOW sets.\n             }}}\n\n      (row 6 6\n        #md {{{\n               The FIRST sets are defined on\n               arbitrary strings in `$(\\Sigma_0\\cup\\Sigma_1)^*$`.\n\n               `$$\\mathrm{first} : \\Sigma^* \\to\\mathrm{SET}(\\Sigma_0)$$`\n\n               $\\mathrm{first}(\\alpha)$ is all terminals $a$\n               that produced as: $\\alpha\\Rightarrow \\mathbf{a}\\dots$\n               }}}\n\n        #md {{{\n               The FOLLOW sets are defined on syntactic variables.\n\n               `$$\\mathrm{follow} : \\Sigma_1 \\to\\mathrm{SET}(\\Sigma_0)$$`\n\n               $\\mathrm{follow}(X)$ is all the terminals $a$ that can follow\n               $X$ in a sentential form:\n               $S\\Rightarrow \\dots X\\mathbf{a}\\dots$\n               }}})\n      )\n\n(page (:h1 \"Toward the parser\")\n\n      #md {{{\n             It\u0027s important to keep in mind that \n             _parsing is hard_.}}}\n\n      #md {{{\n             Like other high performant parsing algorithms,\n             the top-down recursive descendent parser is a _best effort_\n             parsing strategy.\n             }}}\n\n      (:h2 \"The task at hand\")\n\n      #md {{{\n             - Grow the parse tree from $S$:\n\n               \u003e We need to grow the parse tree so that\n               the leaf nodes are _exactly_ the input terminals.\n\n             - Pick a production at each step:\n\n               \u003e We *always* expand the _left most leaf_ syntactic variable $X$\n               in the tree.  We need to pick the production $X:\\alpha$\n               based on the *first* unconsumed terminal in the input.\n             }}}\n\n      (:h2 \"The larger picture\")\n\n      #md {{{\n             We have a generic tree growing algorithm.\n\n             ```\n             def build_parse_tree($T$, $x$):\n             \u2506  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n             \u2506  \u2502 building tree $T$\n             \u2506  \u2502 consume terminals in the stream $x$\n             \u2506  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n             \u2506  try:\n             \u2506  \u2506   let $v(Z)$ = left-most leaf syntactic variable node in $T$\n             \u2506  catch:\n             \u2506  \u2506   if $x$ is empty:\n             \u2506  \u2506   \u2506   return Success \n             \u2506  \u2506   else:\n             \u2506  \u2506   \u2506   throw ParserError()\n             \u2506   \n             \u2506  try:\n             \u2506  \u2506   prod = select($Z$, first($x$))\n             \u2506  catch:\n             \u2506  \u2506   throw ParserError()\n             \u2506   \n             \u2506  expand $v(Z)$ using prod in $T$\n             \u2506  consume $x$ using prod\n             \u2506  build_parse_tree($T$, $x$)\n             ```\n             }}}\n      )\n\n(page (:h1 \"Production selection\")\n      (rows :sep 4 8\n             (:h2 \"Intuition\")\n             (:div #md {{{\n                         `select($Z$, $c$)` needs to select _one_ rule\n                         out of several:\n\n                         `$$ Z : \\alpha_1 | \\alpha_2 | \\dots | \\alpha_n $$`\n                         }}}\n                  #md {{{\n                         - Pick the one such that $c\\in\\mathrm{first}(\\alpha_i)$\n                         - If $Z\\Rightarrow\\epsilon$, we check if\n                         $c\\in\\mathrm{follow}(Z)$.\n                         }}}\n                  #md {{{\n                         When could such strategy get _confused_?\n                         }}})\n             (:h2 \"The LL(1) condition\")\n             (box #md {{{\n                         A grammar $G$ is a LL(1) grammar if it satisfies the following.\n\n                         \u003e Given any two productions with the same head:\n                         $Z:\\alpha$ and $Z:\\beta$,\n                         \u003e \n                         \u003e - $\\mathrm{first}(\\alpha)\\cap\\mathrm{first}(\\beta) = \\emptyset$\n                         \u003e - If $\\epsilon\\in\\mathrm{first}(\\alpha)$, then we must have:\n                         \u003e   $$\\mathrm{follow}(Z)\\cap\\mathrm{first}(\\beta) = \\emptyset$$\n                         }}})\n             )\n      )\n\n(page (:h1 \"Rule selection\")\n      (rows 4 8\n            (:h2 \"The rule selection procedure\")\n            #md {{{\n                   Given that $G$ is a LL(1) grammar.\n\n                   We can define the `select($Z$, $c$)` as\n                   follows:\n\n                   ```\n                   def select($Z$, $c$):\n                   \u2506  if $c\\in\\mathrm{follow}(Z)$:\n                   \u2506  \u2506  for each $Z:\\alpha$ in $G$\n                   \u2506  \u2506  \u2506  if $\\epsilon \\in \\mathrm{first}(\\alpha)$:\n                   \u2506  \u2506  \u2506  \u2506  return $Z:\\alpha$\n                   \u2506  elif $c\\in\\mathrm{first}(Z)$:\n                   \u2506  \u2506  for each $Z:\\alpha$ in $G$\n                   \u2506  \u2506  \u2506  if $c \\in \\mathrm{first}(\\alpha)$:\n                   \u2506  \u2506  \u2506  \u2506  return $Z:\\alpha$\n                   \u2506  else:\n                   \u2506  \u2506  raise Exception(\"No applicable rules\")\n                   ```\n                   }}}\n            (:h2 \"The predictive parsing table\")\n            (:div #md {{{\n                         There are only _finitely_ many possible inputs to `select`:\n                         $ |\\Sigma_1| \\times |\\Sigma_0| $\n                         }}}\n                  #md {{{\n                         We can precompute all the rule selections statically based\n                         on the grammar, and the result is a 2D table, known as the\n                         _predictive parsing table_.\n\n                         |    | a | b | c | d |\n                         |:----:|:---:|:---:|:---:|:---:|\n                         | X  | -  |   |   |   |\n                         | Y  |   |   |`select`(X, c)   |   |\n                         | Z  |   |   |   |   |\n                         }}}\n                  #md {{{\n                         For every $(X,c)\\in\\Sigma_1\\times \\Sigma_0$, we set the table entry as:\n\n                         `$$\n                         \\mathrm{entry}(X,c) = \\left\\{\\begin{array}{ll}\n                         \\mathtt{select}(X, c) \u0026 \\mathrm{if\\ no\\ exception} \\\\\n                         \\mathrm{empty} \u0026 \\mathrm{else}\n                         \\end{array}\\right.\n                         $$`\n                         }}}\n                  )\n            )\n      )\n",
                    "istop": false,
                    "path": "03.topdown-parsing/parser"
                },
                "05.grammar-design": {
                    "children": ["05.grammar-design/calc", "05.grammar-design/intro", "05.grammar-design/sdd"],
                    "content": "{:title \"Grammar Design with ANTLR\"\n :summary #md {{{\n                 We will look at how to programmatically\n                 design and process grammars using\n                 ANTLR.\n                 }}}\n }\n",
                    "istop": false,
                    "path": "05.grammar-design"
                },
                "05.grammar-design/calc": {
                    "children": [],
                    "content": "{:title \"A Calculator Example\"\n :rank 3\n :summary #md {{{\n                 We are going to use embedded actions\n                 and attributes to build a fully\n                 functional calculator interpreter.\n                 }}}\n }\n\n(page :wide\n      (:h1 \"The grammar\")\n\n      (file {:codewalk true\n             :filename \"Calc.g4\"}\n            \"src/calc/Calc.g4\"))\n\n(page (:h1 \"Challenge\")\n\n      #md {{{\n             Can you:\n\n             1. Write an application that makes use of the grammar?\n\n             2. Add more syntax such as the symbolic constant `pi`,\n             and trignometric functions of `sin`, `cos`, and `tan`?\n             }}})\n\n(:h1 \"Stateful Calculator\")\n\n(page (:h1 \"Syntax for variables\")\n\n      #md {{{\n             We want to support programs with variables:\n\n             ```\n             radius = 10.2\n             pi = 3.1415\n             area = pi * radius * radius\n\n             area\n\n             base = 10.2\n             top = 5.0\n             height = 5.1\n             (1/2) * (base + top) * height\n             ```\n             }}}\n\n      (:h2 \"Updating the grammar\")\n\n      (rows :sep 4 8\n        #md {{{\n               We need to update the grammar with _variables_.\n               }}}\n        #md {{{\n               ```\n               expr : expr \u0027*\u0027 expr\n                    | expr \u0027/\u0027 expr\n                    | expr \u0027+\u0027 expr\n                    | expr \u0027-\u0027 expr\n                    | \u0027(\u0027 expr \u0027)\u0027\n                    | Number\n                    | ID\n                    ;\n\n               ID : [a-z]+;\n\n               Number : [0-9]+ (\u0027.\u0027 [0-9]+)?;\n\n               WS : [ \\t]+ -\u003e skip;\n               ```\n               }}}\n\n        #md {{{\n               We also need to introduce the symbol assignment\n               statements.\n               }}}\n        #md {{{\n               ```\n               program : statement+;\n\n               statement : assignment | expr;\n\n               assignment : ID \u0027=\u0027 expr;\n               ```\n               }}})\n\n      (:h2 \"Updating the embedded actions\")\n\n      (row 6 6\n        #md {{{\n               We need to create a stateful storage, called _symbol table_,\n               associated with the parser.  This will\n               be a member to the `CalcParser` class.\n               }}}\n\n        #md {{{\n               It will be of type:\n\n               ```\n               Map\u003cString, Double\u003e symTable;\n               ```\n\n               It stores the value of the variables that have\n               been declared.\n               }}})\n      )\n\n(page :wide\n      (:h1 \"A self-contained Antlr grammar file\")\n\n      #md {{{\n             We will demonstrate the usage of `@header`\n             and `@members` sections to create\n             a grammar file that will generate an executable\n             parser class.\n             }}}\n\n      (file {:codewalk true\n             :filename \"Calc2.g4\"}\n            \"src/calc2/Calc2.g4\")\n      )\n\n\n",
                    "istop": false,
                    "path": "05.grammar-design/calc"
                },
                "05.grammar-design/intro": {
                    "children": [],
                    "content": "{:title \"About ANTLR\"\n :rank 1\n :summary #md {{{\n                 Let\u0027s cover the basics of ANTLR.\n                 }}}\n }\n\n(:h1 \"The grammar file\")\n\n(page (:h1 \"Sections\")\n      #md {{{\n             An ANTLR grammar file is a specification\n             of a CFG with lexical analysis rules.\n\n             So, it contains two parts:\n\n             1. The grammar\n             2. The lexer\n             }}}\n\n      (:h2 \"Separation of grammar rules from lexical rules\")\n      #md {{{\n             - Syntactic variables *must* start with lower letters\n             - Token names are the terminals, and they *must* start\n             with uppercase letters.\n             }}}\n\n      (:h2 \"The overall section\")\n\n      #md {{{\n             An ANTLR grammar file has the following general sections:\n             }}}\n\n      (codewalk :java\n                {{{\n                   // ===============\n                   //  All grammar files starts\n                   //  with the declaration of the grammar name\n                   // ===============\n                   grammar \u003cgrammar_name\u003e;\n\n                   // ===============\n                   // The header section is _optional_.\n                   // Everything in the header section\n                   // goes into the start of the generated Java\n                   // file.\n                   //\n                   // This allows package declarations,\n                   // and import statements.\n                   // ===============\n                   @header {\n                     ...\n                   }\n\n                   // ===============\n                   // The `members` section is _optional_.\n                   // Everything in the members section\n                   // is added to the _inside_ of the\n                   // generated parser class.\n                   //\n                   // This allows declarations of new\n                   // class members.\n                   // ===============\n                   @members {\n                     ...\n                   }\n\n                   // ==================\n                   // The grammar rules\n                   // are declared.\n                   //\n                   // All syntactic variables\n                   // must start with a lowercase letter.\n                   // ==================\n                   \u003cgrammar rules\u003e\n                   ...\n\n                   // ==================\n                   // The lexical rules are declared.\n                   //\n                   // All token names must start with an uppercase letter.\n                   // ==================\n                   \u003clexical rules\u003e\n                   ...\n                   }}})\n      )\n\n(page (:h1 \"Life cycle of a grammar file\")\n      (rows :sep 4 8\n            (:h2 \"Author grammar file\")\n            #md {{{\n                   The developer is responsible to author\n                   the grammar file together with the lexical\n                   rules of the tokens.\n                   }}}\n\n            (:h2 \"Example:\")\n            (file :codewalk {:filename \"Example1.g4\"} \"src/uoit/csci4020u/Example1.g4\")\n\n            (:h2 \"Generating parser code\")\n            (:div #md {{{\n                         ANTLR is a tool that converts the grammar\n                         file into one or more source code files\n                         for the lexer and parser.\n                         }}}\n                  (code :bash\n                        {{{\n                           $ export ANTLR=\u003cpath to antlr.jar\u003e\n                           $ java -jar $ANTLR Example1.g4\n                         }}})\n                  (code :bash\n                        {{{\n                           $ ls *.java\n                           Example1Lexer.java Example1Parser.java ...\n                           }}}))\n\n            (:h2 \"What are generated?\")\n            (:div (code :java\n                        {:label \"Example1Lexer.java\"}\n                        {{{\n                           package uoit.csci4020u;\n                           import java.util.*;\n\n                           public class Example1Lexer extends Lexer {\n                             ...\n                           }\n                           }}})\n                  (code :java\n                        {:label \"Example1Parser.java\"}\n                        {{{\n                           package uoit.csci4020u;\n                           import java.util.*;\n\n                           public class Example1Parser extends Parser {\n                             private int couter = 0;\n                             public void smiley() {\n                               System.out.println(\"\ud83d\ude42\");\n                             }\n                             ...\n                             public final NumberListContext numberList() throws RecognitionException {\n                               ...\n                             }\n                             ...\n                           }\n                           }}}))\n            )\n      )\n\n(page (:h1 \"Writing applications\")\n      #md {{{\n             We make use of the parser in several steps.\n             }}}\n\n      (file :codewalk\n            :java\n            {:filename \"App.java\"}\n            \"src/App.java\")\n      )\n",
                    "istop": false,
                    "path": "05.grammar-design/intro"
                },
                "05.grammar-design/sdd": {
                    "children": [],
                    "content": "{:title \"Syntax Directed Definitions\"\n :rank 2\n :summary #md {{{\n                 In this section, we demonstrate _actions_\n                 and _values_ as part of the grammar productions.\n                 This allows us to use _the parser_ as a platform\n                 for computation.\n\n                 This style of programming is known as _syntactic directed definitions_.\n                 }}}\n }\n\n(:h1 \"Actions\")\n\n(page (:h1 \"Triggers\")\n      #md {{{\n             Consider a production of the form:\n\n             ```\n             expr : A \u0027+\u0027 B\n             ```\n             }}}\n\n      #md {{{\n             We would like to register blocks\n             of code to selected symbols so that\n             whenever their respective node in the parse\n             tree is created, the block of code is\n             to be executed.\n             }}}\n\n      #md {{{\n             Syntactically, we use `{ ... }`\n             to attach code to the symbols\n             in the _body_ of the productions.\n\n             ```\n             expr : A { print(\"A is matched\"); }\n                    \u0027+\u0027\n                    B { print(\"B is matched\"); }\n                    ;\n             ```\n             }}}\n\n      (box #md {{{\n                  _Definition_: Actions:\n\n                  \u003e The code blocks in the form of `{...}`\n                  are called _actions_.\n                  }}}\n           #md {{{\n                  \u003e They can be thought of as _symbols_\n                  that always match $\\epsilon$.  Namely,\n                  they are assumed immediately by the parser.\n                  }}})\n      )\n\n(page (:h1 \"Example\")\n\n      #md {{{\n             Suppose we want to parse arbitrary arithmetic expressions\n             over integers.\n             }}}\n\n      #md {{{\n             We want to be able to count the number of additions\n             and multiplications to be performed.\n\n             \u003e This can be done easily by just looking for `\u0027+\u0027` and `\u0027*\u0027`.\n             But let\u0027s use actions to do the same.\n             }}}\n\n      (rows 2 10\n            (:h2 \"The grammar file\")\n            (file :codewalk\n                  {:filename \"Expr.g4\"}\n                  \"src/counters/Expr.g4\")\n\n            (:h2 \"The application file\")\n            (file :codewalk {:filename \"App.g4\"}\n                  \"src/counters/App.java\"))\n\n      )\n\n(:h1 \"Attributes\")\n\n(page (:h1 \"Data at nodes\")\n\n      (row 6 6 \n           #md {{{\n                  So far, a parse tree consists of nodes that are labeled only by\n                  _symbols_.\n\n                  Now, we will extend the nodes so they can have arbitrary data.\n                  }}}\n           (image \"parse-tree-with-data.png\"))\n\n      (box #md {{{\n                  ## Definition: _Attributes_\n\n                  \u003e Each node in the parse tree can have _data_ associated with it.\n                  \u003e\n                  \u003e The data must be in the form of $$\\mathrm{attribute}\\mapsto\\mathrm{value}$$\n                  }}})\n\n      (rows :sep 4 8\n            (:h2 \"Attributes\")\n            #md {{{\n                   Each node in the parse tree can have data associated with it.\n                   The node can have zero or more attributes of arbitrary Java type.\n                   }}}\n\n            (:h2 \"Declaring attributes\")\n            #md {{{\n                   Syntactic variables can have one or more attributes with arbitrary Java types.\n\n                   ```\n                   expr returns [int counter, Map\u003cString, Integer\u003e map]\n                     : ...\n                     | ...\n                     ;\n                   ```\n                   }}}\n\n            (:h2 \"Computing attribute value\")\n            (:div #md {{{\n                         The attributes can be referenced as `$attr`.  For example,\n                         for `expr returns [int counter, Map map]`,\n                         the attributes can be referred to as `$counter` and `$map`.\n\n                         The attribute values are computed in embedded actions:\n\n                         ```\n                         {\n                           $attr = ...;\n                         }\n                         ```\n                         }}}\n                  #md {{{\n                         Sometimes, initialization is needed to compute the attributes.\n                         For instance, `Map\u003c...\u003e` needs to be constructed as:\n\n                         ```\n                         $map = new HashMap\u003cString, Integer\u003e();\n                         ```\n\n                         This is done by the `@init {...}` block of the syntactic\n                         variable productions.\n\n                         ```\n                         expr returns [int counter, Map\u003cString, Integer\u003e map]\n                           @init {\n                             $map = new HashMap\u003cString, Integer\u003e();\n                           }\n                           : ...\n                           | ...\n                           ;\n                         ```\n                         }}})\n            (:h2 \"Referencing attribute values\")\n            (:div #md {{{\n                         How do we refer to the _computed_ attribute values?\n\n                         1. We must have a reference to the _node_ of\n                         the parse tree by a _label_.\n\n                         2. We can refer to the attribute in the form\n                         of `$label.attribute`.\n                         }}})\n            (:h2 \"Referrencing a node in production\")\n            (:div {:class \"nomath\"} \n                  #md {{{\n                         Suppose we have a production with an embedded action:\n\n                         ```\n                         expr returns [int a, String b]\n                           : expr \u0027+\u0027 expr { \u003cembedded action\u003e }\n                           | ...\n                           ;\n                         ```\n                         }}}\n                  #md {{{\n                         The embedded action can refer to the attributes\n                         of the three _nodes_:\n\n                         1. `expr`: the first occurrence of `expr`\n                         2. `\u0027+\u0027`: the terminal token\n                         3. `expr`: the second occurrence of `expr`.\n                         }}}\n                  #md {{{\n                         To distinguish different nodes with the _same_ symbol,\n                         we can assign _labels_ to the nodes:\n\n                         ```\n                         expr returns [int a, String b]\n                           : e1=expr \u0027+\u0027 e2=expr { \u003cembedded action\u003e }\n                           | ...\n                           ;\n                         ```\n                         }}}\n                  #md {{{\n                         The embedded action can refer to the computed attributes\n                         as when computing the attributes of the current node:\n\n                         ```\n                         $b = $e1.b + $e2.b;\n                         $a = $e1.a - $e2.a;\n                         ```\n                         }}}\n                  )\n            )\n      )\n\n",
                    "istop": false,
                    "path": "05.grammar-design/sdd"
                },
                "06.interpreters": {
                    "children": [],
                    "content": "{:title \"Building an interpreter\"\n :summary #md {{{\n                 In this section, we will develop a Turing complete\n                 interpreter.  We will see how to represent programming\n                 constructs as generic data structures, and how such\n                 data structures can be processed by an _interpreter_.\n                 Finally, we will design a grammar with SDD to\n                 generate the data structures as the input to the\n                 interpreter.\n                 }}}\n }\n\n(:h1 \"Part 1: data structures for programming constructs\")\n\n(page (box #md {{{\n                  Amid the COVID 19 situation, the reminder of the course will be given\n                  as online videos.\n                  }}})\n      )\n\n(page (html {{{\n               \u003ciframe src=\"https://player.vimeo.com/video/398445962\" width=\"640\" height=\"361\" frameborder=\"0\" allow=\"autoplay; fullscreen\" allowfullscreen\u003e\u003c/iframe\u003e\n               }}}))\n\n(page (html {{{\n               \u003ciframe src=\"https://player.vimeo.com/video/398751629\" width=\"640\" height=\"361\" frameborder=\"0\" allow=\"autoplay; fullscreen\" allowfullscreen\u003e\u003c/iframe\u003e\n               }}}))\n\n(page (html {{{\n               \u003ciframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/vWL8Sw0sJWM\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen\u003e\u003c/iframe\u003e\n               }}}))\n\n(page (html {{{\n               \u003ciframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/q3VliV1U4Po\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen\u003e\u003c/iframe\u003e\n               }}}))\n",
                    "istop": false,
                    "path": "06.interpreters"
                },
                "07.compiler": {
                    "children": ["07.compiler/basics-of-jvm", "07.compiler/programming-bytecode"],
                    "content": "{:title \"Building an compiler\"\n :summary #md {{{\n                 In this section, we introduce the JVM and its programming model.\n                 We will present the JVM instruction set known as Java bytecode,\n                 and demonstrate how they are used in practice to implement\n                 basic programming constructs.\n                 }}}\n }\n",
                    "istop": false,
                    "path": "07.compiler"
                },
                "07.compiler/basics-of-jvm": {
                    "children": [],
                    "content": "{:title \"Basics of JVM\"\n :summary #md {{{\n                 In this section, we introduce the programming model\n                 of the Java virtual machine, and a subset\n                 of the JVM bytecode instructions.\n                 }}}\n }\n\n(page (html {{{\n               \u003ciframe src=\"https://docs.google.com/presentation/d/e/2PACX-1vQHZEFE3RJwWJ209F8UYUx7-kG2ycp5jPKXVmtj5BwKsq3NXU6Lu0OPnkBmB1b7GnKw3ffh59i3i_2p/embed?start=false\u0026loop=false\u0026delayms=3000\" frameborder=\"0\" width=\"480\" height=\"299\" allowfullscreen=\"true\" mozallowfullscreen=\"true\" webkitallowfullscreen=\"true\"\u003e\u003c/iframe\u003e\n               }}})\n      )\n\n(page (:h1 \"March 30, 2020\")\n\n      (rows :sep 12\n            (image \"1.png\")\n            (image \"2.png\")\n            (image \"3.png\")\n            (image \"4.png\")\n            (image \"5.png\")\n            (image \"6.png\")\n            (image \"7.png\")\n            (image \"8.png\")\n            (image \"9.png\")\n            )\n      )\n",
                    "istop": false,
                    "path": "07.compiler/basics-of-jvm"
                },
                "07.compiler/programming-bytecode": {
                    "children": [],
                    "content": "{:title \"Programming in Bytecode\"\n :summary #md {{{\n                 In this section, we review the basics of JVM\n                 and demonstrate how the instructions are used\n                 to implement basic programming constructs.\n                 }}}\n }\n\n(page (:h1 \"April 2, 2020\")\n\n      (rows :sep 12\n            (image \"1.png\")\n            (image \"2.png\")\n            (image \"3.png\")\n            (image \"4.png\")\n            (image \"5.png\")\n            (image \"6.png\")\n            (image \"7.png\")\n            (image \"8.png\")\n            )\n      )\n\n(page (:h1 \"Sample code\")\n\n      (file :small \"Base.j\")\n      )\n",
                    "istop": false,
                    "path": "07.compiler/programming-bytecode"
                }
            };
    var root_path = "/KenPuOldWebsite/compilers/";
    var reload_path = window.origin + root_path;
    console.log("app.core.main()");
    app.core.main();
</script>
</body>

<!-- Mirrored from db.science.uoit.ca/library/teaching/compilers by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 06 Apr 2020 22:35:50 GMT -->
</html>