<html>

    
<!-- Mirrored from db.science.uoit.ca/library/teaching/programming-languages by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 06 Apr 2020 22:45:06 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
        <meta name="viewport" content="width=device-width, initial-scale=1 maximum-scale=1">
        <link rel="icon" href="../static/favicon.png"/>
        <title>programming-languages</title>
        <!--
        <link rel="stylesheet" href="/library/static/yeti-bootstrap.min.css">
        -->
        <link rel="stylesheet" href="../static/font-awesome/css/font-awesome.min.css">
        <link rel="stylesheet" href="../static/css/fonts/fonts.css">
        <link rel=stylesheet href="../static/prism/prism.css">
        <link rel=stylesheet href="../static/client/css/app.css">
        <link rel=stylesheet href="../static/client/css/bookie.css">
    </head>

<body>
<div id="app"></div>
<div id="app-resources" style="display: none">
    <ul>
        
        <li><a href="index.clj">index.clj</a></li>
        
        <li><a href="1-computation/index.html">1-computation/index.clj</a></li>
        
        <li><a href="1-computation/2-turing-machine/content.html">1-computation/2-turing-machine/content.clj</a></li>
        
        <li><a href="1-computation/2-turing-machine/tm-control-1.html">1-computation/2-turing-machine/tm-control-1.jpg</a></li>
        
        <li><a href="1-computation/2-turing-machine/tm-tape-1.html">1-computation/2-turing-machine/tm-tape-1.jpg</a></li>
        
        <li><a href="1-computation/2-turing-machine/tm-head-1.html">1-computation/2-turing-machine/tm-head-1.jpg</a></li>
        
        <li><a href="1-computation/1-history/john-von-neumann.html">1-computation/1-history/john-von-neumann.jpg</a></li>
        
        <li><a href="1-computation/1-history/john-mccarthy.html">1-computation/1-history/john-mccarthy.jpg</a></li>
        
        <li><a href="1-computation/1-history/david-hilbert.html">1-computation/1-history/david-hilbert.png</a></li>
        
        <li><a href="1-computation/1-history/content.html">1-computation/1-history/content.clj</a></li>
        
        <li><a href="1-computation/1-history/john-backus.html">1-computation/1-history/john-backus.jpg</a></li>
        
        <li><a href="1-computation/1-history/alan-turing.html">1-computation/1-history/alan-turing.png</a></li>
        
        <li><a href="1-computation/1-history/alonzo-church.html">1-computation/1-history/alonzo-church.png</a></li>
        
        <li><a href="1-computation/1-history/kurt-godel.html">1-computation/1-history/kurt-godel.png</a></li>
        
        <li><a href="1-computation/3-lambda-calculus/arithmetics.html">1-computation/3-lambda-calculus/arithmetics.clj</a></li>
        
        <li><a href="1-computation/3-lambda-calculus/index.html">1-computation/3-lambda-calculus/index.clj</a></li>
        
        <li><a href="2-Clojure/index.html">2-Clojure/index.clj</a></li>
        
        <li><a href="2-Clojure/7-macros/backtick.html">2-Clojure/7-macros/backtick.png</a></li>
        
        <li><a href="2-Clojure/7-macros/index.html">2-Clojure/7-macros/index.clj</a></li>
        
        <li><a href="2-Clojure/4-standard-library/index.html">2-Clojure/4-standard-library/index.clj</a></li>
        
        <li><a href="2-Clojure/3-lazy/index.html">2-Clojure/3-lazy/index.clj</a></li>
        
        <li><a href="2-Clojure/6-oop/index.html">2-Clojure/6-oop/index.clj</a></li>
        
        <li><a href="2-Clojure/1-data/index.html">2-Clojure/1-data/index.clj</a></li>
        
        <li><a href="2-Clojure/1-scopes/index.html">2-Clojure/1-scopes/index.clj</a></li>
        
        <li><a href="2-Clojure/0-setup/clojuredocs.html">2-Clojure/0-setup/clojuredocs.png</a></li>
        
        <li><a href="2-Clojure/0-setup/brave-n-bold.html">2-Clojure/0-setup/brave-n-bold.png</a></li>
        
        <li><a href="2-Clojure/0-setup/programming-clojure.html">2-Clojure/0-setup/programming-clojure.jpg</a></li>
        
        <li><a href="2-Clojure/0-setup/index.html">2-Clojure/0-setup/index.clj</a></li>
        
        <li><a href="2-Clojure/4-data-transformation/index.html">2-Clojure/4-data-transformation/index.clj</a></li>
        
        <li><a href="2-Clojure/5-clojure-projects/index.html">2-Clojure/5-clojure-projects/index.clj</a></li>
        
        <li><a href="2-Clojure/8-tools/index.html">2-Clojure/8-tools/index.clj</a></li>
        
        <li><a href="2-Clojure/2-general-programming/index.html">2-Clojure/2-general-programming/index.clj</a></li>
        
        <li><a href="3-Scala/index.html">3-Scala/index.clj</a></li>
        
        <li><a href="3-Scala/2-syntax/ex1.html">3-Scala/2-syntax/ex1.scala</a></li>
        
        <li><a href="3-Scala/2-syntax/index.html">3-Scala/2-syntax/index.clj</a></li>
        
        <li><a href="3-Scala/4-general-programming/index.html">3-Scala/4-general-programming/index.clj</a></li>
        
        <li><a href="3-Scala/3-types/type-hierarchy.html">3-Scala/3-types/type-hierarchy.png</a></li>
        
        <li><a href="3-Scala/3-types/index.html">3-Scala/3-types/index.clj</a></li>
        
        <li><a href="3-Scala/2-scala-programming/index.html">3-Scala/2-scala-programming/index.clj</a></li>
        
        <li><a href="3-Scala/1-pure-oop/index.html">3-Scala/1-pure-oop/index.clj</a></li>
        
    </ul>
</div>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    elements: [],
    skipStartupTypeset: true,
    /*
    "HTML-CSS": {
        scale: 83,
    },
    */
    //showMathMenu: false,
    //zoom: "None",
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
      processEscapes: true,
      skipTags: ["script", 
      "noscript", 
      "style", 
      "textarea", 
      "nomath", 
      //"pre",
      ],
      // nomathjax used by (code ...) component
      ignoreClass: "nomath|nomathjax|tex2jax_ignore", 
    },
    /*
    TeX: {
        equationNumbers: {autoNumber: "AMS"},
    },
    */
  });
</script>
<script>
(function() {
var throttle = function(type, name, obj) {
    obj = obj || window;
    var running = false;
    var func = function() {
        if (running) { return; }
        running = true;
         requestAnimationFrame(function() {
            obj.dispatchEvent(new CustomEvent(name));
            running = false;
        });
    };
    obj.addEventListener(type, func);
};
throttle("resize", "__resize__");
throttle("scroll", "__scroll__");
})();
</script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js"></script>
    <!--
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
    -->


<!--
Prism from CDN does not come with line number plugin
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/prism.min.js"></script>
-->
<script src="../static/prism/prism.js"></script>
<script src="../static/prism/prism-extension.js"></script>
<script src="../static/client/main.js"></script>

<script>
    var sitemap = {"": {"children": ["1-computation", "2-Clojure", "3-Scala"], "content": "{:title \"Programming Languages\"\n :status \"3055\"\n ; :cover \"cover.jpg\"\n :rank \"3055\"\n :categories [\"course\"]\n :summary #md {{{\n                This course covers the foudation and design principles of\n                different programming languages.  We will survey several programming\n                paradigms and their respective representative languages.\n\n                Students will gain working knowledge of selected languagse to\n                appreciate the hyperproductivity of selecting the _right_ language\n                for the type of computational tasks at hand.\n              }}}\n}\n\n", "istop": false, "path": ""}, "1-computation": {"children": ["1-computation/1-history", "1-computation/2-turing-machine", "1-computation/3-lambda-calculus"], "content": "{:title \"Theories of Computation\"\n :summary #md {{{\n             _Computation_ was much more of a discovery than an invention.\n             In this section, we will cover the history of the discovery of\n             computation, and two _surprising_ formulations of computation:\n             the Turning Machine and Lambda Calculus.\n             It\u0027s quite incredible that modern programming languages are\n             heavily influenced by the two computational models.\n          }}}\n}\n", "istop": false, "path": "1-computation"}, "1-computation/1-history": {"children": [], "content": "{:title \"History of Computation\"\n :status :done\n :summary #md {{{\n                The history of computation is interesting in\n                its own right.  Our focus is to draw\n                the connection between the growth of\n                Computer Science with the provenance of\n                modern day programming languages.\n              }}}}\n\n(page (:h1 \"A challenge from David Hilbert\")\n      (row 6 6\n           (image \"david-hilbert.png\")\n           #md {{{\n                  - David Hilbert:\n                    \u003e \"_He is recognized as one of the most influential and\n                    universal mathematicians of the 19th and early 20th\n                    centuries_\"\n                    \u003e\n                    \u003e Wikipedia\n\n                  - In 1900, Hilbert formulated a collection of mathematical\n                  problems for the community to work on.  Collectively,\n                  they are known as the Hilbert\u0027s problems.\n               }}}))\n\n(page (:h1 \"Hilbert\u0027s 10th problem\")\n      #md {{{\n            - Diophantine equation is an equation whose\n             left-hand side is a polynormial with only\n             integer coefficients and finitely many unknowns\n             to the integer power.  The right-hand side is zero.\n\n               \u003e $x^2 + 78xy - y^6z = 0$\n\n            - Hilbert asks if there is a procedure to decide\n            if there are integer solutions of an arbitarily\n            given diophantine equation.\n\n            - It\u0027s worth noting that if we relax the solution space\n            to real numbers, then it can be decided.  Matlab does it.\n          }}})\n\n(page (:h1 \"Hilbert\u0027s Entscheidungsproblem\")\n      #md {{{\n             Before the 10th problem was better understood, Hilbert posed\n             a far more grand problem known as the _Entscheidungsproblem_\n             in 1928.\n\n             It questions whether solutions to mathematical problems\n             can be procedurally derived (always) if the mathematical\n             system is properly well-defined.\n          }}}\n\n      (box #md {{{\n                  ## The Entscheidungsproblem\n                  Given first order logic and a set of consistent axioms,\n                  it is possible to always decide if a sentence is true or false.\n               }}}))\n\n(page (:h1 \"G\u00f6del\u0027s incompleteness theorem, 1931\")\n      (row 6 6\n           (image \"kurt-godel.png\")\n           #md {{{\n                  Kurt G\u00f6del, in 1931, three years after Hilbert\u0027s formulation\n                  of the Entscheidungsproblem came up with the _negative_ result.\n\n                  It is possible to assert a set of consistent\n                  axioms, and pose a question in first-order logic that\n                  cannot be decided (to be true or false).  Thus the\n                  logical sentence is _unsolvable_.\n\n                  Such axioms are called _incomplete_.\n               }}}))\n\n(page (:h1 \"An example of incomplete system\")\n      #md {{{\n             Godel not only proved a negative result to the Entscheidungsproblem,\n             he did so by _construction_.\n\n             It\u0027s been well-known that integer arithmetics is axiomizable\n             in first-order logic.  Godel formulated a logical sentence\n             that describes a specific property for a special number known\n             as the Godel\u0027s number.  He showed that such number cannot be\n             derived by logic deduction, and yet it exists.\n          }}} \n      (--*--)\n      #md {{{\n             **Guess what?** Hilbert\u0027s 10th problem from 1900 was in fact such\n             problem.\n\n             There cannot be any mechanical procedure that can handle arbitrary\n             diophanine equations.\n          }}})\n\n(page (:h1 \"Along comes Turing\")\n      (row 6 6\n           (image \"alan-turing.png\")\n           #md {{{\n                  1936: Alan Turing formalized formal reasoning as\n                  _computation_, which is further concretely defined as a\n                  mechanical device, known today as the _Turing Machine_ (TM).\n\n\n                   With TM, Turing was able to reproduce the incompleteness\n                  result of Godel.  Turing\u0027s proof of incompleteness is much\n                  closer to today\u0027s concept of _programming_.\n               }}}))\n\n(page (:h1 \"Then there is Church\")\n      (row 4 8\n           (image \"alonzo-church.png\")\n           #md {{{\n                  Alonzo Church in 1936 (the same year as TM) proposed\n                  a string rewrite system for formally reasoning about\n                  mathematical functions, their definitions and actions.\n                  The rewrite system is known las _Lambda Calculus_ (LC).\n\n\n                  It was soon discovered that LC and TM are _equivalent_.\n\n\n                  Together, Church and Turing seem to agree that TM and LC\n                  model the most powerful computation possible.  So, TM and LC\n                  are the universal upperbound on the ability of mechanical\n                  reasoning.  This bound is called _Turing Completeness_.\n\n                  \n                  The belief that nothing possible beyond Turing Completeness\n                  is called _Church-Turing Thesis_.\n               }}}))\n\n(page (:h1 \"From Computation to Computers\")\n      (row 4 8\n           (image \"john-von-neumann.jpg\")\n           (:div\n             #md {{{\n                    von Neumann was easily the top 3 most prolific physicist,\n                    mathematician and scientist of the 20th century.\n\n\n                    He took the specification of the TM (specifically\n                      the _universal_ TM) and designed a real-life version\n                      out of vacuum tubes.  The system was called\n                      _Electronic Discrete Variable Automatic Computer_ (EDVAC).\n                      }}}\n             #md {{{\n                    EDVAC was innovative in that:\n\n                    1. It was programmable.\n                    2. It was in binary.\n                 }}})))\n\n(page (:h1 \"The birth of structured programming\")\n      (row 4 8\n           (image \"john-backus.jpg\")\n           (:div #md {{{\n                        John Backus in 1953 drafted a proposal\n                        for the development of a revolutionary\n                        way of specifying computation --\n                        a structured programming language known\n                        as the _Formula Translating System_, or\n                        FORTRAN.\n                        }}}\n                 #md {{{\n                        The first FORTRAN compiler was completed\n                        in 1957.  It was performing at par with the\n                        best assembly programmers of that time.\n\n                        The abstraction and syntax of FORTRAN\n                        is almost exactly a modernization of\n                        the Turing Machine of 1936.\n                        }}}\n                 #md {{{\n                        More amazingly, FORTRAN fostered decades\n                        of programming language development including:\n\n                        1. Basic\n                        1. C/C++\n                        2. Java\n                        2. ...\n\n                        FORTRAN is still alive and well in Fortran 2010.\n                     }}})))\n\n(page (:h1 \"Lambda Calculus comes to life\")\n      (row 4 8\n           (image \"john-mccarthy.jpg\")\n           (:div #md {{{\n                        Lambda Calculus focuses on mathematical definitions\n                        and their logical inferences.  John McCarthy in late 1950\n                        (before 1958) drafted a specification of a programming\n                        language based on LC, known as _List Processing_ (Lisp).\n                        }}}\n                 #md {{{\n                        Lisp has been created a subversive community of academics\n                        (mainly at MIT) to create a human-equivalent artificial\n                        intelligence for the past half of a century.\n                        }}}\n                 #md {{{\n                        Lisp\u0027s influence on Computer Science is covert but powerful.\n                        It was the fountain head for ideas such as:\n\n                        1. Dynamic memory allocation\n                        2. Dynamic typing\n                        3. Garbage collection\n                        4. Interpreted code during compilation (macros)\n                        5. Concurrency\n                        }}}\n                 #md {{{\n                        All of these features are now *finally* part of modern (post 2000)\n                        programming languages.\n\n                        Lisp is still alive and well in Common Lisp 2010.\n                     }}})))\n\n(page (:h1 \"Programming languages united\")\n      #md {{{\n             _Functional programming_ (FP) is a paradigm inspired by LC and\n             celebrated by Lisp and its derivatives.\n             While FP has been shown to be much superior at describing\n             computation with correctness succinctly, the runtime for FP\n             has always plagued practical FP in the early days of\n             computers.\n\n             More recently, advancements in compiler technology and computational\n             power (Moore\u0027s law) have fundamentally changed the feasibility\n             of FP in practice.\n          }}}\n      #md {{{\n             ```\n\n                                 Go   JS   Python Rust Swift Scala Kotlin\n              TM \n                 Stateful        x    x    x      x    x     x     x\n\n                 Statements      x    x    x      x    x     x     x\n\n                 Branching       x    x    x      x    x     x     x\n            \n              LC\n                 Immutable       -    -    -      x    x     x     x\n\n                 Statement as   \n                 expressions     -    -    -      x    x     x     x\n\n                 Function\n                 as value        x    x    x      x    x     x     x\n              ```\n            }}})\n", "istop": false, "path": "1-computation/1-history"}, "1-computation/2-turing-machine": {"children": [], "content": "{:title \"Turing Machine\"\n :status :done\n :summary #md {{{\n                 Turing Machine is a mechanical machine\n                 that manipulates 0\u0027s and 1\u0027s on a tape.\n                 It\u0027s simplicity is deceptive, as TM is\n                 as expressive as any modern computers.\n                 TM is a major device for the development\n                 of Computer Science both theoretically\n                 and practically.\n              }}}\n}\n\n(page (:h1 \"TM and this course\")\n      #md {{{\n             TM is the foundation of computation on which\n             _all_ computers are modeled after. Despite\n             its primitive construction and theoretical \n             importance, the notion of _programming_, and how\n             computation can be described through instructions\n             are still vividly obvious once we understand\n             how a TM functions. \n          }}})\n\n\n(page (:h1 \"Binary encoding of problems\")\n      #md {{{\n            Computations is about entering a problem\n            to an automated system (the computer), and \n            have the computer produce the correct answer\n            to the problem.\n\n            *Terminology*\n\n            \u003e **Problem:** \u003cbr\u003e\n            \u003e \u003e an example of a problem is integer addition\n                as given by: _Given two integers $a$ and $b$, what\n                is the sum $a+b$?_ \n            \u003e\n            \u003e **Instance** of the problem: \u003cbr\u003e\n            \u003e \u003e An instance of a problem is a concrete specification\n            \u003e \u003e so that there is a well-defined answer.  An example\n            \u003e \u003e of an instance of addition is:\n            \u003e \u003e - $a = 10$ \n            \u003e \u003e - $b = 2$\n          }}}\n\n      (:div #md {{{\n                *Algorithm*\n\n                 An algorithm for a problem is a procedure that can\n                 compute the answer of *every* instance of the problem,\n                 for example a function `int add(int a, int b)`.\n                }}}\n        (box #md {{{\n                    Hilbert\u0027s Entscheidungsproblem can be formulated as:\n\n                    \u003e Do all mathematical problems have an algorithm?\n                    \n                    To answer the question, we must be able to define\n                    what an algorithm is.\n                 }}}))\n\n      (:div #md {{{\n                  *Binary encoding*:\n\n                  \u003e For every meaningful problem, there exists\n                  a well-defined encoding that maps each instance\n                  to a finite string consisting of 0 or 1.  \n\n                  For example, consider the integer addition problem.\n                  Can you think of an encoding that maps *every* instance\n                  of the problem to a binary string?\n                }}}\n            (:p {:style {:text-align :right\n                         :padding 30\n                         :font-style :italic}}\n                \"~ Be sure that your encoding takes care of arbitrarily\n                large integers.\")))\n\n(page (:h1 \"Functions over binary strings\")\n      #md {{{\n            - Let $\\mathbf{P}$ be the set of problem instances.\n            - Let $\\mathrm{sol}(\\mathbf{P})$ be the solutions of the instances.\n            - An algorithm is a function $\\mathcal{A} : \\mathbf{P}\\to\\mathrm{sol}(\\mathbf{P})$.\n\n            By the binary encoding assumption, we also have the following functions:\n\n            - `$\\mathrm{enc}: \\mathbf{P} \\to 2^*$` \n            where $2^*$ is the set of finite binary strings.\n\n            - `$\\mathrm{dec} : 2^* \\to \\mathrm{sol}(\\mathbf{P})$`\n          }}}\n      \n      #md {{{\n            Alan Turing had a brilliant realization that we only need\n            to work with binary strings when reasoning about computation.\n\n            Consider a function `$f: 2^* \\to 2^*$` such that it satisfies the\n            following condition:\n\n            `$$\n            \\forall x\\in\\mathbf{P}: \\mathrm{dec}(f(\\mathrm{enc}(x))) = \\mathcal{A}(x)\n            $$`\n          }}}\n      )\n\n(page (:h1 \"TM: a mechanical device\")\n      #md {{{\n            Let\u0027s go through the Turing machine by its components.\n          }}}\n\n      (:h2 \"The tape\")\n\n      (row 4 8\n           (image \"tm-tape-1.jpg\")\n           #md {{{\n                - The TM has an _infinitely_ long tape that is divided into cells.\n                Each cell can been **blank**, **0**, or **1**.\n\n                - One or more finitely binary strings can be stored on\n                the tape.\n\n                - The cells are indexed with position 0, 1, 2, 3, ...\n\n                - At any time, one position is marked _current_.\n               }}})\n      \n      (:h2 \"The head\")\n      (row 4 8\n           (image \"tm-head-1.jpg\")\n           #md {{{\n                - The head can be positioned at any cell in\n                the tape.  The cell with the head is called\n                the _current cell_.\n\n                - It can read the symbol in the current cell.\n\n                - It can also be instructed to modify the content\n                of the current cell.\n               }}})\n\n      (:h2 \"The control logic\")\n      (row 4 8\n           (image \"tm-control-1.jpg\")\n           (div\n             #md {{{\n                  - The control logic is a finite state machine.\n\n                  - The control logic is driven by the symbols\n                  read by the head.\n\n                  - The control logic emits commands to the head.\n\n                  - The commands are:\n\n                    1. Nothing\n                    2. Move(left), Move(right), No move\n                    4. Write(blank), Write(0), Write(1)\n                 }}}\n               (html {{{\n                        \u003ciframe src=\"https://docs.google.com/presentation/d/e/2PACX-1vTlQu-c2PSkXMOVX7Kp-J6QFNkydlznEhL1qgcJTJvQnLr21hHvkOEOoeoxhbyrVLlzjYPThcoFqu3T/embed?start=false\u0026loop=false\u0026delayms=3000\" frameborder=\"0\" width=\"480\" height=\"299\" allowfullscreen=\"true\" mozallowfullscreen=\"true\" webkitallowfullscreen=\"true\"\u003e\u003c/iframe\u003e\n                      }}})))\n      ); page\n\n(page (:h1 \"Execution of TM\")\n      \n      #md {{{\n             - The TM starts with its control logic in the initial state.\n             - The head is set at the left-most position of the tape.\n\n             It performs the following steps:\n\n             ```\n             STATE = initial_state\n             POSITION = 0 \n\n             while True:\n             \u2506    \n             \u2506   if STATE is halting:\n             \u2506   \u2506   break\n             \u2506    \n             \u2506   SYMBOL = TAPE[POSITION]\n             \u2506\n             \u2506   next_state, $\\Delta$Position, next_symbol = get_transition(STATE)\n             \u2506\n             \u2506   STATE = next_state\n             \u2506\n             \u2506   POSITION = POSITION + $\\Delta$Position\n             \u2506\n             \u2506   if next_symbol $\\not=$ None:\n             \u2506   \u2506   TAPE[POSITION] = next_symbol\n             \u2506    \n             return TAPE\n             ```\n          }}})\n\n\n(page (:h1 \"Practical considerations\")\n      (box #md {{{\n                  TM can almost be implemented electro-mechanically.\n                  The *only* impractical element of a theoretical\n                  TM is its assumption that the tape is _infinite_.\n               }}})\n); page\n\n(page (:h1 \"TM and computable functions\")\n      #md {{{\n            Let\u0027s first examine how a TM solves problem $\\mathbf{P}$.\n\n            - Given an arbitrary instance $p\\in \\mathbf{P}$,\n            we need to encode it as a binary string $\\mathrm{enc}(p)$\n            which is to be stored on the tape of TM.\n\n            - We execute the control logic.\n\n            - Hopefully, TM will come to termination.  The tape\n            will contain the solution as a binary string `$s_\\mathrm{final}$`,\n            and `$\\mathbf{solution}(p) = \\mathrm{dec}(s_\\mathrm{final})$`.\n          }}}\n\n      #md {{{\n            We see that a TM always implements a _partial_ function\n            on binary strings.\n\n            *Definition* (Computable functions)\n\n            \u003e Let `$f:2^*\\to 2^*$`.  If there exists a TM implements $f$,\n            then we say that $f$ is computable.\n\n            *Definition* (Decidable functions)\n\n            \u003e If `$f:2^*\\to\\{0, 1\\}$`, and $f$ is computable, then\n            we say that $f$ is _decidable_.\n          }}}\n\n      (box #md {{{\n                 A TM is **equivalent** to a computer (as we know it today).\n\n                 - The tape is the memory.\n                 - The head is the data bus.\n                 - The finite state machine control logic is the processor.\n               }}})\n); page\n\n(page (:h1 \"The Universal TM\")\n      #md {{{\n            Given an algorithm $\\mathcal{A}$, we can have a\n            corresponding TM, call it $\\mathbf{TM}(\\mathcal{A})$\n            that implements $\\mathcal{A}$.  The actual _magic_ of\n            $\\mathbf{TM}(\\mathcal{A})$ is the control logic\n            as a finite state machine.\n          }}}\n      #md {{{\n             This is somewhat unsatisfying:\n\n             - One needs a new TM for every algorithm.\n             - Every TM is only good for a specific algorithm.\n\n             What about _programming_?\n\n             Alan Turing came to a profound realization:\n\n             \u003e Turing Machine is powerful enough to simulate itself.\n          }}}\n\n      (:h2 \"Simulation\")\n      #md {{{\n            Consider theh following problem $\\mathbf{SIM}$:\n\n            \u003e The input is \n            \u003e 1. a Turing machine $\\mathbf{M}$, and\n            \u003e 2. the initial content of the tape of $\\mathbf{M}$.\n\n            The solution we want is:\n\n            \u003e _What is the eventual tape content if $\\mathbf{M}$ terminates?_\n\n            *Theorem*:\n\n            \u003e - TM can be encoded into binary strings.\n            \u003e - The problem $\\mathbf{SIM}$ is computable.\n                Therefore there exists an algorithm to solve $\\mathbf{SIM}$.  Let\u0027s\n                call this algorithm $\\mathbf{SIM}$ as well.\n            \u003e - There exists a TM, $\\mathbf{TM}(\\mathbf{SIM})$, that implements\n                the simulation any Turing machine with arbitrary inputs.  We call\n                this very special TM the _Universal Turing Machine_ (UTM).\n          }}}\n\n      (:h2 \"UTM\")\n      #md {{{\n            UTM is a societal wide paradigm shifting discovery.  It is\n            immediately responsible for the modern day programmable\n            computing devices.\n\n            The following table compares the theoretical formulation\n            of simulation of a turing machine $M$ with input problem\n            $I$ on a UTM.\n          }}}\n\n      (:table.table.table-bordered.bookie-target\n        {:style {:font-size \"110%\"}}\n        (:tbody\n          (:tr\n            (:th \"UTM simulation of $(M, I)$\") (:th \"Modern day computer\"))\n          (:tr\n            (:td \"Tape\") (:td \"Disk\"))\n          (:tr\n            (:td \"Encoding of $I$ on tape\")\n            (:td \"The data memory region\"))\n          (:tr\n            (:td \"Encoding function of $I$\")\n            (:td \"Binary data format\"))\n          (:tr\n            (:td \"Encoding of $M$ on tape\") \n            (:td \"The code memory region such as the boot record\"))\n          (:tr\n            (:td \"Encoding function of $M$\")\n            (:td \"The programming language such as low level instructions\"))\n        ))\n); page\n\n(page (:h1 \"Undecidability of the properties of TM\")\n      #md {{{\n             $\\newcommand{\\h}{\\mathbf{accept}}$\n            Remember how computation started?\n\n            -- _Entscheidungsproblem_\n\n            \u003e 1. TM can be defined using mathematical logic (first-order logic)\n            \u003e 2. Can we define a property of a TM that cannot be decided\n            by a TM?\n            \u003e\n            \u003e ---\n            \u003e\n            \u003e Yes\n\n          }}}\n\n      #md {{{\n            Let\u0027s consider using TM to perform _decisions_.\n\n            \u003e A decision TM is TM that can:\n            \u003e\n            \u003e - _accepts_ the input $x\\in 2^*$ or\n            \u003e - _rejecting_ the input $x$.\n          }}}\n\n      (note #md {{{\n                   We can define _acceptance_ of TM of $x$ as\n                   that TM halts, and the `TAPE[0] == 1`.\n\n                   If TM rejects $x$, then when it halts,\n                   `TAPE[0] = 0`.\n                }}})\n\n      #md {{{\n             For decision TM, we shall write\n             the symbol in cell `TAPE[0]` after $M$ halts\n             as \n             $$ M(x) $$\n          }}}\n\n      #md {{{\n            *Definition* (The Accepting Problem)\n\n            \u003e Given a TM $\\mathbf{M}$ and the initial content\n            of its tape $x$, will $\\mathbf{M}$ accept $x$?\n\n            From this, we can define the _accepting function_.\n\n            `$$\\h(\\mathbf{M}, x) = \\left\\{\n              \\begin{array}{ll}\n                1 \u0026 \\mathrm{if}\\ \\mathbf{M}\\ \\mathrm{accepts\\ with\\ input}\\ x \\\\\n                0 \u0026 \\mathrm{otherwise}\n              \\end{array}\n              \\right.$$`\n\n             *Theorem*: (Undecidability)\n\n             \u003e There does not exists a TM that implements the function $\\h$.\n\n             As we can see, $\\h$ is perfectly definable within\n             the language of mathematics, and yet there is no\n             computation that can evaluate $\\h(\\circ, \\circ)$ for \n             arbitrary inputs.\n          }}}\n      (box #md {{{\n                Therefore, the answer to Hilbert\u0027s entscheidungsproblem is\n                _negative_.\n               }}}))\n\n(page (:h1 {{{The proof of undecidability of $\\h$}}})\n\n      #md {{{\n             Recall:\n             $$\\h(M, x) \\quad\\mathrm{if\\ and\\ only\\ if}\\quad M(x) = 1 \\tag{1}$$\n\n             Our prove by contradiction.  Let\u0027s assume that $\\h$ is\n             in fact computable.  \n             \n             - So, we can think of $\\h$ has a TM, or\n             equivalently, a program.\n\n             - Thus, we can construct another computable function:\n               $$ D(M) = \\mathrm{not}(\\h(M, \\mathrm{enc}(M))) \\tag{2}$$\n          }}}\n      (note #md {{{\n                   It may seem strange to have $\\h(M, \\mathrm{enc}(M))$.  More precisely,\n                   we first encode the description of $M$ to a binary string, and\n                   use the string as an input to $M$.\n                }}})\n\n      #md {{{\n            Now we can ask, $D(D) = ?$.\n            }}}\n\n      (rows 6 6\n            #md {{{\n                    Try $D(D) = 0$.\n\n                    `$$\\begin{eqnarray}\n                    \u0026\u0026 D(D) = 0 \\\\\n                    \u0026\\Rightarrow \u0026 \\h(D, D) = 1 \\tag {By 2}\\\\\n                    \u0026\\Rightarrow \u0026 D(D) = 1 \\tag{By 1} \\\\\n                    \u0026\\Rightarrow \u0026 \\mathrm{contradiction}.\n                    \\end{eqnarray}$$`\n                    }}}\n            #md {{{\n                  Try $D(D) = 1$.\n\n                  `$$\\begin{eqnarray}\n                  \u0026\u0026 D(D) = 1 \\\\\n                  \u0026\\Rightarrow \u0026 \\h(D, D) = 0 \\tag{By 2}\\\\\n                  \u0026\\Rightarrow \u0026 D(D) = 0 \\tag{By 1}\\\\\n                  \u0026\\Rightarrow \u0026 \\mathrm{contradiction}.\n                  \\end{eqnarray}$$`\n                }}}\n            (:h2 \"End of proof\"))\n); page\n\n(page (:h1 \"Summary\")\n\n      (:h2 \"TM \u0026 Programming\")\n\n      (row 6 6\n        #md {{{\n               - Turing Machine is a simple device that captures\n               _computation_ perfectly.\n\n               ***\n\n               \n               - There are certain problems that cannot be\n               solved by any Turing Machine, and therefore cannot\n               be solved by any computer.\n            }}}\n        #md {{{\n               - Universal TM and the simulation function capture\n               the abstraction of general purpose programmable computers and\n               compilers.\n\n               ***\n\n\n               - Turing Machine focuses on mutable data storage,\n               and the logical flow of statements that accesses\n               and modifies the data.\n            }}}\n        ))\n\n", "istop": false, "path": "1-computation/2-turing-machine"}, "1-computation/3-lambda-calculus": {"children": [], "content": "{:title \"\u03bb-Calculus\"\n :status :done\n :summary #md {{{\n                 Lambda Calculus was invented independently from\n                 the Turing Machine.  While it has a completely\n                 different formulation, it is equally powerful\n                 and expressive.  Furthermore, LC is a major\n                 influence of the entire family of function\n                 programming languages.\n              }}}\n}\n\n(page #md {{{\n            This lesson is based on the article,\n            \"_A Tutorial Introduction to the Lambda Calculus_\",\n            by Raul Rojas.  An online version can be\n            [downloaded from here](https://arxiv.org/pdf/1503.09060.pdf).\n          }}}\n); page\n\n(page (:h1 \"Expressions of LC\")\n      #md {{{\n            Lambda Calculus (LC) is a _language_, namely\n            a set of strings over some fixed alphabet.\n\n            The alphabet is:\n\n            - \u03bb: the lambda symbol\n            - $x, y, z$, ...: we assume infinitely many\n            names we can use as _variables.\n\n            Optionally, for readability, we also allow\n            the parentheses: `(`, `)` as part of the strings.\n          }}}\n      (:h2 \"The language of LC\")\n      #md {{{\n             We can express the language of LC as a grammar:\n          }}}\n      (row 6 6\n           (md {{{\n                    _expr_ := _name_ | _func_ | _apply_ \u003cbr\u003e\n                    _func_ := \u03bb _name_ . _expr_ \u003cbr\u003e\n                    _apply_ := (_expr_ _expr_) \u003cbr\u003e\n                 }}})\n           #md {{{\n                  - `expr`: is the value expression.  A value can be a variable name `name`,\n                  or a function declaration `func`, or the evaluation of a function `apply`.\n\n                  - `func`: is function declaration. The \u03bb syntax allows us to declare the\n                  _input_ of the function, and bind it to a variable `name`.  The body\n                  of the function is given as an arbitrary expression `expr`.\n\n                  - `apply`: describes evaluating a function given as `expr` with an input which\n                  is also an arbitrary expression `expr`.\n               }}})\n      #md {{{\n            Here some examples:\n\n            ```\n            x\n            (x y)\n            (\u03bb x. (x y))\n            ```\n\n            To build an intuitive understanding of these expressions, we need to keep in\n            mind that \n            \n            1. the variables represent data or _functions_,\n            2. functions can be passed around just like data,\n            3. all functions accept exactly _one_ input.\n          }}}\n); page\n\n(page (:h1 \"Free vs Bound Variable Occurrences\")\n      #md {{{\n            Let $e$ be an expression in LC.  A variable occurrence is the\n            variable name at a specific position not following \u03bb.\n\n            Consider: $e=$`(x \u03bb x. x)`.  There are two variable occurrences\n            of `x`.\n\n            The variable occurrences are either _free_ or _bound_ in the expression.\n          }}}\n      #md {{{\n            *Definition* (Free and bound var occurrences)\n\n            \u003e Let $e$ be an expression.  Let $\\mathrm{Var}(e)$ be all the variable\n            occurrences in $e$.  We define the _free occurrences_ $\\mathrm{Free}(e)$\n            and _bound occurrences_ $\\mathrm{Bound}(e)$ by induction\n            on the structure of $e$:\n            \u003e\n            \u003e - If $e = x$, then `$\\mathrm{Free}(e) = \\{x\\}$`.\n            \u003e - If $e = \u03bb x. e\u0027$, then `$\\mathrm{Free}(e) = \\mathrm{Free}(e\u0027)-\\{x\\}$`.\n            \u003e - If `$e = (e_1 e_2)$`, then \n            \u003e   `$\\mathrm{Free}(e) = \\mathrm{Free}(e_1) \\cup\\mathrm{Free}(e_2)$`.\n            \u003e\n            \u003e Finally, $\\mathrm{Bound}(e) = \\mathrm{Var}(e) - \\mathrm{Free}(e)$.\n          }}}\n      #md {{{\n            Consider the following expression (with the occurrences indexed):\n\n            $$ e = (x_1\\ \u03bbx.\u03bby.((x_2\\ y_1)\\ (z_1\\ \u03bbz.z_2))) $$\n\n            One can verify that $e\\in\\mathbf{LC}$.\n            }}}\n      #md {{{\n            Here is the reasoning about the free and bound occurrences.\n            }}}\n\n      #md {{{\n            - `$\\mathrm{Free}(y_1) = \\{y_1\\}$`\n            }}}\n\n\n      #md {{{\n            - `$\\mathrm{Free}(x_2) = \\{x_2\\}$`\n            }}}\n\n\n      #md {{{\n            - `$\\mathrm{Free}((x_2\\ y_1)) = \\{x_2\\}\\cup\\{y_1\\} = \\{x_2, y_1\\}$`\n            }}}\n\n\n      #md {{{\n            - `$\\mathrm{Free}(z_2) = \\{z_2\\}$`\n            }}}\n\n\n      #md {{{\n            - `$\\mathrm{Free}(\u03bbz.z_2) = \\{z_2\\} -\\{z\\} = \\emptyset$`\n\n              \u003e Recall that $z_2$ has the name $z$, but indexed by its position 2.\n            }}}\n\n\n      #md {{{\n            - `$\\mathrm{Free}(z_1\\ \u03bbz.z_2) = \\{z_1\\} \\cup \\emptyset = \\{z_1\\}$`\n            }}}\n\n\n      #md {{{\n            - `$\\mathrm{Free}((x_2\\ y_1)\\ (z_1\\ \u03bbz.z_2)) = \\{x_2, y_1\\} \\cup \\{z_1\\} = \\{x_2, y_1, z_1\\}$`\n            }}}\n\n\n      #md {{{\n            - `$\\mathrm{Free}(\u03bby.(x_2\\ y_1)\\ (z_1\\ \u03bbz.z_2)) = \\{x_2, z_1\\}$`\n            }}}\n\n\n      #md {{{\n            - `$\\mathrm{Free}(\u03bbx.\u03bby.(x_2\\ y_1)\\ (z_1\\ \u03bbz.z_2)) = \\{z_1\\}$`\n            }}}\n\n\n      #md {{{\n            - `$\\mathrm{Free}((x_1\\ \u03bbx.\u03bby.(x_2\\ y_1)\\ (z_1\\ \u03bbz.z_2))) = \\{x_1, z_1\\}$`\n\n              \u003e Thus, there are only two free occurrences in $e$, \n              the first occurrence of $x$, that is $x_1$, and\n              the first of $z$, that is $z_1$.\n          }}}\n); page\n\n(page (:h1 \"Variable Renaming\")\n      #md {{{\n            The expressions define functions by specifying the evaluation\n            of the _return_ value in terms of the input variable (and other\n            variables). \n\n            Computation is carried out through LC-expression transformations\n            with two transformation rules:\n\n            - Variable renaming\n            - Substitution\n            }}}\n      #md {{{\n            *Definition* (Substitution)\n\n            \u003e Let $e$ be a LC-expression, and $x_i\\in\\mathrm{Var}(e)$ an occurrence.\n            The new expression $e[x_i/e\u0027]$ is by replacing $x_i$ with $e\u0027$.\n            }}}\n\n      #md {{{\n            Consider an expression $e = \u03bbx.x$.  It describes a very simple\n            function: take the input and return it.  So, the exact variable name\n            for the input is not important.  We can define the _same_ function\n            as $e\\equiv \u03bbz.z$.\n            }}}\n\n      #md {{{\n            Now, let\u0027s look at another function definition:\n\n            $$ e = \u03bbx. (x y) $$\n\n            It describe a function that takes a function $x$\n            and it passes the variable $y$ as the input, and\n            returns the output of $x(y)$.\n            }}}\n\n      #md {{{\n            Suppose that we are to rename $x$ to another variable name:\n\n            $$ e\\equiv \u03bbz.(z y)$$\n            }}}\n      #md {{{\n            But we must be very careful.  Not all input variable renaming\n            is allowed.  Suppose we try $x\\mapsto y$.  But $y$ is already\n            appearing in the body:\n\n            $$ e\\not\\equiv \u03bby.(y y) $$\n\n            The substitution changes the meaning of the function.\n          }}}\n      (box #md {{{\n                  ## Substitution\n\n                  \u003e Consider an abstraction expression $\\lambda x.e$.\n                  If $z\\not\\in\\mathrm{Free}(e)$, then\n                  $$\\lambda x.e \\equiv \\lambda z.e[x/z]$$\n                  \u003e where $e[x/z]$ replaces _all_ occurrences of $x$\n                  with $z$.\n               }}})\n); page\n\n(page (:h1 \"Function Application\")\n      #md {{{\n            Finally, we have built up enough machinery to discuss\n            the computational step that powers \u03bb-Calculus.\n            }}}\n\n      #md {{{\n            We will examine the second expression transformation:\n            function application.  This transformation applies\n            to expression of the form `$(e_1\\ e_2)$`.\n\n            Consider $((\\lambda x.e_1)\\ e_2)$.  The intuitive\n            interpretation is that $e_2$ is the input\n            to the function whose action is defined by $e_1$,\n            and $x$ is the input.\n            }}}\n\n      #md {{{\n            We are tempted to perform the following transformation:\n\n            $$ e\\mapsto e_1[x/e_2] $$\n            }}}\n\n      #md {{{\n             It is a _good_ guess:\n\n             _Example_:\n\n             `$$\\begin{eqnarray}\n             e \u0026=\u0026 ((\\lambda x.x) y) \\\\\n             \u0026=\u0026 (x [x/y]) \\\\\n             \u0026=\u0026 y\n             \\end{eqnarray}$$`\n             }}}\n      #md {{{\n            But this won\u0027t be valid universally for all cases of $e_1$.\n            }}}\n\n      #md {{{\n            ## Invalid substitution due to bound occurrences\n\n            Consider $e = (\\lambda x.\\lambda y.(xy))y$.\n\n            Should we blindly substitute:\n\n            `$$\\begin{eqnarray}\n            e \u0026=\u0026 (\\lambda x.\\lambda y.(xy))y \\\\\n            \u0026\\to\u0026 (\\lambda y.(xy))[x/y]  \\\\\n            \u0026\\to\u0026 \\lambda y.(yy)\n            \\end{eqnarray}$$`\n\n            But $e\\not=\\lambda y. (yy)$, so the substitution was _not_ valid.\n            }}}\n      #md {{{\n            This substitution is _invalid_ because $y$ occurs in $e_1$ as a\n            bound occurrence.\n          }}}\n\n      (box #md {{{\n                ## Function Application\n\n                Consider $e = ((\\lambda x.e_1)\\ e_2)$.  We can perform the following\n                transformation:\n\n                $$e\\equiv e_1[x/e_2]$$\n\n                **if $\\mathrm{Var}(e_2)\\cap\\mathrm{Bound}(e_1) = \\emptyset$.**\n                }}})\n      (box #md {{{\n                ## Preprocessing for function application\n\n                If $\\mathrm{Var}(e_2)\\cap\\mathrm{Bound}(e_1) \\not= \\emptyset$, we\n                can use _variable renaming_ to rename the bound variables of\n                $e_1$ so that we can apply function application correctly.\n               }}})\n      (note #md {{{\n                   So, we can always use variable renaming to ensure _valid_\n                   function application.\n                   }}})\n); page\n\n(page (:h1 \"Computation\")\n      #md {{{\n             To perform computation,\n\n             1. Encode the problem instance into a LC-expression.\n             2. Perform all possible function applications and variable renaming\n\n             When function application can no longer be applied,\n             the expression is said to be in _normal form_ which is\n             the encoding of the solution.\n          }}}\n); page\n\n\n{:title \"Arithmetics\"}\n\n(page (:h1 \"Arithmetics in LC\")\n      #md {{{\n            This is a very amazing discussion:\n\n            1. We will show that _nothing_ more\n            is needed aside from the LC-expressions we have discussed\n            to perform integer arithmetics.\n\n            2. LC is Turing complete.\n          }}}\n); page\n\n(page (:h1 \"Encoding of Integers\")\n      #md {{{\n             - $0 = \\lambda s.(\\lambda z.z)$\n             - $1 = \\lambda s.\\lambda z.(s z)$\n             - $2 = \\lambda s.\\lambda z.(s (s z))$\n             - $3 = \\lambda s.\\lambda z.(s (s (s z)))$\n             - $\\vdots$\n          }}}\n      \n      (note #md {{{\n                  ## Intuition\n\n                  The encoding of integers is done using a function\n                  with two inputs.  A natural number $n$\n                  is a function $n(f, x)$ and it applies $f$\n                  to $x$ exactly $n$ times.\n\n                  Thus, $3(f,x) = f(f(f(x)))$.\n               }}})\n      ); page\n\n(page (:h1 \"Successor\")\n      #md {{{\n             Now that we have an encoding scheme for integers,\n             we can focus on the first problem:\n\n             *Successor*\n\n             \u003e INSTANCE: consider an input $n$.  What is\n             $n+1$?\n\n             *Theorem*:\n\n             \u003e Consider the function:\n             \u003e\n             \u003e $$ S = \\lambda w.\\lambda y.\\lambda x.(y ((w y) x)) $$\n             \u003e\n             \u003e The solution to SUCCESSOR is the normal form of\n             \u003e\n             \u003e $$ S n $$\n             \u003e\n             \u003e where $n$ is the LC-expression of integer $n$.\n          }}}\n      (--*--)\n      #md {{{\n            Let\u0027s try it out.\n\n            Consider $S1$:\n\n            ```\n            S1 = (\u03bbw.\u03bby.\u03bbx.(y ((w y) x))) (\u03bbs.\u03bbz.(s z))\n               = \u03bby.\u03bbx.(y ((w y) x))[w/(\u03bbs.\u03bbz.(s z))]\n               = \u03bby.\u03bbx.(y (((\u03bbs.\u03bbz.(s z)) y) x))\n               = \u03bby.\u03bbx.(y ((\u03bbz.(y z)) x))\n               = \u03bby.\u03bbx.(y (y x))\n               = 2\n            ```\n          }}}\n\n      (note #md {{{\n                   ## Intuition.\n\n                   If we see numbers as $n(f, x) = f\\dots f(n)$, then\n                   $$(Sn)(f, x) = f(n(f,x))$$\n                   \n                   When expressed as LC, it becomes\n                   $$ S = \\lambda w.\\lambda y.\\lambda x.(y ((w y) x)) $$\n                }}})\n      )\n\n(page (:h1 \"Addition\")\n      #md {{{\n            To build up addition, let\u0027s recap on the intuition behind\n            the encoding of integers and the successor function:\n\n            - An integer $m$ is actually a function with two inputs:\n              $\\lambda f.\\lambda x. \\dots$.  It applies the function $f$\n              repeatedly $m$ times to the input $x$:\n              $$ m f x = f(f(\\dots f(x))) $$\n            - The successor function $S$ is a function of one input:\n              $\\lambda x. \\dots$.  It increments the input integer by one:\n              $$ Sx = x+1 $$\n\n            This allows us to describe addition $m + n$ at an intuitive level\n            in terms of $m$ and $S$:\n\n            \u003e $m+n$ can be written as $n+1+1+1+\\dots+1$, so it\u0027s the repeated\n            ($m$ times) application of $S$ to $n$.  Namely:\n            $$ m + n = mSn $$\n          }}}\n      (box #md {{{\n                  Let $m$ and $n$ be two integer encoding in LC.\n                  Then the encoding of $m+n$ is given by:\n\n                  $$((m S) n)$$\n               }}}))\n\n(page (:h1 \"Multiplication\")\n      #md {{{\n            Consider $m\\times n$.  It can be written as:\n\n            $$0 + n + n + \\dots + n$$\n\n            So, we just need to build a function $f(x) = n + x$ in LC\n            and use $m$ to apply $f$ repeatedly to 0.\n\n            `$$\\begin{eqnarray}\n            f \u0026=\u0026 \\lambda x. (n + x) \\\\\n              \u0026=\u0026 \\lambda x. n S x\n            \\end{eqnarray}\n            $$`\n          }}}\n      (box #md {{{\n                Let $m$ and $n$ be integers, then\n\n                $$m\\times n = m (\\lambda x. n S x) \\mathbf{0}$$\n               }}}))\n\n(page (:h1 \"Boolean Logic\")\n      #md {{{\n             Without proof, we will outline the encoding\n             of boolean algebra in LC:\n\n             - True: $\\mathbf{T} = \\lambda x.\\lambda y.x$\n             - False: $\\mathbf{F} = \\lambda x.\\lambda y.y$\n\n             Logical operators can be encoded as:\n\n             - AND: $\\mathrm{and} = \\lambda x.\\lambda y.(xy\\mathbf{F})$\n             - OR: $\\mathrm{or} = \\lambda x.\\lambda y.(x\\mathbf{T}y)$\n             - NOT: $\\mathrm{not} = \\lambda x.(x \\mathbf{F}\\mathbf{T})$\n          }}}\n      (:h2 \"And a lot more...\")\n      #md {{{\n            LC is equally effective in encoding the following computational essentials:\n\n            1. Comparison operators between integers\n            2. Subtraction and division\n            3. If-else\n\n            In the next section, we see the most powerful of all\n            integer based operator -- the fixed-point iterator, known\n            as the _Y-combinator_.\n          }}}\n); page\n\n(page (:h1 \"Y-combinator\")\n      #md {{{\n            Now, we proceed to reach for Turing completeness.\n            We have already gathered:\n\n            1. Integer and arithmetics\n            2. Boolean logic\n\n            The only thing missing is iteration.  This is where\n            _Y-combinator_ comes in.\n\n            $$ Y = (\\lambda y.(\\lambda x.y(xx))(\\lambda x.y(xx))) $$\n\n            *Theorem* (Fixed-point of Y-combinator)\n\n            \u003e For any expression $e$, we have:\n            \u003e\n            \u003e $$ Ye = e(Ye) $$\n\n            Therefore, $Ye$ is an input that is a fixed point\n            of the computation $e$. Namely,\n            $Ye$ is the solution of $x = e(x)$.\n          }}}\n(box #md {{{\n            ## Turing completeness of \u03bb-Calculus\n\n            \u003e \u03bb-Calculus is Turing complete.\n         }}})\n); page\n\n", "istop": false, "path": "1-computation/3-lambda-calculus"}, "2-Clojure": {"children": ["2-Clojure/0-setup", "2-Clojure/1-data", "2-Clojure/1-scopes", "2-Clojure/2-general-programming", "2-Clojure/3-lazy", "2-Clojure/4-data-transformation", "2-Clojure/4-standard-library", "2-Clojure/5-clojure-projects", "2-Clojure/6-oop", "2-Clojure/7-macros", "2-Clojure/8-tools"], "content": "{:title \"Clojure: the programming language\"\n :summary #md {{{\n                We are going examine Clojure from the perspective\n                of functional programming using Lisp.\n                Using Clojure syntax, we will explore various\n                programming patterns in functional programming.\n              }}}}\n\n(page #md {{{\n            Recommended reading:\n\n            \u003e _Programming Clojure_ (2nd Edition)\n            \u003e\n            \u003e Stuart Halloway and Aaron Bedra\n          }}})\n\n", "istop": false, "path": "2-Clojure"}, "2-Clojure/0-setup": {"children": [], "content": "{:title \"Setting up Clojure\"\n :status :done\n :author #md {{{\n                - Ken Pu\n                - Faculty of Science, UOIT\n                - 2017\n             }}}}\n\n(page (:h1 \"References\")\n      (row 6 6\n        #md {{{\n               _Textbook_\n\n               \u003e There are _many_ introductory\n               Clojure textbooks.  All of them\n               are quite adequate for this course.\n               \u003e\n               \u003e \"_Programming Clojure_\" is one\n               of my favourites.\n            }}}\n        (image \"programming-clojure.jpg\"))\n      (row 6 6\n           #md {{{\n                  _Online book_\n\n                  \u003e \"_Clojure For The Brave And Bold_\"\n                  \u003e is an online book, freely available\n                  \u003e for online reading.\n                  \u003e\n                  \u003e It is really entertainingly written.\n               }}}\n           (image \"brave-n-bold.png\"))\n      (row 6 6\n           #md {{{\n                  _Documentation \u0026 References_\n\n                  \u003e https://clojuredocs.org/\n                  \u003e is the definitive documentation\n                  \u003e for Clojure functions.  Because\n                  \u003e it\u0027s community driven, almost every\n                  \u003e Clojure API comes with some\n                  \u003e really great sample code.\n               }}}\n           (image \"clojuredocs.png\"))\n      ); page\n\n(page (:h1 \"Software Setup\")\n\n      (:h2 \"Java SDK\")\n      (row 6 6\n           #md {{{\n              Clojure is a language built on top\n              of the Java Virtual Machine (JVM).\n\n              So, we need Java.\n              }}}\n           (:div.jumbotron.well\n             #md {{{\n                    Java SDK 8.0 or higher\n                 }}})\n           )\n\n      (:h2 \"Downloading Clojure\")\n      (row 6 6\n           #md {{{\n                  https://clojure.org distributes the latest Clojure compilation tools.\n\n                  For the purpose of this course, it\u0027s really easy to install Clojure.\n              }}}\n           (:div.jumbotron.well\n           #md {{{\n                  # Install `clojure-1.8.0.jar` \n                  \n                  - It can be obtained from the zip image here:\n                  \u003ca class=\"btn btn-info\" href=\"https://repo1.maven.org/maven2/org/clojure/clojure/1.8.0/clojure-1.8.0.zip\"\u003eclojure-1.8.0.zip\u003c/a\u003e\n\n                  - Save the `clojure-1.8.0.jar` in a directory.  I recommend to put it in `\\$HOME/bin/`.\n              }}}))\n\n      (:h2 \"Trying it out\")\n      (row 6 6\n           #md {{{\n                  Let\u0027s try things out:\n\n                  - We are running the Clojure interpreter as a\n                  _read-evaluate-print-loop_ (REPL).\n               }}}\n           (code {:lang :bash\n                  :no-num true}\n                 {{{\n                    $ java -jar ~/bin/clojure-1.8.jar\n                    Clojure 1.8.0\n                    user=\u003e (def x \"Hello, \")\n                    #\u0027user/x\n                    user=\u003e (println x \"CSCI 3050U\")\n                    Hello,  CSCI 3050U\n                    nil\n                    user=\u003e\n                 }}}))\n      (:h2 \"Not a good IDE\")\n      #md {{{\n             The bare Clojure setup is far from ideal.\n\n             - The REPL does not support keybindings (e.g. command recall)\n          }}}\n      ); page\n\n(page (:h1 \"Development Environment\")\n      (row 4 8\n           #md {{{\n                  ## Better REPL\n               }}}\n           #md {{{\n                  `rlwrap` is a unix-based console program that\n                  wraps around _any_ interactive console programs\n                  so they have proper keybindings.\n               }}})\n      (:h2 \"Installing rlwrap\")\n      (row 4 8\n           #md {{{\n                  ## For Linux\n               }}}\n           #md {{{\n                  ```\n                  sudo apt-get install rlwrap\n                  ```\n               }}})\n      (:h2 \"Better interactive Clojure\")\n      (row 6 6\n           #md {{{\n                  Now, we can have a much better experience with Clojure\n                  using rlwrap.\n               }}}\n           (code :bash\n                 {{{\n                    $ rlwrap java -cp $HOME/bin/clojure-1.8.0.jar:$PWD clojure.main\n                    Clojure 1.8.0\n                    user=\u003e\n                 }}})\n           )\n\n      ); page\n", "istop": false, "path": "2-Clojure/0-setup"}, "2-Clojure/1-data": {"children": [], "content": "{:title \"Data \u0026 Expressions\"\n :status :done\n :summary #md {{{\n                 We will cover the basic syntax of\n                 Clojure, and use it to describe\n                 data, functions and more. We will\n                 introduce many fundamental concepts\n                 (binding and scoping) and syntactic\n                 forms (s-expressions and symbol binding).\n              }}}}\n(page (row 4 8\n      #md {{{\n            Clojure is a general purpose programming language:\n          }}}\n      (:div\n      #md {{{\n            - It belongs to the family of programming languages\n            derived from _Lisp_.  Because of this, Clojure syntax\n            is simple and follows very closely to expression of \u03bb-Calculus,\n            and promotes the functional programming paradigm.\n          }}}\n      #md {{{\n            - It compiles into Java bytecode, so Clojure code\n            runs top of the JVM.  Clojure has excellent integration\n            with Java, so we can integrate existing Java libraries\n            with ease.\n          }}}\n      #md {{{\n            - Very recently, Clojure has gained massive popularity through\n            Clojurescript which compiles directly into Javascript.  So\n            Clojure is becoming a choice of Web application programming.\n          }}})))\n\n\n(page (:h1 \"Values, lists and functions\")\n      #md {{{\n            We will explore the syntax and programming constructs of Clojure.\n            Note, as a dialect of Lisp, the syntax an immediate derivative\n            of \u03bb-Calculus.\n          }}}\n      (:h2 \"Simple values\")\n      #md {{{\n            Simple values in Clojure are specified just like any\n            other language.\n\n            - `42`: an integer\n            - `42.0`: a floating point\n            - `42M`: a\n            [BigDecimal](https://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html)\n            - `\"hello world\"`: a string\n            - `\\h`: a character\n          }}}\n      #md {{{\n            Clojure comes with two more atomic types:\n\n            - `:last-name` is a [_keyword_](https://clojure.org/reference/data_structures#Keywords).\n            Keywords are just verbatim values that we can use for _convenience_.\n            The _magical_ property with Clojure keywords is that equality takes $\\mathcal{O}(1)$\n            (Integer equality is $\\mathcal{O}(\\log n)$, and string equality is $\\mathcal{O}(n)$.)\n\n            - `\u0027last-name` is a symbol.  Symbols are also used in other programming languages,\n            but only in Lisp can you create them at runtime.\n          }}}\n    (:h2 \"Lists\")\n    #md {{{\n           Lisp (LISt Processing) processes lists.  A list is either data\n           or function evaluation or function abstraction.\n        }}}\n    (note #md {{{\n                 This should remind us the grammar of\n                 \u03bb-Calculus.\n              }}})\n    #md {{{\n          The default interpretation of list is function\n          invocation:\n\n          `(+ 1 2 3 4 5)`\n\n          To indicate that a list is just a (data) list, use\n          the single quote symbol.\n\n          `\u0027(\"hello\" \"world\" 123)`\n        }}}\n    (note #md {{{\n                Another way is to use the `quote` form:\n\n                ```\n                (quote (\"hello\" \"world\" 123))\n                ```\n              }}})\n    #md {{{\n          List as a function abstraction follows closely to the\n          \u03bb-Calculus.  Recall \u03bb notation is:\n\n          ```\n          (\u03bb x. \u003cexpr\u003e)\n          ```\n\n          Clojure uses the following:\n\n          ```clojure\n          (fn [x] \u003cexpr\u003e)\n          ```\n\n          To test your understanding, make sure you understand \n          the following:\n\n          ```clojure\n          ((fn [x y] (+ x x y y) 1 (+ 1 1)))\n          ```\n\n          What\u0027s the answer?\n        }}}\n\n    (:h2 \"Data structures\")\n    #md {{{\n          Clojure is a _practical_ programming language aimed to solve industrial\n          scale problems with maximal productivity.  Beyond basic lists, Clojure\n          provides support for _vectors_, _hash-maps_ and _sets_ as part of the language.\n\n          Here is a vector:\n          }}}\n\n    (row 6 6\n         #md {{{\n          ```clojure\n          [\"hello\" \"world\" [1 2 3]]\n          ```\n          }}}\n         #md {{{\n              - A vector is enclosed by `[ ... ]`.\n              - Whitespace is the separator of the elements.  \n              (Commas are allowed as well, but not commonly used).\n              - Vectors are heterogeneous - they can contain _any_ thing.\n             }}})\n    #md {{{\n          A vector is similar to a list, but with some important differences:\n\n          - It provides direct access to any of the elements in $\\mathcal{O}(1)$, so\n          think of them as dynamic arrays.\n\n          - It\u0027s *always* data, so `[+ 1 2]` evaluates to a vector of three elements,\n          not 3.\n\n          Vector elements can be obtained with the `get` function.\n\n          ```clojure\n          (get [\"hello\" \"world\"] 0)\n          ; =\u003e \"hello\"\n          ```\n\n          Here is a hash-map:\n        }}}\n\n    (row (code :clojure\n               :no-nu\n               :sm\n               {{{\n                 {\"first-name\"   \"Richard\"\n                  \"last-name\"    \"Feynman\"\n                  :profession    \"Physicist\"\n                  :interests     [\"Physics\" \"Drumming\"]}\n               }}})\n        #md {{{\n               - A hash-map is enclosed by `{ ... }`.\n               - Whitespace is used to separte both keys and values.\n               This means that there must be an _even_ number\n               of entries in `{...}`.\n               - Anything can be a key.  This is a magical property of\n               languages where data cannot be mutated.\n            }}})\n    #md {{{\n         Values of a hash-map can be retrieved by the `get` function.\n         Instead of indexes, we need to provide the key.\n\n         ```clojure\n         (get {\"first-name\"   \"Richard\"\n               \"last-name\"    \"Feynman\"\n               :profession    \"Physicist\"\n               :interests     [\"Physics\" \"Drumming\"]} \"first-name\")\n         ; =\u003e \"Richard\"\n\n         (get {\"first-name\"   \"Richard\"\n               \"last-name\"    \"Feynman\"\n               :profession    \"Physicist\"\n               :interests     [\"Physics\" \"Drumming\"]} :profession)\n         ; =\u003e \"Physicist\"\n         ```\n        }}}\n    #md {{{\n         *Note*:\n\n         \u003e - `(get ... \"first-name\")` needs to perform string comparison \n         for the key lookup.\n         - `(get ... :profession)` uses keyword comparison during the lookup.\n\n        }}}\n    #md {{{\n         Finally we have _sets_. Sets are like lists, except that there cannot\n         be duplicates and that order does not matter.\n\n         ```clojure\n         (println #{:a :b :c})\n         ; =\u003e #{:c :b :a}\n\n         (let [my-set #{:a :b :c}]\n           (if (my-set :a)\n             (println \"My set contains :a\"))\n           (if (my-set :x)\n             (println \"My set contains :a\")))\n         ```\n        }}}\n\n\n    (:h2 \"Summary\")\n    #md {{{\n          We have seen several ways of specifying _values_.  It\u0027s quite\n          important and extremely liberating to understand that the\n          notion of a value can be:\n\n          - A simple atomic piece of data such as number or character,\n          - a nested data structure such as list, vector, hash-map, or\n          - a function.\n        }}}\n); page\n\n", "istop": false, "path": "2-Clojure/1-data"}, "2-Clojure/1-scopes": {"children": [], "content": "{:title \"Binding, Scopes and Scoping Rules\"\n :status :done\n :summary #md {{{\n                 We will\n                 introduce many fundamental concepts\n                 (binding and scoping) and syntactic\n                 forms (s-expressions and symbol binding).\n              }}}}\n\n\n(page (:h1 \"Symbols, bindings and scopes\")\n      #md {{{\n            So far, we have shown how to specify different types of\n            data (and sprinkle of functions), but like any programming\n            languages, we need a way to assign them to _symbols_.\n          }}}\n      (box #md {{{\n                *Symbol binding*\n\n                \u003e A **binding** is a mapping from a symbol to a value.\n                \u003e We write a binding as:\n                \u003e\n                \u003e $$ s \\mapsto v $$\n                \u003e\n                \u003e to denote that symbol $s$ is bound to the value $v$.\n              }}}\n           #md {{{\n                *Scope*\n\n                \u003e A **scope** $\\sigma$ is a mapping of a group of symbols to values.\n                The set of symbols that are mapped to some value is called\n                the domain of the scope, $\\mathrm{dom}(\\sigma)$.\n                A bound symbol is a symbol $s\\in\\mathrm{dom}(\\sigma)$.  Namely,\n                $\\sigma(s)$ is defined.  Otherwise $s$ is _free_ with respect to\n                the scope $\\sigma$.\n               }}})\n); page\n\n(page (:h1 \"Closure\")\n      #md {{{\n            Whenever we specify a value (data / abstraction / application),\n            we do so by constructing an _expression_.  The expression is\n            specified in some scope $\\sigma$, and therefore the expression\n            can make use of the symbols in $\\mathrm{dom}(\\sigma)$.\n\n        }}}\n    #md {{{\n            An expression can also create a _new_ scope $\\sigma\u0027$, and the new\n            scope $\\sigma\u0027$ will define bindings on _new_ symbols \n            or re-define symbols in $\\sigma$.  Since $\\sigma\u0027$ is defined in the scope\n            of $\\sigma$, we call $\\sigma\u0027$ a sub-scope of $\\sigma$, written $\\sigma\u0027 \u003c \\sigma$.\n\n        }}}\n    #md {{{\n            *Definition* (Closure)\n\n            \u003e Let `$\\sigma_n \u003c \\sigma_{n-1} \u003c \\dots \u003c \\sigma_0$`.  Namely, $\\sigma_0$ is the global\n            scope, and $\\sigma_i$ are the successive sub-scopes.  The closure of $\\left\u003c\\sigma_i\\right\u003e$,\n            written $\\overline{\\sigma_i}$ is a scope defined by\n            the following rules:\n            \u003e\n            \u003e - `$\\mathrm{dom}(\\overline{\\sigma_i}) = \\bigcup_i\\mathrm{dom}(\\sigma_i)$`\n            \u003e\n            \u003e\n            \u003e - Given a symbol $s\\in\\mathrm{dom}(\\overline{\\sigma_i})$, its binding\n            in the closure is the $\\sigma_i$ such that $s\\in\\mathrm{dom}(\\sigma_i)$\n            and $i$ is the largest (most specific scope).\n\n        }}}\n    #md {{{\n            Why is closure important in Clojure?\n\n            \u003e Lisp makes the creation of sub-scopes _exceedingly_ explicit (unlike Java / C / Python).\n            \u003e So we have lots of instances of nested scopes $\\left\u003c\\sigma_i\\right\u003e$.\n            \u003e Clojure (and other Lisps) resolve symbol binding according to the closure\n            \u003e of the scopes. \n          }}}\n\n      (:h2 \"Closure in action\")\n\n      #md {{{\n            There is a global scope, which is also called the _top-level_ scope.\n            _(Actually, there can be more than one top-level when we discuss namespaces.)_\n            The _def_ expressions _modifies_ the top-level scope with new symbol bindings.\n          }}}\n\n      (row 6 6\n          #md {{{\n            ```clojure\n            (def \u003csymbol\u003e \u003cvalue\u003e)\n            ```\n          }}}\n          #md {{{\n            The _value_ is evaluated immediately, and the result of the evaluation is\n            bound to the symbol at the top-level scope.\n          }}})\n\n      #md {{{\n            ```clojure\n            (def \u03c0 3.1415)\n            (def r 10)\n\n            (* \u03c0 r r)\n            ;=\u003e 314.15000\n            ```\n\n            As we all (should) know, modifying the top-level scope is never encouraged.\n            Clojure _strongly_ discourages careless pollution of the top-level scope.\n            The _let_ form creates a _new scope_ with new symbol bindings.}}}\n      (row 6 6\n           #md {{{\n            ```clojure\n            (let [\u003csymbol\u003e \u003cvalue\u003e\n                  \u003csymbol\u003e \u003cvalue\u003e\n                  ...]\n              \u003cexpression\u003e)\n            ```\n               }}}\n           #md {{{\n                  - The symbol/value pairs are _new bindings_.  They are\n                  given as a _vector_ after the `let`.\n                  - Each value is evaluated immediately.\n                  - Each value can make use of the symbols in the previous binding\n                  in the same `let` form.\n               }}})\n      #md {{{\n            Let\u0027s try it out.\n\n            ```clojure\n            ;; Computing the area of two circles.\n            (let [\u03c0    3.1415\n                  r    10\n                  area (* \u03c0 r r)]\n              (* 2 area))\n            ;=\u003e 628.30000\n            ```\n\n            Let\u0027s just remind ourselves the flexibility of Lisp syntax --\n            whitespaces and commas are all ignored.  So the same code above can be\n            rewritten as follows:}}}\n      (row 8 4\n           #md {{{\n            ```clojure\n            (let [\u03c0 3.1415 r 10 area (* \u03c0 r r)] (* 2 area))\n            ```\n          }}}\n          #md {{{\n                 But this is quite terribly unreadable.\n              }}})\n      (row 8 4\n           (code :clojure :no-nu\n                 {{{\n                  (let [\u03c0 3.1415, r 10,\n                        area (* \u03c0 r r)] (* 2 area))\n                 }}})\n           #md {{{\n                  We can use commas to improve readability.\n               }}})\n      #md {{{\n            We will see many more ways of creating sub-scopes.\n            The important thing to keep in mind is that\n            symbols are resolved to values according to the\n            closure of the chain of nesting of scopes.\n          }}}\n); page\n\n\n(page (:h1 \"Binding resolution policies\")\n      (html {{{\n               \u003ciframe src=\"https://docs.google.com/presentation/d/e/2PACX-1vRgZKQ_iS1Kr8vMuvY1yFbrkgDv3ai-bhT89Y6lkWKIEx2LLBSFxFcseN39XQ3RLclYLaGv-eeItdIJ/embed?start=false\u0026loop=false\u0026delayms=3000\" frameborder=\"0\" width=\"960\" height=\"569\" allowfullscreen=\"true\" mozallowfullscreen=\"true\" webkitallowfullscreen=\"true\"\u003e\u003c/iframe\u003e\n               }}})\n      )\n\n\n(page (:h1 \"Lexical scoping\")\n      #md {{{\n            Lexical scoping is the rule\n            of how the parent/child scope relation is determined.\n\n            The word \"_lexical_\" refers to the atomic building block\n            of syntax known as _lexicon_.  The rule of thumb\n            of lexical scoping is that whenever a new scope is created,\n            the location of the program that creates the new scope\n            determines the parent scope.\n\n            Let\u0027s look at a specific example.}}}\n      (row 6 6\n        (code :clojure\n              {{{\n              (def make-larger (let [x 10]\n                                 (fn [y] (+ y x))))\n\n              (let [x 1000]\n                (make-larger 1))\n              }}})\n        (:div\n          #md {{{\n                Let\u0027s first examine line 1-2.\n                A function is defined `(fn [y] (+ y x))`.  Note that\n                the function relies on the symbol `x` from some\n                parent scope.  At the declaration of the function\n                (line 2.), the parent scope has `$x\\mapsto 10$`.\n              }}}\n          #md {{{\n            However, at line 5., the evaluation of `make-larger`\n            function happens inside a scope where\n            $x\\mapsto 1000$.\n            }}}\n          #md {{{\n            Should 1000 be used as the value for `x`?\n\n            \u003e No, because Clojure uses _lexical scoping_ which\n            states that the parent scope of `make-larger` \n            is the scope where it is declared (line 2.).\n          }}}))\n\n      (row 4 8\n        #md {{{\n              To test your understanding of the scoping rule\n              of Clojure, can you tell the value computed?\n            }}}\n        (:div\n          (code :clojure :no-nu :sm\n                {{{\n                (def make-make-larger \n                  (fn [amount] (fn [value] (+ value amount))))\n\n                (let [amount 10\n                      make-larger (make-make-larger 100)]\n                  (make-larger 1))\n                ;=\u003e 11 or 101?\n                }}})\n          #md {{{\n                 What is the output?\n              }}}\n          (toggle #md {{{\n                         The answer is 101.\n\n                         - `((make-make-larger 100) 1)`\n                         - `((fn [value] (+ value 100)) 1)`\n                         - `(+ 1 100)`\n                         - `101`\n                      }}})))\n); page\n\n(page (:h1 \"Dynamic scoping\")\n      #md {{{\n            Clojure supports dynamic scoping, but\n            it\u0027s actually discouraged because it can created subtle bugs\n            and hard to understand code.\n            }}}\n      (rows 4 8\n            (:h2 \"Dynamic symbols\")\n            (:div #md {{{\n                         By default, all free variables in a function\n                         are resolved by lexical scoping rule.\n                         }}}\n                  #md {{{\n                         To enable dynamic scoping rule for a _specific_ symbol, the symbol must be\n                         declared as _dynamic_ at the _top-level_.\n                         }}}\n                  (code :clojure\n                        {{{\n                           (def ^:dynamic bonus 0)\n                           }}})\n                  )\n\n            (:h2 \"Function declaration\")\n            (:div #md {{{\n                         The function is to be declared as a top-level function.\n                         }}}\n                  (code :clojure\n                        {{{\n                           (defn get-salary [base]\n                             (+ base bonus))\n                           }}}))\n\n            (:h2 \"Dynamic binding\")\n            (:div #md {{{\n                         We can _modify_ the binding of dynamic symbols\n                         at the scope in which the function invocation occurs.\n                         }}}\n                  (code :clojure\n                        {{{\n                           (binding [bonus 100]\n                             (println \"My salary is\" (get-salary 1000)))\n                           }}}))\n            )\n\n      (:h2 \"Putting it together\")\n      (rows 6 6\n            (code :clojure\n                  :tiny\n                  {{{\n                     (def ^:dynamic tax-rate 0)\n\n                     (defn calc-net-income [total-income]\n                       (let [tax (* tax-rate total-income)]\n                         (- total-income tax-rate)))\n\n                     (defn tax-report [total-income]\n                       (do (printf \"Total income $.2f\\n\" total-income)\n                           (printf \"         Tax $.2f\\n\" (* tax-rate total-income))\n                           (printf \"  Net income $.2f\\n\" (calc-net-income total-income))))\n                     }}})\n\n            (:div #md {{{\n                         Elsewhere...\n\n                         ```\n                         ;; This is Ontario\n                         (binding [tax-rate 0.13]\n                           (tax-report 1000000))\n                         ```\n                         }}}\n                  #md {{{\n                         And somewhere else...\n\n                         ```\n                         ;; This is Alberta\n                         (binding [tax-rate 0.08]\n                           (tax-report 1000000))\n                         ```\n                         }}})\n            )\n      )\n", "istop": false, "path": "2-Clojure/1-scopes"}, "2-Clojure/2-general-programming": {"children": [], "content": "{:title \"General Purpose Programming\"\n :status :done\n :summary #md {{{\n                 We will be looking at programming\n                 constructs that make Clojure a\n                 general purpose programming language.\n              }}}}\n\n(page (:h1 \"More expressions\")\n      #md {{{\n            A profound distinction between Lisp and some\n            procedural languages (C/Java/Python) is that\n            _everything_ is an expression that evaluates\n            to data.\n          }}}\n      (:h2 \"Branching and boolean\")\n      (row 6 6\n           (code :clojure\n                 :no-nu\n                 {{{\n                  (if test-expr\n                    true-expr\n                    false-expr)\n                 }}})\n           #md {{{\n                The `test-expr` is an expression.\n                If it\u0027s evaluated to `false` or `nil`, then\n                the whole `(if ...)` evaluates to the\n                evaluation of `false-expr`.  Otherwise, it\n                evaluates to the `true-expr`.\n               }}})\n      #md {{{\n            Boolean expressions can be combined\n            with `and`, `or`, `not`.\n\n            ```clojure\n            (= 1 2)\n            ;=\u003e false\n\n            (= 1 (dec 2))\n            ;=\u003e true\n\n            (and (= 1 2) (= 1 (dec 2)))\n            ;=\u003e false\n\n            (let [n 1\n                  n\u0027 2]\n              (and (= n n\u0027) (= n (dec n\u0027))))\n            ;=\u003e same as before, false.\n            ```\n\n            Combining with other facilities, we can do:\n\n            ```clojure\n            (def physicist?\n              (fn [person]\n                (if (= \"physicist\" (get person :profession))\n                  true\n                  false)))\n            ```\n\n            Of course, this can be simplified to\n\n            ```clojure\n            (def physicist?\n              (fn [person] (= \"physicist\" (get person :profession))))\n            ```\n          }}}\n      (:h2 \"Conditional tests\")\n      (row 6 6\n           (code :clojure :no-nu\n                 {{{\n                  (cond\n                    test-expr value\n                    test-expr value\n                    :else value)\n                 }}})\n           #md {{{\n                  This is the generalized `switch` statement\n                  in Clojure.  In the form `(cond ...)`, \n                  we have _pairs_ of test expression and value\n                  expression, followed by a _default_ pair\n                  with `:else` and the default value expression.\n\n                  The test expressions are evaluated one after another\n                  until one of them evaluates to _true_.  Then the\n                  corresponding value expression is the result\n                  of the entire `(cond ...)` expression.\n               }}})\n      (note #md {{{\n                   It\u0027s worth noting that `cond` does not have\n                   any requirement on having the default pair.\n                   It\u0027s only a convention to use a keyword\n                   (such as `:else` or `:default`) \n                   as the test expression because keywords\n                   are always _true_.\n                }}})\n      #md {{{\n            Here is an expression that evaluates\n            a hash-map of personal information to\n            their base salary.\n\n            ```clojure\n            (def base-salary-1\n              (fn [person]\n                (let [profession (get person :profession)]\n                  (cond\n                    (= profession \"physicist\")  70,000\n                    (= profession \"accountant\") 78,000\n                    (= profession \"teacher\")    67,000\n                    :else                       40,000))))\n            ```\n\n            Note that if we are to implement this using \n            the `(if ...)` form, we would have:\n\n            ```clojure\n            (def base-salary-2\n              (fn [person]\n                (let [profession (get person :profession)]\n                  (if (= profession \"physicist\")\n                    70,000\n                    (if (= profession \"accountant\")\n                      78,000\n                      (if (= profession \"teacher\")\n                        67,000\n                        40,000))))))\n            ```\n            While `base-salary-2` is functionally correct,\n            it\u0027s considered _bad_ Clojure code.\n\n            Clojure provides a number of extensions to `cond`.\n            One is the `(case ...)` form, in which it only\n            handles equality tests for the test expressions. \n            Here is now the base salaries are computed using case.\n\n            ```clojure\n            (def base-salary-3\n              (fn [person]\n                (case (get person :profession)\n                  \"physicist\"  70,000\n                  \"accountant\" 78,000\n                  \"teacher\"    67,000\n                  40,000)))\n            ```\n\n            It\u0027s quite visibly so that `base-salary-3`\n            is the most well structured implementation.\n          }}}\n); page\n\n(page (:h1 \"Functions\")\n      #md {{{\n            We have already seen encountered\n            some built-in functions, such\n            as `(+ ...)` and `(get ...)`.\n            We have also seen the `(fn [...] ...)`\n            form that evaluates to a function.  In this section we will explore\n            more function related programming constructs offered by Clojure.\n\n            ## The _defn_ form\n\n            It\u0027s quite common to define functions in the top-level scope. Clojure\n            provides an alternative to define symbols that are bound to a fn-value\n            at the top-level.\n\n            The follow two forms are equivalent.\n            }}}\n      (row 6 6\n           #md {{{\n              ```clojure\n              (defn \u003cfun-name\u003e\n                [args ...]\n                body)\n              ``` \n            }}}\n           #md {{{\n                  ```clojure\n                  (def \u003cfun-name\u003e\n                    (fn [args ...]\n                      body))\n                  ```\n               }}})\n      #md {{{\n             The _defn_ form is especially convenient when the body of the function\n             needs to refer to the function symbol itself, for example when we\n             implement a recursive function.\n\n             ```clojure\n             (defn factorial\n               [n]\n               (if (= 0 n)\n                 1\n                 (* n (factorial (- n 1)))))\n             ```\n          }}}\n\n      (note #md {{{\n                   Let\u0027s assess the efficiency of this recursive implementation of `factorial`.\n\n                   - What is the time requirement of `factorial` in terms of the input `n`?\n\n                   - What is the space requirement of `factorial`?\n\n                   Compare these answers with a procedural implementation.\n                }}})\n\n      #md {{{ \n             ## Higher order functions\n\n             Let\u0027s reiterate a tremendously crucial aspect of Lisp (and functional programming in\n             general), functions are also data.\n\n             Traditionally, we think of functions as transformations of input data to output data.\n             Since functions can be data, we can pass functions as input to another function, and we\n             can expect a function to return another function as its output.\n\n             Let\u0027s look at implementing _function composition_.\n\n             \u003e The composition of two functions $f$ and $g$ is defined as\n             \u003e $\\mathrm{compose}(f, g)(x) = g(f(x))$.\n\n             This can be implemented in Lisp very straight fowardly as a higher order function:\n\n             ```clojure\n             (defn compose [f g] (fn [x] (g (f x))))\n             ```\n\n             which is probably better written as follows for readability:\n\n             ```clojure\n             (defn compose\n               [f g]\n               (fn [x]\n                 (g (f x))))\n             ```\n             }}}\n      (note #md {{{\n                   Can you predict the value of the following expression?\n\n                   ```clojure\n                   ((compose inc dec) 1)\n                   ; =\u003e ???\n                   ```}}})\n      #md {{{\n             Suppose we want to be able to apply a function multiple times:\n\n             $$ y = (2(2(2x + 3) + 3) + 3) $$\n\n             This can be seen as:\n\n             - $f(x) = 2x + 3$\n             - $y = f(f(f(x)))$\n\n             Let\u0027s implement this using a higher order function.\n\n             ```clojure\n             (defn f [x] (+ (* 2 x) 3))\n             (defn repeat [f n]\n               (if (\u003c n 1)\n                 f\n                 (compose (repeat f (dec n)) f)))\n             ```\n\n             The function `repeat` returns a function that acts on\n             the input by repeatedly applying the input function, `f`, `n`\n             times.\n\n             Now, we can compute $y$ as follows:\n\n             ```clojure\n             (let [x ...]\n               ((repeat f 3) x))\n             ```\n\n             Let\u0027s try to evaluate another expression:\n\n             $$ y = 3.14/(3.14/(3.14/(3.14/2))) $$\n\n             We observe that:\n\n             - The function of interest is $x\\mapsto \\frac{3.14}{x}$\n             - It\u0027s applied repeatedly 4 times to the input value of $x=2$.\n\n             The Clojure way is the following:\n\n             ```clojure\n             ((repeat (fn [x] (/ 3.14 x)) 4) 2)\n             ```\n          }}}\n    (:h2 \"Apply\")\n    #md {{{\n           There is a really useful higher order function, _apply_, that we will\n           make good use of.\n\n           The basic form looks like:\n\n           ```clojure\n           (apply \u003cfunction\u003e \u003csequence\u003e)\n           ```\n\n           It\u0027s evaluated to function evaluation where the sequence expression\n           becomes the arguments of the function.\n\n           ```clojure\n           (+ 1 2 3)\n           ;=\u003e 6\n\n           (apply + (range 6))\n           ;=\u003e 6\n\n           (min 3 4 1)\n           ;=\u003e 1\n\n           (let [values ...]\n             (apply min values))\n           ```\n        }}}\n); page\n\n(page (:h1 \"Iteration with loop and recur\")\n      #md {{{\n            Recursion is computationally powerful, but it can be impractically inefficient.\n\n            Consider the computation of Fibonacci numbers.\n\n            - $F(0) = 1$\n            - $F(1) = 1$\n            - $F(i) = F(i-1) + F(i-2)$\n\n            We have seen enough to come up with a functionally correct implementation.\n\n            ```clojure\n            (defn fib\n              [n]\n              (case n\n                0 1\n                1 1\n                (+ (fib (- n 1)) (fib (- n 2)))))\n            ```\n          }}}\n      (note #md {{{\n                   This is a _bad_ implementation.  To see why,\n                   ask yourself the following questions:\n\n                   1. What is the time complexity of `(fib n)`\n                   in terms of `n`?\n\n                   2. What is the space complexity of `(fib n)`\n                   in terms of `n`?\n\n                   3. What are these complexities if we had used\n                   procedural solution to compute the n-th Fibonacci\n                   number.\n                }}})\n      #md {{{\n             The inefficiency of the recursive implementation is evident\n             also from trying to evaluate `(fib 100)`.\n\n             The inefficiency is actually inherit to the recursive algorithm,\n             as indicated by the complexity.  Whereas an iterative algorithm\n             will work much better.\n\n             Clojure provides a functional way of performing iteration\n             using _tail recursion_.\n\n             ## Tail Recursion\n\n             As we know, recursion is if the body of a function invokes the\n             function itself.\n\n             Tail recursion requires that the self-recursive call must be\n             the very _last_ evaluation in the body.\n\n             `(fib ...)` is _not_ tail recursive because of the line:\n\n             ```clojure\n             (+ (fib (- n 1)) (fib (- n 2)))\n             ```\n\n             It shows that _after_ recursive call, it needs to perform _another_ recursive call,\n             and then another apply of `+`.\n\n             Clojure provides elegant form to ensure that we can:\n\n             1. Perform general purpose iteration, and\n             2. do so with really efficient tail-recursion.\n          }}}\n\n      (row 6 6\n           (code :clojure :no-nu\n                 {{{\n                    (loop [sym expr\n                           sym expr\n                           ... ...]\n                      (...\n                       ...\n                        (recur expr expr ...)))\n                 }}})\n           #md {{{\n                  - `(loop [...])` marks the start of the iteration.\n                  Immediately after `loop` is a vector of symbol bindings which\n                  creates a sub-scope for the body of the iteration.\n\n                  - At any point, you can have `(recur ...)` which serves\n                  as a `goto` statement.  It starts a new iteration at the `(loop ...)`,\n                  except that the symbols in `(loop [...])` will receive the\n                  new values supplied by the arguments of `(recur ...)`.\n\n                  - Termination is *not* guaranteed.  The program needs to ensure that\n                  at some point, `(loop ...)` form will _no longer_ evaluate another `(recur ...)`.\n               }}})\n\n      #md {{{\n             Now, we can implement a really efficient version of Fibonacci number.\n\n             ```clojure\n             (defn fib [n]\n               (loop [i    0\n                      Fi-1 nil\n                      Fi-2 nil]\n                 (let [Fi (case i\n                            0 1N\n                            1 1N\n                            (+ Fi-1 Fi-2))]\n                   (if (= i n)\n                     Fi\n                     (recur (inc i) Fi Fi-1)))))\n             ```\n\n             It\u0027s quite efficient:\n\n             - The time complexity is $\\mathcal{O}(n)$,\n             - Time space compleixty is $\\mathcal{O}(1)$.\n               It just needs to hold three numbers: the iteration count `i`,\n               and the two previous Fibonacci numbers `Fi-1` and `Fi-2`.\n             \n             ```\n             (time (println (fib 1000)))\n             703303677114228158218352548771835497701\n             812698363587327426049050871545371181969\n             335797422494945626117334877504492417659\n             910881863632654502236471060120533741212\n             738673391111981393731255987676900919022\n             45245323403501N\n             \"Elapsed time: 21.277407 msecs\"\n             ```\n          }}}\n); page\n\n\n(page (--*--)\n      (:h1 \"Summary\")\n      #md {{{\n             - We have covered a lot _strange_ ways of programming.\n             They are distinctive different from C/Java/Python.\n             Yet, in the face of growing complexity of modern\n             software and integration, it\u0027s precisely this type\n             of programming style will withstand the test of time\n             and bit-delay.\n\n             - We have been working with just numbers and arithmetics.\n             This will change _very very rapidly_.  The principles we\n             have covered so far applies universally to a wide range\n             of domains, from large scale Big Data science, Internet scale\n             Web applications to mobile programming.\n\n             - In this course, we will push the boundary of practical\n             Lisp programming, and experience what is like to use\n             Clojure to solve complex programming tasks.\n          }}})\n", "istop": false, "path": "2-Clojure/2-general-programming"}, "2-Clojure/3-lazy": {"children": [], "content": "{:title \"Sequences and Lazy Programming\"\n :status :done\n :summary #md {{{\n                 _Sequence_ is a fundamental concept in Lisp.  We will\n                 examine how Clojure supports programming around\n                 sequences.  In particular, we will look at _lazy evaluation_\n                 of computation on sequences, and how to use lazy evaluation\n                 to handle _infinite_ sequences.\n              }}}\n}\n\n(page (:h1 \"Prerequisite: function values\")\n\n      #md {{{\n             When it comes to _lazy_ programming, we want to specify\n             computation **without** evaluating it.\n\n             So computation can be specified, but _not_ evaluated until \n             some time later.\n             }}}\n\n      #md {{{\n             Clojure make use of functions as values to specify _delayed_\n             computations.\n\n             Since this happens so often, let\u0027s examine some Clojure\n             language features to specify functions.\n             }}}\n\n      (rows 6 6\n            #md {{{\n                   We can _pollute_ the top-level scope with\n                   _defn_.  But this is the least desirable way\n                   if we need to specify a lot of function values.\n                   }}}\n            (code :clojure\n                  {{{\n                     (defn add-then-multiply [x a b]\n                       (* b (+ x a)))\n                     }}})\n\n            #md {{{\n                   Recall that `(fn ...)` form constructs\n                   a function value.  The function is anonymous\n                   because it doesn\u0027t have to be bound to\n                   any symbol.\n                   }}}\n            (code :clojure\n                  {{{\n                     (fn [x a b]\n                       (* b (+ x a)))\n                     }}})\n\n            #md {{{\n                   Clojure often makes use of anonymous functions with\n                   very simple bodies.  Special syntax is available\n                   to define very simple functions succinctly.\n\n                   `#(...)` creates a function where the arguments\n                   are represented by `%1`, `%2`, ...\n\n                   If there is only one argument, it can be shorthanded to `%`.\n                   }}}\n            (code :clojure\n                  {{{\n                     #(* %3 (+ %1 %2))\n                     }}})\n            ); rows\n\n      ); page\n\n(page (:h1 \"Sequences as abstract type\")\n      #md {{{\n            A sequence is an object that can be the input to the following \n            built-in Clojure functions:\n\n            - `(first xs)`: returns the first element of the sequence `xs`.\n            - `(rest xs)`: returns another sequence that excludes the first of `xs`.\n            - `(cons x xs)`: constructs a new sequence starting with `x` followed by\n            the sequence `xs`.\n\n            Any data structure that support sequence functions is called a _seq_.\n          }}})\n\n(page (:h1 \"Lists, Vector, Hashmaps As Seqs\")\n      #md {{{\n            Seqs are the building block of Clojure programming\n            patterns.  We will see that _many_ data structures\n            can be treated as a generic seqs.  This makes it very\n            easy to reuse generic seq-based code.\n            }}}\n      #md {{{\n\n            ## Lists\n\n            Lists are seqs.\n\n            ```clojure\n            (let [xs \u0027(:a :b :c :d)]\n              (println (first xs))\n              (println (rest xs))\n              (println (cons 1 xs)))\n            ```\n\n            }}}\n      #md {{{\n            ## Vectors\n\n            Vectors are seqs.\n\n            ```clojure\n            (let [xs [:a :b :c :d]]\n              (println (first xs))\n              (println (rest xs))\n              (println (cons 1 xs)))\n            ```\n\n            }}}\n      #md {{{\n            ## Hashmaps \n            \n            Hashmaps are seqs.  This may seem rather strange at first, but Python\n            has `dict.itemize()` to iterate over items as key/value pairs, and\n            Java has `Set\u003cMap.Entry\u003cK,V\u003e\u003e entrySet()` as part of the map interface.\n\n            Clojure treats hashmaps as seqs of key/value pairs.\n\n            ```clojure\n            (let [xs {:name \"Richard Feynman\"\n                      :job \"Physicist\"\n                      :interests [\"Physics\" \"Art\" \"Computing\"]}]\n              (println (first xs))\n              (println (rest xs))\n              (println (cons 1 xs)))\n            ```\n\n            }}}\n      #md {{{\n            ## Mystery seqs\n\n            Sometimes, we will simply get a seq object without knowing how\n            it is implemented.  For instance,\n\n            ```clojure\n            (repeat 3.1415)\n            ```\n\n            will evaluate to an _infinite_ seq in which all the values are\n            the constant 3.1415.  Clearly, we cannot use list, vector nor hashmap\n            to represent an _infinite_ sequence.\n\n            As long as we stick with seq functions, we can handle the data regardless\n            of the `seq` implementation.\n          }}})\n\n(page (:h1 \"Making finite seqs\")\n      #md {{{\n            Clojure comes with a collection of seq functions.\n          }}}\n\n      (row (code\n             :clojure\n             {{{\n                (range end)\n                (range start end)\n             }}})\n           #md {{{\n                  Creates a sequence of integers in the specified range.\n               }}})\n      #md {{{\n            We can make a sequence by repeating an element.\n            \n            ```clojure\n            (repeat n x) ;; a sequence containing n copies of x.\n            ```\n          }}}\n); page\n\n(page (:h1 \"Functions on seqs\")\n      #md {{{\n            Let\u0027s examine functions that act on seqs.\n          }}}\n      (:h2 \"Taking elements\")\n      (row\n        (code :clojure \n              :no-nu\n              {{{\n                (take n \u003cseq\u003e)\n              }}})\n        #md {{{\n               Returns a seq containing the first $n$ elements\n               from `\u003cseq\u003e`.\n            }}})\n      (--*--)\n      (row\n        (code :clojure :no-nu\n              {{{\n                 (take-last n \u003cseq\u003e)\n              }}})\n        #md {{{\n               Returns a seq containing the _last_ $n$\n               elements of `\u003cseq\u003e`.\n            }}})\n      (--*--)\n      (row\n        (code :clojure :no-nu\n              {{{\n                 (last \u003cseq\u003e)\n              }}})\n        #md {{{\n               This is the same as\n               ```clojure\n               (first (take-last 1 seq))\n               ```\n            }}})\n      (--*--)\n      (row\n        (code :clojure :no-nu\n              {{{\n                 (nth \u003cseq\u003e n)\n              }}})\n        #md {{{\n                Returns the $n$-th element in a seq.\n            }}})\n);\n\n(page (:h1 \"Making infinite seqs\")\n      #md {{{\n            Clojure can handle _infinite_ sequences without consuming\n            all the memory.  It can achieve this by making the following\n            observations:\n\n            - It\u0027s easy to describe infinite sequences.\n\n            - We can consume the sequence in bit-size, and only\n            compute the elements in the sequence that are consumed.\n          }}}\n\n      (:h2 \"Infinite repetitions\")\n\n      (row\n        (code :clojure :no-nu\n              {{{\n                (repeat x)\n              }}})\n        #md {{{\n              This generates an infinite seq of x.\n\n              For example, we have\n\n              ```clojure\n              (let [xs (repeat \"hello\")]\n                (println (first xs))\n                (println (nth xs 1))\n                (println (nth xs 2))\n                (println (nth xs 123456)))\n              ```\n\n              This will print \"hello\" four times.\n            }}})\n\n      (:h2 \"Infinite function applications\")\n      (row\n        (code :clojure :no-nu\n              {{{\n                 (iterate f x)\n              }}})\n        #md {{{\n               This generates an _infinite_ sequence starting with `x`,\n               followed by `(f x)`, and then `(f (f x))`, so on infinitum.\n\n               Here is an example:\n\n               ```clojure\n               (let [numbers (iterate inc 0)]\n                 (println (take 10 numbers)))\n               ```\n\n               This will print `(0, 1, 2, ... 9)`.\n            }}})\n\n      (:h2 \"Infinitely cycling through a sequence\")\n\n      (row\n        (code :clojure :no-nu\n              {{{\n                 (cycle \u003cseq\u003e)\n              }}})\n        #md {{{\n               This constructs an infinite sequence that is `\u003cseq\u003e`\n               repeated indefinitely.\n\n               ```clojure\n               (println (take 100 (cycle (range 3))))\n               ```\n\n               This prints `0 1 2 0 1 2 `...\n            }}})\n); page\n\n(page (:h1 \"Transforming sequences\")\n      #md {{{\n             There are some interesting ways to transform a sequence or\n             combine multiple sequeneces to a single seq.\n          }}}\n\n      (:h2 \"Join seq with a separator\")\n\n      (row\n        (code :clojure :no-nu\n              {{{\n                 (interpose \u003cseperator\u003e \u003cseq\u003e)\n              }}})\n        #md {{{\n               Returns a seq that is built by\n               inserting a `\u003cseparator\u003e` between every pair of adjacent\n               elements in `\u003cseq\u003e`.\n\n               ```clojure\n               (println (interpose \"|\" (range 5))) \n               ;=\u003e 0 | 1 | 2 | 3 | 4\n               ```\n            }}})\n\n      (:h2 \"Combining two sequences by interleaving\")\n\n      (row\n        (code :clojure :no-nu\n              {{{\n                 (concat \u003cxs\u003e \u003cys\u003e)\n              }}})\n        #md {{{\n               Returns a sequence starting with elements in `xs`\n               followed by `ys`.\n            }}})\n\n      (row\n        (code :clojure :no-nu\n              {{{\n                 (interleave \u003cxs\u003e \u003cys\u003e)\n              }}})\n        #md {{{\n               Creates a seq with `x` interleaved with `y`:\n\n               `x0 y0 x1 y1 ...`\n\n               until either `xs` or `ys` reaches its end.\n\n               ```clojure\n               (let [xs (range 100)\n                     ys [:a :b :c]]\n                 (println (interleave xs ys)))\n               ;=\u003e 0 :a 1 :b 2 :c\n               ```\n            }}})\n\n      (--*--)\n\n      (note #md {{{\n                   _Challenge_\n\n                   Can you implement _interpose_\n                   using _interleave_ and other seq functions\n                   we have covered?\n                }}})\n\n      (:h2 \"Transformation by predicates\")\n\n      (row\n        (code :clojure :no-nu\n              {{{\n                 (filter \u003cpred\u003e \u003cseq\u003e)\n              }}})\n        #md {{{\n               A predicate is a function that takes _one_ input and always returns true or false.\n\n               `(filter \u003cpred\u003e \u003cseq\u003e)` returns elements that are evaluated to _true_ by the predicate.\n\n\n               ```clojure\n               (let [small? (fn [n] (\u003c n 5))\n                     numbers (iterate inc 0)]\n                 (filter small? numbers))\n               ;=\u003e (0 1 2 3 4)\n               ```\n            }}})\n\n      (row\n        (code :clojure :no-nu\n              {{{\n                 (take-while \u003cpred\u003e \u003cseq\u003e)\n              }}})\n        #md {{{\n               Only keeps the elements **until** the predicate is no longer satisfied.\n            }}})\n\n      (row\n        (code :clojure :no-nu\n              {{{\n                 (drop-while \u003cpred\u003e \u003cseq\u003e)\n              }}})\n        #md {{{\n               Only keeps the elements **when** the predicate is no longer satisfied.\n            }}})\n); page\n\n(page (:h1 \"Splitting and partitioning\")\n      #md {{{\n             Splits a sequence into two.\n             ```clojure\n             (split-at i \u003cseq\u003e)\n             ;=\u003e [(take i \u003cseq\u003e) (drop i \u003cseq\u003e)]\n\n             (split-with pred \u003cseq\u003e)\n             ;=\u003e [(take-while pred \u003cseq\u003e) (drop-while pred \u003cseq\u003e)]\n             ```\n          }}}\n\n      (row\n        (code :clojure :no-nu\n              {{{\n                 (partition n \u003cseq\u003e)\n              }}})\n        #md {{{\n               Divides `\u003cseq\u003e` into non-overlapping segments of size `n`.\n            }}})\n\n      (row\n        (code :clojure :no-nu\n              {{{\n                 (partition n i \u003cseq\u003e)\n              }}})\n        #md {{{\n               Divides `\u003cseq\u003e` into segments of size `n`, and each\n               adjacent segments are offset by $n$.\n\n               The following generates the sliding window\n               of size 3.\n               ```clojure\n               (partition 3 1 (range 100))\n               ;=\u003e [0 1 2] [1 2 3] [2 3 4] ...\n               ```\n            }}})\n); page\n\n(page (:h1 \"Predicates on sequences\")\n      #md {{{\n             ```clojure\n             (empty? seq)\n             ```\n             }}}\n      #md {{{\n             ```clojure\n             (every? \u003cpred\u003e \u003cseq\u003e)\n             ```\n             }}}\n      #md {{{\n\n             ```clojure\n             (some \u003cpred\u003e \u003cseq\u003e)\n             ```\n             }}}\n      #md {{{\n\n             ```clojure\n             (not-every? \u003cpred\u003e \u003cseq\u003e)\n             ```\n             }}}\n      #md {{{\n\n             ```clojure\n             (not-any? \u003cpred\u003e \u003cseq\u003e)\n             ```\n          }}}\n); page\n\n(page (:h1 \"Map \u0026 Reduce\")\n      #md {{{\n             ```clojure\n             (map f \u003cseq\u003e)\n             (reduce f x0 \u003cseq\u003e)\n             ```\n          }}}\n      (rows 5 7\n            #md {{{\n                   Map _transforms_ a seq one element at a time\n                   by applying a function to each element.\n\n                   `map: seq -\u003e seq`\n                   }}}\n            (code :scala\n                  {{{ \n                     (let [xs (range 10) \n                           stars (fn [n]\n                                   (clojure.string/join \n                                     \"\" \n                                     (repeat n \"*\")))] \n                       (map stars xs))\n                     }}})\n\n            #md {{{\n                   Reduce is a more _powerful_ transformation.\n                   It _reduces_ a seq to a data value.\n\n                   \u003e The data value can be a scalar, or another seq.\n\n                   `reduce: seq -\u003e data`\n                   }}}\n            (:div\n                (code :clojure\n                      {{{\n                         ;; Computing the sum of a sequence\n                         (let [xs (range 10)]\n                           (reduce + 0 xs))\n                         }}})\n                (code :clojure\n                      {{{\n                         ;; Implementing map using reduce\n                         (let [xs (range 10)\n                               stars (fn [n]\n                                       (join \"\" (repeat n \"*\")))\n                               g (fn [ys n] (conj ys (stars n)))]\n                           (reduce g [] xs))\n                         }}}))\n            ); rows\n); page\n\n(page (:h1 \"Sorting\")\n      #md {{{\n             ```clojure\n             (sort \u003ccomparator\u003e seq)\n             (sort-by \u003ckeyfunc\u003e seq)\n             ```}}}\n\n      (rows 4 8\n            #md {{{\n                   We can rely on the _natural_ ordering\n                   to sort a seq.\n                   }}}\n            (code :clojure\n                  {{{\n                     (let [gibberish (take 10 (repeatedly #(rand-int 100)))]\n                       (sort gibberish))\n                     }}})\n\n\n            #md {{{\n                   We can provide our own specific comparator.\n                   For this sample, we sort the numbers by how\n                   close it is to the value of $\\pi$.\n                   }}}\n            (code :clojure\n                  {{{\n                     (let [gibberish (take 10 (repeatedly #(rand-int 10)))\n                           f (fn [a b] (compare (Math/abs (- a Math/PI))\n                                                (Math/abs (- b Math/PI))))]\n                       (sort f gibberish))\n                     }}})\n\n\n            (:div\n                  #md {{{\n                         Sometimes, we want to map the elements by _a comparison key function_ to\n                         sort them.\n                      }}}\n\n                  #md {{{\n                         For example:\n\n                         \u003e The elements are students, which are not obviously comparable.\n                         \u003e Here are some examples of _comparison key functions_:\n                         \u003e \n                         \u003e 1. Final grade\n                         \u003e 2. Height\n                         \u003e 3. Number of lectures attended\n                         }}}\n\n                  #md {{{\n                         Clojure supports sorting as long as we can provide the comparison key\n                         function with the `(sort-by ...)` function.\n                         }}})\n\n            (:div\n                  (code :clojure\n                        {{{\n                           (let [gibberish (take 10 (repeatedly #(rand-int 10)))\n                                 k (fn [a] (Math/abs (- a Math/PI)))]\n                             (sort-by k gibberish))\n                           }}})\n                  (code :clojure\n                        {{{\n                           (let [students [{:name \"Jack\" :grade 80}\n                                           {:name \"Mary\" :grade 90}\n                                           {:name \"Joe\" :grade 70}]]\n                             (reverse (sort-by :grade students)))\n                           }}}))\n            ); rows\n      ); page\n\n(page (:h1 \"Iteration By List-Comprehension\")\n      (rows :sep 6 6\n            #md {{{\n                   We can fine control the enumeration using the `(for ...)`\n                   form.\n\n                   1. The form generates a lazy seq.\n                   2. At each iteration, the symbol `x` is bound to the current\n                   element in `\u003cseq\u003e`.\n                   3. The `\u003cexpr\u003e` is lazily evaluated to form the elements\n                   of the returned seq.\n                   }}}\n            (code :clojure \n                  {{{ \n                     (for [x \u003cseq\u003e] \n                       \u003cexpr\u003e) \n                     }}})\n\n\n            #md {{{\n                   `(for ...)` is quite powerful.\n\n                   1. It allows nested iteration over multiple\n                   seqs.\n                   2. It allows additional symbols binding during _each_\n                   iteration.\n                   3. It allows filtering condition during iteration.\n                   }}}\n             (code :clojure \n                   {{{\n                      (for [x \u003cseq\u003e\n                            y \u003cseq\u003e\n                            :let [...]\n                            :when (...)] \u003cexpr\u003e)\n                   }}})\n             ); rows;\n      ); page\n\n(page (:h1 \"Side-effects\")\n      (rows :sep 6 6\n            #md {{{\n                   Lazy evaluation is great because it allows us\n                   to never waste time to iterate over elements\n                   that are not necessary, and hence we can handle\n                   infinite sequences.\n                   }}}\n            (code :clojure\n                  {{{\n                     (take 10 (for [x (range 1000000)]\n                                (* x x)))\n                     }}})\n\n            #md {{{\n                   But Clojure also supports _non-functional_ programming.\n                   So each iteration can have _side-effects_.\n\n                   Example of side-effect:\n\n                   \u003e (println \"hello\")\n                   \u003e (save-to-file f name)\n                   }}}\n\n            (:div (code :clojure\n                        {{{\n                           (defn stutter [n message]\n                             (for [i (range n)]\n                               (println i \":\" message)))\n\n                           (stutter 3 \"Good morning.\")\n                           }}})\n                  #md {{{\n                         It might be surprising to find out\n                         that under certain runtime environment\n                         (running as a command-line script),\n                         nothing gets printed.\n\n                         `=\u003e` Reason is that `stutter` chose\n                         to be lazy and not evaluate the iteration loop.\n                         }}})\n\n\n\n            #md {{{\n                   We can force the evaluation of a lazy sequence\n                   using `(doall ...)`\n                   }}}\n            (:div (code :clojure\n                        {{{\n                           (defn stutter [n message]\n                             (doall \n                               (for [i (range n)]\n                                 (println i \":\" message))))\n\n                           (stutter 3 \"Good morning.\")\n                           }}})\n                  #md {{{\n                         This version will work as expected.\n\n                         `(doall ...)` forces the evaulation over _all_\n                         elements in `(range n)`.\n                         }}})\n\n            #md {{{\n                   `(doall ...)` still returns a seq which takes memory.\n                   If we know that the iteration does not generate new\n                   data, but rather is strictly with side-effects,\n                   we can use the `(dotimes [i n] ...)` form.\n                   }}}\n            (code :clojure\n                  {{{\n                     (defn stutter [n message] \n                       (dotimes [i n] \n                         (println i \":\" message)))\n                     }}})\n            ); rows\n      ); pages\n\n(page (:h1 \"Constructing lazy seq manually\")\n      (rows 6 6\n           #md {{{\n                  Can we create a lazy sequence manually?\n\n                  Yes: (lazy-seq \u003cexpr\u003e) defers the evaluation\n                  of `\u003cexpr\u003e` until its element are needed.\n                  }}}\n           (code :clojure :no-nu\n                 {{{\n                    (lazy-seq (cons x \u003cseq\u003e))\n                 }}})\n\n\n           #md {{{\n                  Consider the seq:\n\n                  `[:a :b :c]`\n\n                  This is not a lazy seq because\n                  all the elements are evaluated.\n\n                  Let\u0027s make it a lazy seq.\n               }}}\n           (code :clojure\n                 {{{\n                    (lazy-seq \n                      (cons :a\n                            (lazy-seq\n                              (cons :b\n                                    (lazy-seq\n                                      (cons :c nil))))))\n                    }}})\n           ); rows\n\n      (rows 6 6\n            #md {{{\n                   Let\u0027s revisit the Fibonacci sequence\n                   function.\n\n                   Suppose we want to compute the _infinite_\n                   sequence of Fibonacci numbers.\n                   }}}\n            nil\n\n            #md {{{\n                   Recall that we had a function\n\n                   `(fib n)`\n                   }}}\n\n            (:div (code :clojure\n                        {{{\n                           (map fib (iterate inc 0))\n                           }}})\n                  #md {{{\n                         Here is a solution.\n\n                         _What\u0027s wrong with it?_\n\n                         _Performance, wasted computation_\n                         }}})\n\n\n            #md {{{\n                   Let\u0027s use lazy sequence construction\n                   to build the infinite sequence _without_\n                   any wasted computation.\n                   }}}\n            (code :clojure :sm\n                  {{{\n                     (defn fibonacci-numbers\n                       [a b]\n                       (let [n (+ a b)]\n                         (lazy-seq \n                           (cons n (fibonacci-numbers b n)))))\n                     }}})\n            ); rows\n); page\n\n(slide (:h1 \"Summary\")\n      (rows 6 6\n            #md {{{\n                   Sequence programming is a staple of programming.\n\n                   Functional programming provides much cleaner abstractions\n                   around sequences.\n                   }}}\n\n            #md {{{\n                   Functional programming, such as Clojure, supports lazy\n                   evaluations, thus we are able to program with\n                   _infinite_ sequences efficiently.\n                   }}}))\n", "istop": false, "path": "2-Clojure/3-lazy"}, "2-Clojure/4-data-transformation": {"children": [], "content": "{:title \"Transformation of Data\"\n :status :done\n :summary {{{\n             We will look at how data is transformed in Clojure.\n             }}}}\n\n(page (:h1 \"Cheatsheet\")\n\n      #md {{{\n             I strongly urge any serious Clojure developers to\n             bookmark the Clojure cheatsheet(s):\n\n             - https://clojure.org/api/cheatsheet\n             - http://cljs.info/cheatsheet/\n             }}})\n\n(page (:h1 \"Data Literals\")\n\n      #md {{{\n             Let\u0027s first look at how can be built in the\n             Clojure source code.\n             }}}\n\n      (:h2 \"List\")\n\n      #md {{{\n             ```clojure\n             `(1 2 3)\n             ```}}}\n\n      (:h2 \"Vector\")\n      #md {{{\n             ```clojure\n             [1 2 3]\n             (vector 1 2 3)\n             ```\n             }}}\n      (note #md {{{\n                   Vectors are generally preferred\n                   over lists.  They allow fast\n                   random access.\n                   }}})\n\n      (:h2 \"Hashmap\")\n      #md {{{\n             ```clojure\n             {:course-code \"CSCI 3055U\"\n              :course-title \"Programming Languages\"\n              :enrolment nil}\n             ```\n             }}}\n\n      (:h2 \"Set\")\n      #md {{{\n             ```clojure\n             #{1 2 3}   ; Okay\n             #{1 2 3 1} ; Not okay\n             ```\n             }}}\n\n      (note #md {{{\n                 There is more:\n\n                 - functions: `#(...)` or `(fn ...)`\n                 - regular expressions: `#\"...\"`\n                 }}})\n    ); page\n\n(page (:h1 \"Transforming seqs\")\n      (rows :sep 4 8\n            #md {{{\n                   Adding elements\n                   }}}\n            (:div (code :clojure \n                        {{{ \n                           (cons :a \u0027(1 2 3))\n                           ;; =\u003e \u0027(a 1 2 3)\n\n                           (cons :a [1 2 3])\n                           ;; =\u003e \u0027(a 1 2 3)\n                           }}})\n                  (code :clojure\n                        {{{\n                           (conj \u0027(1 2 3) :a)\n                           ;; =\u003e \u0027(:a 1 2 3)\n                           (conj (vector 1 2 3) :a)\n                           ;; =\u003e [1 2 3 :a]\n                           }}})\n                  ); div\n\n\n            #md {{{\n                   Delete elements\n\n                   \u003e There is __no__ deletion in functional programming.\n                   \n                   For example, given `[1 2 3]`\n                   we cannot choose to remove the elements because the\n                   vector is _ready-only_.  However, we can _transform_\n                   the vector to a new _smaller_ list.\n                   }}}\n            (:div (code :clojure\n                        {{{\n                           (rest \u0027(1 2 3 4))\n                           ;; =\u003e \u0027(2 3 4)\n\n                           (pop \u0027(1 2 3 4))\n                           ;; =\u003e \u0027(2 3 4)\n                           }}})\n                  (code :clojure\n                        {{{\n                           (rest [1 2 3 4])\n                           ;; =\u003e \u0027(2 3 4)\n\n                           (pop [1 2 3 4])\n                           ;; =\u003e [1 2 3]\n                           }}}))\n            );rows\n      ); page\n\n(page (:h1 \"Transforming vectors\")\n\n      (rows :sep 4 8\n            #md {{{\n                   Changing elements at indexes.\n                   }}}\n            (code :clojure\n                  {{{\n                     (assoc [:a :b :c :d]\n                            0 \"A\"\n                            2 \"C\")\n                     ;; =\u003e [\"A\" :b \"C\" :d]\n                     }}})\n\n            #md {{{\n                   We can update elements at index\n                   by an update function.\n                   }}}\n            (code :clojure\n                  {{{\n                     (update [:a :b :c :d]\n                             0\n                             (fn [x] (str \"x=\" x)))\n                     ;; [\"x=:a\" :b :c :d]\n                     }}})\n\n\n            #md {{{\n                   Subvectors\n                   }}}\n            (code :clojure\n                  {{{\n                     (subvec [:a :b :c :d] 2)\n                     ;; =\u003e [:c :d]\n\n                     (subvec [:a :b :c :d] 1 3)\n                     ;; =\u003e [:b :c]\n                     }}})\n\n            #md {{{\n                   Replace elements by indexes.\n                   }}}\n            (code :clojure\n                  {{{\n                     (replace {:zero 0 :seven 7} \n                              [:zero :zero :seven \"is\" \"James\" \"Bond\"])\n                     ;; =\u003e [0 0 7 \"is\" \"James\" \"Bond\"]\n                     }}})\n            ); rows\n      ); page\n\n(page (:h1 \"Hash-maps\")\n\n      (rows :sep 4 8\n            #md {{{ \n                   For all the sample code below, \n                   let\u0027s assume that we have the following symbol binding:\n                   }}}\n            (code :clojure\n                  :sm\n                  {{{\n                   (def richard {:last-name \"Feynman\"\n                                 :first-name \"Richard\"\n                                 :job \"Physicist\"\n                                 :work {:school \"Caltech\"\n                                        :position \"Professor\"\n                                        :address {:city \"Pasadena\" \n                                                  :state \"California\"\n                                                  :country \"USA\"}}\n                                 :hobbies [:science :music :art]})\n                   }}})\n\n            #md {{{\n                   Setting key/values\n\n                   `(assoc \u003cmap\u003e key val key val ...)`\n                   }}}\n            (code :clojure\n                  {{{\n                     (assoc richard \n                            :born \"1918-05-11\"\n                            :died \"1988-02-15\")\n                     ;; =\u003e {:last-name \"Feynman\",\n                     ;;     :first-name \"Richard\",\n                     ;;     :job \"Physicist\",\n                     ;;     :work {:school \"Caltech\",\n                     ;;            :position \"Professor\",\n                     ;;            :address {:city \"Pasadena\", \n                     ;;                      :state \"California\", \n                     ;;                      :country \"USA\"}},\n                     ;;     :hobbies [:science :music :art],\n                     ;;     :born \"1918-05-11\",\n                     ;;     :died \"1988-02-15\"}\n                     }}})\n\n            #md {{{\n                   Removing keys\n\n                   `(dissoc \u003cmap\u003e key key ...)`\n                   }}}\n\n            (code :clojure\n                  {{{\n                     (dissoc richard :job :hobbies)\n                     ;; {:last-name \"Feynman\"\n                     ;;  :first-name \"Richard\"\n                     ;;  :work {:school \"Caltech\"\n                     ;;         :position \"Professor\"\n                     ;;         :address {:city \"Pasadena\" \n                     ;;                   :state \"California\"\n                     ;;                   :country \"USA\"}}\n                     ;; }\n                     }}})\n\n\n            #md {{{\n                   Nested maps are very common in Clojure.\n                   Each part of the nested map can be\n                   referenced by a _path_ from the root.\n\n                   We can get the values using\n                   paths with `(get-in \u003cmap\u003e [...])`\n                   }}}\n            (code :clojure :sm\n                  {{{\n                     (get-in richard [:work :address :state])\n                     ;; =\u003e California\n\n                     (get-in richard [:work :address])\n                     ;; =\u003e {:city \"Pasadena\" :state \"California\" :country \"USA\"}\n\n                     (get-in richard [:hobbies 0])\n                     ;; =\u003e :science\n                     }}})\n\n\n            #md {{{\n                   The paths can also be used to transform by updating values.\n\n                   `(assoc-in \u003cmap\u003e [path] \u003cnew-value\u003e)`\n\n                   `(update-in \u003cmap\u003e [path] \u003cupdate-fn\u003e)`\n                   }}}\n            (:div (code :sm :clojure\n                        {{{\n                           (assoc-in \n                             richard \n                             [:work :address :street] \n                             \"1200 E California Blvd\")\n                           }}})\n                  (code :sm :clojure\n                        {{{\n                           (update-in\n                             richard\n                             [:work :position]\n                             #(str \"Nobel winning \" %))\n                           }}})\n                  ); div\n            );rows\n      ); pages\n\n(page (:h1 \"Advanced hash-map transformations\")\n      #md {{{\n             Clojure places great emphasis on the transformations\n             of hash-map objects.\n\n             Let\u0027s look at some more advanced transformations.\n             }}}\n\n\n      (rows :sep 5 7\n            #md {{{\n                   Creating hash-map out of interesting things.\n                   }}}\n            (:div (code :sm :clojure\n                        {{{\n                           (hash-map :a 1 :b 2 :c 3)\n                           ;; =\u003e {:a 1 \n                           ;;     :b 2 \n                           ;;     :c 3}\n\n                           (apply hash-map [:a 1 :b 2 :c 3])\n                           ;; same as before\n                           }}})\n                  (code :sm :clojure\n                        {{{\n                           (zipmap [:a :b :c] [1 2 3])\n                           ;; same as before\n\n                           (zipmap \"abc\" (range 3))\n                           ;; =\u003e {\\a 1\n                           ;;     \\b 2\n                           ;;     \\c 3}\n                           }}})\n                  (code :sm :clojure\n                        {{{\n                           (frequencies [:a :b :c :b :c :c])\n                           ;; =\u003e {:a 1, :b 2, :c 3}\n                           }}})\n                  (code :sm :clojure\n                        {{{\n                           (group-by first [\"mary\" \"jack\" \"joe\"])\n                           ;; =\u003e {\\m [\"mary\"]\n                           ;;     \\j [\"jack\" \"joe\"]}\n                           }}}))\n\n            #md {{{\n                   Merging two or more maps.\n\n                   `(merge \u003cmap\u003e \u003cmap\u003e ...)`\n                   }}}\n            (code :sm :clojure\n                  {{{\n                     (let [personal {:last-name \"Feynman\"\n                                     :first-name \"Richard\"\n                                     :hobbies [:science :music :art]}\n                           professional {:award [\"Nobel in Physics\"]\n                                         :work {:position \"Professor\"}}]\n                       (merge personal professional))\n                     ;; =\u003e {:last-name \"Feynman\",\n                     ;;     :first-name \"Richard\",\n                     ;;     :hobbies [:science :music :art],\n                     ;;     :award [\"Nobel in Physics\"],\n                     ;;     :work {:position \"Professor\"}}\n                     }}})\n\n            #md {{{\n                   Merge with common keys\n\n                   `(merge-with reducer \u003cmap\u003e \u003cmap\u003e ...)`\n                   }}}\n\n            (code :sm :clojure\n                  {{{\n                     (let [m1 {:a [1 2 3]\n                               :b [2 3]}\n                           m2 {:a [10 20 30]\n                               :c [200 300]}]\n                       (merge-with concat m1 m2))\n                       ;; =\u003e {:a [1 2 3 10 20 30]\n                       ;;     :b [2 3]\n                       ;;     :c [200 300]}\n                     }}})\n\n\n            #md {{{\n                   Keep only some keys\n\n                   `(select-keys \u003cmap\u003e \u003ckeys\u003e)`\n                   }}}\n            (code :sm :clojure\n                  {{{\n                     (select-keys {:a 1 :b 2 :c 3}\n                                  [:a :c])\n                     ;; =\u003e {:a 1, :c 3}\n                     }}})\n            ); rows\n      ); page\n\n(page (:h1 \"The great (into ...)\")\n\n      #md {{{\n             Clojure comes with a little function called\n             `(into \u003ccoll\u003e [...])`.\n\n             It inserts elements into the `\u003ccoll\u003e`.\n             }}}\n\n      (box #md {{{\n                  `(into \u003ctarget-coll\u003e \u003csource-coll\u003e)` always\n                  returns the _same_ collection type\n                  as the `\u003ctarget-coll\u003e`.\n                  }}})\n\n      (rows :sep 4 8\n\n            #md {{{\n                   Into a vector...\n                   }}}\n\n            (:div (code :sm :clojure\n                        {{{\n                           (into [:a :b :c] \u0027(1 2 3))\n                           ;; =\u003e [:a :b :c 1 2 3]\n                           }}})\n                  #md {{{\n                         In contrast, `concat` returns\n                         a list:\n\n                         ```clojure\n                         (concat [:a :b :c] \u0027(1 2 3))\n                         ;; =\u003e \u0027(:a :b :c 1 2 3)\n                         ```\n                         }}})\n\n            #md {{{\n                   Into a hash-map...\n\n                   - Target is a hash-map,\n                   - source is a seq of `[key val]` paris.\n                   }}}\n\n            (code :sm :clojure\n                  {{{\n                     (into {} [[:a 1]\n                               [:b 2]\n                               [:c 3]])\n                     ;; =\u003e {:a 1, :b 2, :c 3}\n                     }}})\n            ); rows\n      ); page\n\n", "istop": false, "path": "2-Clojure/4-data-transformation"}, "2-Clojure/4-standard-library": {"children": [], "content": "{:title \"The Standard Libraries\"\n :status :done\n :summary #md {{{\n                 This section focuses on _practical_\n                 programming using Clojure.  \n                 Covering the entire standard library\n                 is beyond the scope of this lecture. We want to focus\n                 on two aspects of the design principles of\n                 the library:\n\n                 1. The APIs are succinct and modular.\n                 2. Sequences are used throughout the library.\n              }}}}\n\n(page (:h1 \"About Clojure libraries\")\n      #md {{{\n             Clojure is a high level language that compiles to\n             a number of host languages.  The primary target is\n             _Java_.  Clojure provides very tight integration with\n             its host languages especially for Java.\n\n             Thus, when it comes to system level programming\n             (or graphical user interface, or networking), we can\n             always rely on the Java API.\n\n             The downside however is that mixing Java oriented Clojure\n             code with pure functional code introduces added complexity\n             to the code.  It also breaks the compatibility of the\n             resulting code with other host runtime environments\n             (such as Javascript or Windows .NET CLR).\n\n             In this lecture, we focus on the Clojure-friendly thin\n             wrappers as part of the standard Clojure \n          }}})\n\n(page (:h1 \"Interacting With File System\")\n      #md {{{\n            A file is a value. A file value can be constructed\n            in several ways.\n\n            ## Getting a file value\n\n            ```clojure\n            (clojure.java.io/file \"datafile.csv\")\n            (clojure.java.io/reader \"datafile.csv\")\n            (clojure.java.io/writer \"datafile.csv\")\n            ```\n          }}}\n      #md {{{\n            ## Reading lines\n\n            ```clojure\n            (line-seq rdr)\n            ```\n          }}}\n      (row 8 4\n        (code :clojure\n              :sm\n              {{{\n                 (require \u0027[clojure.java.io :as io])\n                 (let [rdr (io/reader \"datafile.csv\")]\n                   (doseq [line (line-seq rdr)]\n                     (println \"\u003e\" line)))\n              }}})\n        #md {{{\n               - `doseq` behaviours like `for`. It\n               evaluates the body, but does not\n               retain the returned values.\n\n               - `(line-seq rdr)` produces a lazy\n               sequence of lines from the reader.\n            }}})\n\n      #md {{{\n            ## Writing lines\n\n            ```clojure\n            (ns core\n              (:require [clojure.java.io :as io]))\n\n            (let [outfile (io/writer \"logfile\")]\n              (doseq [i (range 100)]\n                (.write outfile (format \"line [%d]\\n\" i)))\n              (.flush outfile)\n              (.close outfile))\n            ```\n\n            Note that we have to manually flush the\n            writer and close it to free any resources.\n\n          }}}\n      (row 8 4\n           (code :clojure\n                 :sm\n                 {{{\n                    (with-open [outfile (io/writer \"logfile\")]\n                      (doseq [i (range 100)]\n                        (.write outfile (format \"line [%d]\\n\" i))))\n                 }}})\n           #md {{{\n                  The `(with-open ...)` form automatically\n                  closes the writer and flushes the buffer.\n               }}})\n); page\n\n(page (:h1 \"Regular Expressions\")\n      #md {{{\n             Regular expression matching is a convenient\n             way to perform light-weight parsing and\n             pattern matching.  Commonly known as regex,\n             it\u0027s part of the standard library of all\n             modern languages (Java, Python, Javascript, Go, etc.).\n          }}}\n\n      (note #md {{{\n             Refer to \n             \n             - [Java tutorial](https://docs.oracle.com/javase/tutorial/essential/regex/),\n             - [Python regexp library](https://docs.python.org/2/library/re.html),\n             - [Javascript regex support](https://developer.mozilla.org/en/docs/Web/JavaScript/Guide/Regular_Expressions)\n\n             for details of other language support of regular expressions.\n             }}})\n\n      #md {{{\n             ## A quick review of programmatic regular expression\n\n\n             Regular expressions (or RE for short) can do a few things:\n\n             - Define a pattern of a collection of strings.\n             - Within the pattern, RE can define zero or more subpatterns which are known as groups.\n\n             Given an input string $s$ and a pattern defined as a RE $p$, the library can\n             perform the following for us:\n\n             1. Determine if $s$ _matches_ the pattern $p$ or not.\n             2. Find one or all (non-overlapping) substrings of $t$ that match $p$.\n             3. For each matching string, deconstruct the matchings of the groups\n             defined in $p$.\n          }}}\n\n      #md {{{\n             ## Constructing RE\n\n             Clojure is one of few languages that supports RE as part of its syntax.\n          }}}\n\n      (row 6 6\n           (:div\n             #md {{{\n                    Java has a class `Pattern` which has a static method\n                    called `Pattern.compile(...)` which returns a pattern.\n                 }}}\n             (code :java\n                   :sm\n                   :no-nu\n                   {{{\n                      import java.util.regex.Pattern;\n\n                      Pattern p = Pattern.compile(\n                                    \"(\\\\d+)\\\\s*,\\\\s*(\\\\d+)\");\n                   }}}))\n           (:div\n             #md {{{\n                   Clojure uses the syntax `#\"...\"` to indicate that\n                   the enclosed string is a RE.\n                   \u003cbr\u003e\u003cbr\u003e\n                 }}}\n             (code :clojure\n                   :sm\n                   :no-nu\n                   {{{\n                      (def p #\"(\\d+)\\s*,\\s*(\\d+)\")\n                   }}})))\n\n); page\n\n(page (:h1 \"RE Matches\")\n\n      #md {{{\n            ## Deciding on a match\n\n            ```clojure\n            ;; returns nil or the match\n            (re-matches pattern str)\n            ```\n\n            Example:\n\n            ```clojure\n            (let [two-col-csv #\"(\\d+),(\\d+)\"\n                  line-1 \"23,42\"\n                  line-2 \"hello,world\"]\n              (println \"line-1: \" (re-matches two-col-csv line-1))\n              (println \"line-2: \" (re-matches two-col-csv line-2)))\n\n            ;; line-1:  [\"23,42\"    \"23\"     \"42\"]\n            ;; line-2:  nil\n            ```\n          }}}\n\n      (row 8 4\n           (code :clojure\n                 :sm\n                 {{{\n                   (let [p #\"(\\d+),(\\d+)\"]\n                     (with-open [f (clojure.java.io/reader \"data.csv\")]\n                       (let [sums (for [line (line-seq f)]\n                                    (let [[_ i j] (re-matches p \n                                                              line)]\n                                      (+ (Float/parseFloat i)\n                                         (Float/parseFloat j))))]\n                         (/ (apply + sums) (count sums)))))\n                 }}})\n           #md {{{\n                  - We look for lines with two integer columns.\n                  - `sums` is the sum of each line in the CSV file.\n                  - The expression evaluates the average of the sums.\n               }}})\n); page\n\n(page (:h1 \"Streaming matches\")\n      #md {{{\n             It\u0027s possible to stream the matches (either `nil`, a string, or a vector of groups)\n             as a lazy sequence.\n\n             ```clojure\n             (re-seq pattern string)\n             ```\n          }}}\n\n      (row 7 5\n           (code\n             :clojure\n             :sm\n             {{{\n                (let [p #\"(\\d+),(\\d+)\"\n                      text (slurp \"data.csv\")]\n                  (reduce (fn [[total n] [_ i j]]\n                            ((+ total i j) (inc n)))\n                          [0.0f 0] \n                          (filter (complement nil?) \n                                  (re-seq text))))\n             }}})\n           #md {{{\n                  - `(slurp \"data.csv\")` reads the content of the file `\"data.csv\"`\n                  as a string.\n                  - `(reduce ...)` is accumulating a state of a pair: total sum and\n                  the count.  The state is initialized to `[0.0f  0]`.\n                  - We use a [_destructuring_ feature](https://clojure.org/guides/destructuring)\n                  to build the reducer function.  It allows as to declare \"_nested arguments_\"\n                  of functions.\n               }}})\n); page\n\n(page #md {{{\n              # Summary\n\n              ---\n\n              - Clojure\u0027s filesystem access is built on top of Java\u0027s file API.\n\n              - The language feature of Clojure improves file access with\n\n                `(with-open [...] ...)`\n              \n              - We can use `slurp` (or `spit`) for quick and dirty file I/O.\n\n              ---\n\n              - Clojure has native support for regular expressions.\n\n              - `(re-seq ...)` constructs a lazy sequence.  Coupled with functional sequence\n              programming, we can perform text processing with very little programming.\n           }}})\n", "istop": false, "path": "2-Clojure/4-standard-library"}, "2-Clojure/5-clojure-projects": {"children": [], "content": "{:title \"Clojure Projects\"\n :status :done\n :summary\n #md {{{\n        Clojure is an industrial strenght programming\n        language.  It has many features to support\n        large code base. This section describes these\n        features.\n     }}}}\n\n(page (:h1 \"About namespaces\")\n      #md {{{\n            Recall that symbols are bound to\n            values, and expressions perform computation\n            using symbols.\n\n            Thus, in large code base, we need to with\n            _many_ symbols. So far, we only distinguish\n            the bindings of symbols by the scopes.\n\n            ```clojure\n            (def name \"Albert\")\n            (println \"The first name is \" name)\n            (let [name \"Einstein\"]\n              (println \"The last name is \" name))\n            ```\n\n            Sometimes, we need both bindings of\n            at the same time.  This is when we will need to\n            rename the symbols so that they are distinct.\n\n            ```clojure\n            (let [first-name \"Albert\"\n                  last-name \"Einstein\"]\n              (println \"The full name is \" first-name \" \" last-name))\n            ```\n\n            But what if different authors are working on interdependent\n            components.  One cannot rely on agreements on symbol\n            naming conventions.\n\n            This is where _namespaces_ comes in.\n          }}}\n\n      (--*--)\n\n      #md {{{\n             _Definition_:\n\n             \u003e A _namespace_ consists of:\n             \u003e\n             \u003e - A name\n             \u003e - A top-level scope of the namespace\n          }}}\n\n      #md {{{\n             Every expression is evaluated in some specific\n             namespace.  The default namespace is called `user`.\n\n             The program can:\n\n             1. Starts a new namespace.\n             2. Switch the current namespace to an existing namespace.\n          }}}\n\n      #md {{{\n             When we specify a symbol, we can:\n\n             1. Specify the symbol by its name, e.g. `x`.  In this case, we implicitly\n             refer to the symbol in the _current_ namespace, e.g. `user/x`.\n\n             2. Specify the symbol by its fully quantified name in the form of\n             _namespace_/_symbol_.  For example,\n             `clojure.string/join`.  The slash `/` is used to separate the\n             ns name from the symbol name.\n          }}}\n); page\n\n(page (:h1 \"Defining new namespace\")\n      #md {{{\n             Clojure uses \n             \n             ```clojure\n             (ns \u003cnamespace\u003e)\n             ``` \n             \n             form switch to _namespace_, and creates\n             a new one if it doesn\u0027t already exist.\n          }}}\n\n      #md {{{\n            Try out the following:\n\n            ```clojure\n            (ns nice)\n            (def message \"Hi, I am your friend.\")\n\n            (ns rude)\n            (def message \"Yo, I don\u0027t know you.\")\n\n            (ns real-world)\n            (println nice/message)\n            (println rude/message)\n            ```\n          }}}\n); page\n\n(page (:h1 \"Organizing projects into files\")\n      #md {{{\n            Clojure encourages each file to define its\n            own namespace.\n\n            ```clojure\n            ; somewhere in CLASSPATH\n            |\n            +- communication\n               |\n               +- message.clj\n               |  +----------------------------+\n               |  | (ns communication.message) |\n               |  | (def greeting ...)         |\n               |  | (def hello ...)            |\n               |  | ...                        |\n               |  +----------------------------+\n               |\n               +- crypto.clj\n                  +----------------------------+\n                  | (ns communication.crypto)  |\n                  | (defn encrypt [message]    |\n                  |   ...)                     |\n                  | (defn decrypt [code]       |\n                  |   ...)                     |\n                  +----------------------------+\n            ```\n          }}}\n\n      (row 8 4\n        (code :clojure\n              :sm\n              {{{\n                 ;; main.clj\n                 (ns main)\n                 (require \u0027communication.message)\n                 (require \u0027communication.crypto)\n\n                 (let [message (str communication.message/greeting\n                                    \"Albert Einstein\")]\n                   (println (communication.crypto/encrypt message)))\n              }}}\n        ); code\n        #md {{{\n              An application that makes use\n              of the two namespaces and their symbols.\n            }}}\n      ); row\n\n      (row 8 4\n           (code :clojure\n                 :sm\n                 {{{\n                    ;; main.clj\n                    (ns main)\n                    (use \u0027communication.message)\n                    (use \u0027communication.crypto)\n\n                    (let [message (str greeting \"Albert Einstein\")]\n                      (println (encrypt message)))\n                 }}})\n           #md {{{\n                  - **Pro**:\n                    \u003e Succinct code which is easier to understand.\n                  - **Con**:\n                    \u003e Lack of the benefits of using namespaces.\n                    \u003e Application symbols are polluted by\n                    \u003e symbols in the dependent namespaces.\n               }}})\n\n      (row 8 4\n           (code :clojure\n                 :sm\n                 {{{\n                    ;; main.clj\n                    (ns main)\n                    (require \u0027[communication.message :as m])\n                    (require \u0027[communication.crypto :refer [encrypt]])\n\n                    (let [greeting (str m/greeting \"Albert Einstein\")]\n                      (println (encrypt greeting)))\n                 }}})\n          #md {{{\n                 - Line 4 imports the symbol `encrypt` into\n                 the `main` namespace.\n                 - Line 3 requires the namespace `communcation.message`\n                 with an alias of `m`.\n                 - Line 6 can have a symbol `greeting` in the `main` namespace.\n                 It does not conflict with `m/greeting`.\n              }}})\n\n      (row 8 4\n           (code :clojure\n                 :sm\n                 {{{\n                    ;; main.clj\n                    (ns main\n                      (:require \n                        [communication.message :as m] \n                        [communication.crypto :refer [encrypt]]))\n                    (let [greeting (str m/message \"Albert Einstein\")]\n                      (println (encrypt greeting)))\n                  }}})\n           #md {{{\n                  The recommended (and most common) way of using\n                  other libraries is to specify the required\n                  namespaces as part of the declaration of the\n                  current namespace.\n               }}})\n); page\n\n(slide #md {{{\n              # Summary\n\n              ---\n\n              - A namespace is _just_ a top-level scope.\n\n\n              - The standard is to have each file as a separate namespace.\n\n\n              - We can access symbols from other namespaces by\n              `(require ...)`.\n\n              ---\n              \n              *Note*:\n\n              \u003e Clojure does not suppose cyclic namespace dependencies.\n           }}})\n", "istop": false, "path": "2-Clojure/5-clojure-projects"}, "2-Clojure/6-oop": {"children": [], "content": "{:title \"Code Organization and Object-oriented Programming\"\n :status :done\n :summary #md {{{\n                 We examine the part of the Clojure language that supports \n                 polymorphism and a version of object-oriented\n                 programming.  Using features such as _protocols_,\n                 _types_ and _multimethods_, Clojure allows one to maximize\n                 code reusability, and solves the _expression problem_.\n              }}}}\n\n(page #md {{{\n             This unit is based on Chapter 13 of\n             [_Clojure for the Brave and True_](https://www.braveclojure.com/multimethods-records-protocols/).\n          }}})\n\n(:h1 \"Polymorphism\")\n\n(page (:h1 \"The need for polymorphism\")\n\n      (row 6 6\n           #md {{{ \n                  Consider the code.  \n                  We expect the two function calls return different \n                  type of sound.\n\n                  Note, the `louder` function relies on the fact\n                  that `make-noise` works with different types\n                  of animals.\n               }}}\n           (code :clojure\n                 {{{\n                    (def duck ...)\n                    (def dog ...)\n\n                    (make-noise duck)\n                    (make-noise dog)\n\n                    (defn louder [animal]\n                      (make-noise animal)\n                      (make-noise animal))\n\n                    (louder duck)\n                    (louder dog)\n                 }}}))\n      (row 5 7\n           (:div #md {{{\n                        But functional programming is very strict about\n                        functions being _pure_.\n\n                        The symbol `make-noise` is bound to a function that\n                        needs to take care of both ducks and dogs.\n\n                        Who owns the code for `make-noise`?\n\n                        - Bird expert\n                        - Mammal expert\n                     }}}\n                 #md {{{\n                        What if an amphibian expert would like to extend\n                        the `make-noise` function, she would need to share the\n                        ownership of the code.\n                     }}})\n           (code :clojure\n                 {{{\n                    ;; Assume that animals are hash-maps\n                    (defn get-species [animal]\n                      (get animal :species))\n\n                    (defn make-noise [animal]\n                      (case (get-species animal)\n                        :duck (str \"Quack quack, \"\n                                   (get-name animal))\n                        :dog (str \"Woof woof, \"\n                                  (get-name animal))\n                        nil))\n                 }}}))\n\n      (row 4 8\n           #md {{{\n                  How do we decouple the shared responsibility?\n\n                  We can try to make three functions.  But this \n                  make the code messy, and the functions less\n                  reusable.\n\n                  You can see that `louder` is still doing\n                  a case-by-case computation.\n               }}}\n           (code :clojure\n                 :no-nu\n                 :sm\n                 {{{\n                    (defn make-noise-duck [duck] \n                      (str \"Quack quack\" (get-name duck) )\n                    (defn make-noise-dog [dog] \n                      (str \"Woof woof\" (get-name dog))\n\n                    (defn louder [animal]\n                      (case (get-species animal)\n                        :duck (do (make-noise-duck animal)\n                                  (make-noise-duck animal))\n                        :dog (do (make-noise-dog animal)\n                                 (make-noise-dog animal))\n                        nil))\n                 }}}))\n      ); page\n(page (:h1 \"Solution: Polymorphism\")\n\n      #md {{{\n             **Definition**: _Polymorphism_\n\n             \u003e We say that a programming language that supports _polymorphism_\n             if it is possible to bind **multiple** functions to\n             the _same_ symbol.  \n             \u003e\n             \u003e The binding is determined during function application by\n             \u003e the arguments of the function.\n          }}}\n\n      #md {{{\n             Clojure supports polymorphism.  In fact, Clojure has several\n             mechanisms to achieve polymorphism.\n\n             - Multimethods\n             - Protocols\n          }}}\n\n      (:h2 \"Benefitting from polymorphism\")\n\n      #md {{{\n             We can revisit the `make-noise` example.\n          }}}\n      (row 6 6\n           #md {{{\n                  Different biology experts can define their own\n                  functions, and they will all bind to the _same_\n                  symbol `make-noise`.\n               }}}\n           (err (:div\n                  (code :clojure :sm \n                       {{{ \n                          ;; Bird expert \n                          (defn make-noise \n                            [animal] \n                            (str \"Chirp chirp, \"\n                                 (get-name animal)))\n                       }}})\n                  (code :clojure :sm\n                        {{{\n                           ;; Mammal expert\n                          (defn make-noise \n                            [animal] \n                            (str \"Woof woof\"\n                                 (get-name animal)))\n                        }}})\n                  (code :clojure :sm\n                        {{{\n                           ;; This will magically resolve to the\n                           ;; right fn that is bound to make-noise\n                           (defn louder [animal]\n                             (do (make-noise animal)\n                                 (make-noise animal)))\n                        }}})\n                  )))\n      ); page\n\n(:h1 \"Multimethods\")\n\n(page (:h1 \"Getting started with multimethods\")\n      #md {{{\n             **Definition**: _multimethod_\n\n             \u003e A multimethod is a special symbol that\n             can be bound to more than one function values.\n             \u003e The symbol\u0027s binding is resolved during\n             function invocation.\n          }}}\n\n      #md {{{\n            To setup a multimethod, we need to do two things:\n\n            1. Declare a symbol to be a multimethod so that\n            it can be bound to multiple functions, and\n\n            2. A function that helps us to dynamically dispatch\n            the correct binding during function invocation.\n          }}}\n\n      (row 6 6\n           #md {{{\n                  Declare `make-noise` as a multimethod\n\n                  Note that we have to specify the dispatcher\n                  which computes a dispatching token\n                  based on the _first_ argument.\n               }}}\n           (code :clojure :no-nu :sm\n                 {{{\n                    (defmulti make-noise get-species)\n                 }}})\n           ); row\n\n      (row 6 6\n           #md {{{\n                  Now, different authors can contribute\n                  different functions, all of them can be bound\n                  to the symbol `make-noise` using `(defmethod ...)`.\n               }}}\n           (:div (code :clojure :no-nu :sm \n                       {{{\n                          (defmethod make-noise :duck\n                            [animal]\n                            \"Quack quack\")\n                       }}})\n                 (code :clojure :no-nu :sm\n                       {{{\n                          (defmethod make-noise :dog\n                            [animal]\n                            \"Woof woof\")\n                       }}})\n                 (code :clojure :no-nu :sm\n                       {{{\n                          (defmethod make-noise :default\n                            [animal]\n                            \"???\")\n                       }}}))\n           ); row\n\n      #md {{{\n             Have we solved the \"problem\"?\n\n             \u003e Yes.\n             \u003e\n             \u003e - Each expert works on their own `defmethod make-noise \u003cdispatch-token\u003e ...`\n             \u003e\n             \u003e - The dispatch function does not need to be updated for new\n             \u003e species.\n          }}}\n      ); page\n\n(:h1 \"Protocols\")\n\n(page (:h1 \"Why protocols?\")\n\n      #md {{{\n             In the previous example, we have different _types_ of data:\n             `duck`, `dog`, and possibly others.\n\n             From a function point of view, `make-noise` needs to perform\n             different computations for each type.\n          }}}\n\n      #md {{{\n             What if we have many other functions, all of which need to\n             perform species specific computations?\n\n             E.g.\n\n             - `(has-fur? animal)`\n             - `(get-name animal)`\n             - `(can-find? animal continent)`\n             - ...\n          }}}\n\n      (--*--)\n\n      #md {{{\n             It looks like there is a collection of functions shared\n             by the different species of animals.\n\n             - `(make-noise animal)`\n             - `(has-fur? animal)`\n             - `(get-name animal)`\n             - `(can-find? animal continent)`\n          }}}\n      #md {{{\n             We need to define a protocol.\n          }}}\n      )\n\n(page (:h1 \"Getting started with protocols\")\n      (row 6 6\n           (:div #md {{{\n                        Protocol is just a collection of\n                        function symbols.\n\n                        The symbols are _all_ polymorphic,\n                        so their binding will be dynamically dispatched\n                        depending on the _first_ argument.\n                        }}}\n                 #md {{{\n                        - Protocols have name.\n                        - They have a collection of function declarations.\n                        }}})\n           (code :clojure :no-nu\n                 {{{\n                    (defprotocol Animal\n                      (make-noise [x])\n                      (has-fur? [x])\n                      (can-find? [x continent]))\n                 }}}))\n\n      (:h2 \"Abstraction, Implementation and Instances\")\n\n      (box\n        #md {{{\n               *Abstraction*\n\n               \u003e Abstraction refers to some high-level description\n               \u003e of functions\n               \u003e that does not include any code-level details\n               \u003e of how such functions work.\n            }}}\n\n        #md {{{\n               Protocols are abstractions.\n            }}})\n\n      (box\n        #md {{{\n              *Implementation*\n\n              \u003e An implementation is the code that\n              conforms to some abstraction, but also has\n              all the necessary details to describe how\n              the functions work.\n              }}}\n        #md {{{\n              Clojure supports implementation with\n              _records_.\n              }}})\n\n      (box\n        #md {{{\n               *Instances*\n\n               \u003e Instances are data objects which are\n               created at run-time, and enjoys the\n               functionalities provided by some\n               implementation of some abstraction.\n               }}}\n        #md {{{\n               Clojure supports instances by record constructors\n               and also by a special feature known as `reify`.\n               }}})\n      ); page\n\n(:h1 \"Records\")\n\n(page (:h1 \"Getting started with records\")\n      #md {{{\n             **Definition**: _records_\n\n             \u003e Clojure record is a map-like type declaration which\n             \u003e comes with record constructor function\n             \u003e and optionally can serve as an implementation\n             \u003e of an existing protocol.\n             }}}\n\n      (:h2 \"Declaration and construction\")\n\n      (row 6 6\n           #md {{{\n                  A record type is declared by\n                  the `(defrecord ...)` form.\n\n                  It creates the symbol binding\n                  to constructor functions.\n                  }}}\n           (code :clojure :no-nu :sm\n                 {{{\n                    (defrecord Bird [species color])\n\n                    (-\u003eBird \"duck\" :brown)\n\n                    (map-\u003eBird {:species \"duck\"\n                                :color :brown})\n                 }}}))\n\n      (:h2 \"Accessing records\")\n      (row 6 6\n           #md {{{\n                  The constructed record instances\n                  acts like hash-maps.\n                  }}}\n           (code :clojure :no-nu :sm\n                 {{{\n                    (def my-pet (-\u003eBird \"parrot\" :yellow))\n\n                    (:species my-pet)\n\n                    (get my-pet :species)\n                    }}}))\n      ); page\n\n(page (:h1 \"Records as implementations\")\n\n      #md {{{\n             Clojure records can serve as implementations, and \n             there are several ways to make a record type\n             into an implementation of a protocol.\n             }}}\n\n      #md {{{\n             Any implementation of a protocol necessarily needs to\n             provide the body of all the functions declared\n             in the protocol.\n             }}}\n\n      (:h2 \"Declare records as implementation\")\n\n      (row 6 6\n           #md {{{\n                  We can provide the implementation as _part_\n                  of the declaration of the record.\n                  }}}\n           (:div\n             (code :clojure :no-nu :sm\n                   {{{\n                      (defprotocol Animal\n                        (make-noise [this])\n                        (get-name [this]))\n                      }}})\n             (code :clojure :no-nu :sm\n                   {{{\n                      (defrecord Bird [species color]\n                        Animal\n                        (make-noise [bird]\n                          (str \"Chirp, chirp...\"\n                               (:species bird)))\n                        (get-name [bird]\n                          (str \"A\" \n                               (:color bird) \n                               \" \"\n                               (:species bird))))\n                      }}})\n             (code :clojure :no-nu :sm\n                   {{{\n                      (get-name (-\u003eBird \"parrot\" :yellow))\n                      }}})))\n\n      (:h2 \"Make record type into an implementation\")\n\n      (row 6 6\n           #md {{{\n                  Even if the record type and the protocol have been\n                  declared independently, we can still ad-hoc\n                  make the record type into an implementation.\n                  }}}\n           (:div\n             (code :clojure :no-nu\n                   {{{\n                      (defrecord Bird [species color])\n                      }}})\n             \"...\"\n             (code :clojure :no-nu\n                   {{{\n                      (extend-type Bird\n                        Animal\n                        (make-noise [bird]\n                          (str \"Chirp, chirp...\"\n                               (:species bird)))\n                        (get-name [bird]\n                          (str \"A\" \n                               (:color bird) \n                               \" \"\n                               (:species bird))))\n                      }}})))\n\n      (:h2 \"Back to polymorphism...\")\n\n      (row 5 7\n           (code :clojure :no-nu :sm\n                 {{{\n                    (defprotocol Animal\n                      (make-noise [x])\n                      (get-name [x]))\n\n                    (defn louder [x]\n                      (str (make-noise x)\n                           (make-noise x)))\n                    }}})\n           (:div\n             (code :clojure :no-nu :sm\n                   {{{\n                      (defrecord Bird [species color]\n                        Animal\n                        (make-noise [bird]\n                          (str \"Chirp, chirp...\" (:species bird)))\n                        (get-name [bird]\n                          (str \"A\" (:color bird) (:species bird))))\n                      }}})\n             (code :clojure :no-nu :sm\n                   {{{\n                      (defrecord Dog [name])\n                      }}})\n             (code :clojure :no-nu :sm\n                   {{{\n                      (extend-type Dog Animal\n                        (make-noise [dog] \"Woof, woof...\")\n                        (get-name [dog] (:name dog)))\n                      }}})\n             #md {{{\n                    All instances of _Bird_ and _Dog_\n                    records can be processed by\n                    _Animal_ functions.\n                    The correct implementation will be used.\n                    }}}\n             (code :clojure :no-nu :sm\n                   {{{\n                      (let [pet (-\u003eBird \"parrot\" :yellow)]\n                        (println (make-noise pet))\n                        (println (louder pet)))\n\n                      (let [pet (-\u003eDog \"Lassie\")]\n                        (println (make-noise pet))\n                        (println (louder pet)))\n                      }}}))\n           ); row\n      ); page\n\n(:h1 \"Implementation Without Types\")\n\n(page (:h1 \"Why not implementation type?\")\n      #md {{{\n             The reason we declare a record type\n             (e.g. _Bird_) is because we may construct many\n             _Bird_ instances.  All of them will be instances\n             of the protocol _Animal_.\n             }}}\n\n      #md {{{\n             What if we have an object that is so unique that\n             it\u0027s the only member of its kind?\n             }}}\n\n      #md {{{\n             We can describe the object as a Clojure data,\n             and then _bless_ it with the implementing functions\n             of a given protocol.\n             }}}\n\n      (row 6 6\n           #md {{{\n                  To understand how we create an instance of _Animal_,\n                  let\u0027s consider how we can create a _single_ function\n                  using **closure**\n                  }}}\n           (:div\n             (code :clojure :no-nu :sm\n                   {{{\n                      (def robo-make-noise\n                        (let [robot {:power-level \"1500 MW\"\n                                     :frequency   \"90 MHz\"}]\n                          (fn []\n                            (str \"Zzzz....zzzz... @ \" \n                                 (:frequency robot)))))\n                      }}})\n             (code :clojure :no-nu :sm\n                   {{{\n                      (robo-make-noise)\n                      ;; =\u003e \"Zzzz....zzzz... @ 90 MHz\"\n                      }}})))\n\n      #md {{{\n             **Q**: _Can we `robot` into an instance of Animal_?\n\n             \u003e Yes, Clojure has a mechanism called `reify`.\n             }}}\n      ); page\n\n(page (:h1 \"Reify\")\n\n      (rows 6 6\n           #md {{{\n                  The _Animal_ protocol has many functions\n                  to be implemented.\n                  }}}\n           (code :clojure :no-nu :sm\n                 {{{\n                    (defprotocol Animal\n                      (make-noise [x])\n                      (has-fur? [x])\n                      (can-find? [x continent]))\n                    }}})\n\n           #md {{{\n                  Reify allows as to build an express\n                  that is an instance of a protocol.\n\n                  - We need to provide the implementation\n                  for every function in the protocol.\n\n                  - The function signature (number of arguments)\n                  must be consistent with the protocol declaration.\n\n                  - There is a _catch_ on _recursion_.\n                    https://clojuredocs.org/clojure.core/reify\n                  }}}\n           (code :clojure :no-nu :sm\n                 {{{\n                    (reify Animal\n                      (make-noise [x] \n                        \"Hello, I am a person\")\n                      (has-fur? [x] false)\n                      (can-find? [x continent]\n                        (not= continent \"Antarctic\")))\n                    }}})\n           #md {{{\n                  To convert a hash-map (`robot`) to an Animal\n                  instance, we make use of _closure_.\n                  }}}\n           (code :clojure :no-nu :sm\n                 {{{\n                   (let [robot {:power-level \"1500 MW\"\n                                 :frequency   \"90 MHz\"}]\n                      (reify Animal\n                        (make-noise [x]\n                          (str \"Zzzz.... zzzz....\" \n                               (:frequency robot)))\n                        (has-fur? [x] \n                          (\u003c (:power-level robot) \"1600\"))\n                        (can-find? [x c]\n                          (= c \"North America\"))))\n                    }}})\n           )\n\n      #md {{{\n             Here is a complete example:\n             }}}\n      (rows 12\n        (code :clojure\n              {{{\n                 (defn make-robot-as-animal\n                   [pwr freq]\n                   (reify Animal\n                     (make-noise [_] ...)\n                     (has-fur? [_] ...)\n                     (can-find? [_ c] (= c \"North America\"))))\n                 }}})\n        (code :clojure\n              {{{\n                 (make-noise (make-robot-as-animal \"2000W\" \"30Hz\"))\n                 (make-noise (-\u003eBird \"parrot\" :yellow))\n                 }}}))\n      ); page\n\n(page (:h1 \"Summary\")\n      (row 4 4 4\n      #md {{{\n             *Abstract*:\n\n             \u003e Abstraction is the description of a data type based\n             on the set of functions that can act on the instances\n             of that type.\n             \u003e\n             \u003e Clojure supports _abstraction_ by _protocols_.\n          }}}\n      #md {{{\n             *Implementation*:\n\n             \u003e An implementation of an abstraction is a concrete type\n             that provides the implementing code for all the functions.\n             \u003e\n             \u003e Clojure supports _implementation_ by _records_ and _extend-type_.\n             }}}\n      #md {{{\n             *Instances*\n\n             \u003e An instance of a protocol is a data value that can be\n             used as the argument of functions of the protocol.\n             \u003e\n             \u003e Instances of records are instances of the protocol.\n             \u003e\n             \u003e Also, Clojure can create instances without types using\n             the _reify_ construct.\n             }}}\n          ))\n", "istop": false, "path": "2-Clojure/6-oop"}, "2-Clojure/7-macros": {"children": [], "content": "{:title \"Readers, Macros \u0026 Eval\"\n :status :done\n :summary #md {{{\n                 We will be discuss some unique language features of\n                 Lisp and Clojure in particular.  We cover the entire\n                 life cycle of Lisp code, and the significance of\n                 the concept of _code as data_, also known as\n                 the _homoiconic_ property.  Finally, we look at\n                 the incredible possibility of Lisp code extending\n                 the Lisp language through the mechanism of _macros_.\n              }}}}\n\n(page (:h1 \"The s-expressions\")\n\n      (rows :sep 4 8\n            (:h2 \"What are they?\")\n            #md {{{\n                  The _s-expressions_ are strings that represent nested lists.\n\n                  Here are some examples:\n\n                  - `()`\n                  - `(1 2 3)`\n                  - `(1 (2 3))`\n\n                  The parenthesis marks the boundaries of the lists,\n                  and the elements of a list is either\n\n                  1. an atom\n                  2. or another list\n\n                }}}\n\n            (:h2 \"The entire language\")\n            (code {{{\n                     s-expr: (elem*)\n                     elem  : atom | s-expr\n                     }}})\n\n            (:h2 \"The atoms of s-expressions\")\n\n            #md {{{\n                  An atom is a considered a scalar value.  In the context of\n                  programming languages, we may be interested in the following types\n                  of atoms:\n\n                  - Numeric constants: `42`, `3.1415f`, `1.2E10`.\n                  - Strings: `\"hello world\"`\n                  - Symbols: `cosine`, `x`, `auth/login-callback`\n                }}}\n            ); rows\n); page\n\n(page (:h1 \"Encoding data with s-expressions\")\n\n      (rows :sep 4 8\n            (:h2 \"Universality of s-expressions\")\n            #md {{{\n                  Despite the simplicity of the structure of s-expressions,\n                  the expressiveness of s-expressions is **universal**:\n\n                  - C/C++/Java/Javascript can be encoded as s-expression.\n                  - XML can be encoded as s-expressions.\n                  - JSON can be encoded as s-expressions.\n                  - HTML/CSS can be encoded as s-expressions.\n                }}}\n\n            (:h2 \"Encoding programming languages\")\n            (:div (code :python\n                       :sm\n                       :no-nu\n                   {{{\n                      def factorial(n):\n                        if n \u003c= 1:\n                          return n\n                        else:\n                          return n * factorial(n-1)\n\n                      print factorial(100)\n                   }}})\n                   (:i.fa.fa-long-arrow-down)\n                   (code :clojure\n                         :sm\n                         :no-nu\n                     {{{\n                        (my-program\n\n                          (def factorial (n)\n                            (if (n \u003c= 1)\n                              (return n)\n                              (return (n * (call factorial (n - 1))))))\n\n                          (call factorial 100))\n                     }}}))\n\n              (:h2 \"Encoding markup languages\")\n              (:div\n                   (code {:lang \"xml\"\n                          :sm true\n                          :no-nu true}\n                         {{{\n                            \u003cPerson id=\"1234\"\u003e\n                              \u003cname\u003eAlbert Einstein\u003c/name\u003e\n                              \u003cprofession\u003ePhysicist\u003c/profession\u003e\n                            \u003c/Persion\u003e\n                         }}})\n                   (:i.fa.fa-long-arrow-down)\n                   (code :clojure :sm :no-nu\n                         {{{\n                            (person\n                              (:id \"1234\")\n                              (:name \"Albert Einstein\")\n                              (:profession \"Physicist\"))\n                         }}}))\n\n              (:h2 \"Encoding cascade style-sheet\")\n              (:div\n                 (code {:lang \"css\" :sm 1 :no-nu 1}\n                       {{{\n                          body: {\n                            font-family: Helvetica;\n                            margin: 10px 0;\n                            background: transparent;\n                          }\n                       }}})\n                 (:i.fa.fa-long-arrow-down)\n                 (code :clojure :sm :no-nu\n                       {{{\n                          ;; This encoding requires that\n                          ;; the second element of (body ...) list\n                          ;; be a list containing even number of atoms.\n\n                          (body (font-family \"Helvetica\"\n                                 margin      (10 0)\n                                 background  :transparent))\n                       }}}))\n              ); rows\n); page\n\n(page (box #md {{{\n                  # Important observation:\n\n                  \u003e s-expressions are the simpliest text encoding\n                  of trees of atoms.\n               }}})\n); page\n\n(page (:h1 \"Clojure extends s-expressions\")\n\n      (rows :sep 4 8\n\n            (:h2 \"Extensions to s-expressions\")\n            #md {{{\n                  - Sets: `#{...} = (set ...)`\n                  - Vectors: `[...] = (vector ...)`\n                  - Maps: `{...} = (hash-map ...)`\n                  - Regular expressions: `#\"...\" = (re-pattern \"...\")`\n                  - Anonymous functions: `#(...) = (fn [%] ...)`\n\n                  But as you can see, the syntactic extensions are all\n                  applications of constructor functions.\n                }}}\n            ); rows\n); page\n\n(page (:h1 \"The reader\")\n      #md {{{\n            99.9% of the programs starts as a text file as _source code_.\n\n            Source code syntax can be rather arbitrary: C vs Python vs Clojure.\n            }}}\n\n      (rows :sep 4 8\n           #md {{{ \n                  The syntax is largely divided into two components:\n                  }}}\n\n           #md {{{\n              1. Description of computation:\n\n                ```python\n                # Computation in Python\n                for i in range(10):\n                  print i\n                ```\n              2. Description of data:\n\n                ```python\n                # Data in Python\n                {\"name\": \"Albert Einstein\"\n                 \"occupation\": \"Physicist\"}\n                ```\n                }}}\n\n          (:h2 \"Syntax of languages\")\n          (:div\n              #md {{{\n                      `$$\\mathrm{Syntax}^L = \\mathrm{Syntax}^L_\\mathrm{computation} \\cup\n                                      \\mathrm{Syntax}^L_\\mathrm{data}$$`\n                  }}}\n              (note :small\n              #md {{{\n                     Actual grammar of practical languages cannot be decoupled\n                     so easily as most likely, `$\\mathrm{Syntax}^L_\\mathrm{computation}$`\n                     relies some rules from `$\\mathrm{Syntax}^L_\\mathrm{data}$`, and vice versa.\n                  }}}))\n\n          (:h2 \"Homoiconic languages and Lisp\")\n          (:div \n            (box #md {{{\n                      _Definition_:\n\n                      A language $L$ is _homoiconic_ if its syntax has the following property:\n\n                      $$ \\mathrm{Syntax}^L_\\mathrm{data} \\supseteq \\mathrm{Syntax}^L $$\n                   }}})\n            (box #md {{{\n                        _Theorem_:\n\n                        Clojure is homoiconic.  All Lisp based languages are homoiconic.\n                     }}}))\n          ); rows\n      ); page\n\n\n(page (:h1 \"Reader\")\n\n      #md {{{\n            A reader of a language $L$ is a _program_ that performs the following:\n            $$\\mathrm{reader}: \\mathrm{Syntax}^L \\to \\mathrm{SExpression}$$\n            }}}\n\n      #md {{{\n            We have anecdotal evidence that s-expressions can express\n            both computation as well as data.  Thus, we can be certain\n            that _any_ programming syntax can be converted to s-expressions by\n            a reader.\n          }}}\n\n      (note #md {{{\n                   Many Lisp-based programs (Common Lisp, and Racket) allow one\n                   to program the _reader_ as a program in the respective Lisp\n                   itself.\n\n                   Clojure does not provide a programmable reader.\n                }}})\n); page\n\n(page (:h1 \"Macros\")\n\n      (rows :sep 4 8\n            (:h2 \"The three magics of Lisp\")\n            #md {{{\n                  1. Choosing s-expressions as the canonical representation of its programs.\n\n                  2. Uses a reader to convert extensions of s-expression to s-expressions.\n                  This ensures that one can have a more visually appealing source code.\n\n                  3. The output of the reader goes through a _macro expansion_ phase before\n                  compilation and run-time execution.\n\n                    $$\\mathrm{Syntax}^L\\overset{\\mathrm{reader}}{\\longrightarrow} \n                      \\mathrm{SExpression} \\overset{\\mathrm{macro}}\\longrightarrow\n                      \\mathrm{Executable\\ SExpression}$$\n\n                }}}\n\n            (:h2 \"Macro expansion\")\n            (:div \n              #md {{{\n                  The reader is only responsible for producing s-expressions\n                  from the syntax of the language.  The s-expressions may not be\n                  the final program.  In fact, it may not even be invalid for execution.\n                  }}}\n              \n              #md {{{\n                  Consider a s-expression in the program _after reader_.\n                  ```\n                  (e1 e2 ...)\n                  ```\n                  }}}\n\n              #md {{{\n                  If `e1` is a symbol, and it\u0027s a _macro_, then\n                  `(e1 e2 ...)` is evaluated during the expansion phase.  Let `r` be\n                  the resulting value of the evaluation.\n\n                  ```\n                  (e1 e1 ...)     ===\u003e   r\n                  ```\n                }}})\n            ); rows\n      ); page\n\n(page (:h1 \"Macros in Clojure\")\n\n      (rows :sep 4 8\n            (:h2 \"Macros are functions\")\n            (:div \n              #md {{{\n                   A _macro_ is a function.  It\u0027s bound to a symbol, say `mac`.\n                   It\u0027s defined by \n                   \n                   ```clojure\n                   (defmacro mac [...] ...)\n                   ```\n                   }}}\n\n              #md {{{\n\n                   It can be used like a function:\n\n                   ```clojure\n                   (mac ...)\n                   ```\n                   }}}\n              #md {{{\n\n                   Clojure compiler will evaluate the function application\n                   `(mac ...)` at *compile time*.  The result is the code\n                   that will be executed at runtime.\n                }}})\n\n            (:h2 \"Simple macros\") \n            (:div \n              #md {{{\n                    A macro is just a function that:\n\n                    1. Takes arbitrary input, but produces *valid* executable\n                    programs in Clojure\u0027s extended s-expression.\n\n                    2. Any applications of this function shall be evaluated\n                    at compile-time.\n                    }}}\n              #md {{{\n                    Given\n\n                    ```clojure\n                    (defmacro \u003cname\u003e [...]\n                      \u003cbody\u003e)\n                    ```\n\n                    The body of the macro is **any** code in Clojure, and can use\n                    any libraries and data structures you wish -- \n                    including other macros..\n\n                    \u003e Truly, Lisp is used to extend Lisp.\n                  }}})\n            ); rows\n\n      #md {{{\n             Here is an example.\n             }}}\n      (row 6 6\n           (code :clojure\n                 :no-nu\n                 {{{\n                    (defmacro print-eval \n                      [expr]\n                      (list \u0027do\n                            (list \u0027println (str expr))\n                            (list \u0027println \"=\u003e\" expr)))\n                 }}})\n           #md {{{\n                  - `defmacro` declares a **function** just like\n                  `defun`.  But evaluation of macros happen at compile time.\n                  - The input `expr` is a **list**, not the value\n                  after evaluation.\n                  - Try to manually compute the result of\n                  `(print-eval (+ 1 1))` during **compile time**.\n               }}})\n      ); page\n\n(page (:h1 \"Digression: language features on lists\")\n\n      (note #md {{{\n                   1. The discussion here is for _general purpose_ programming.\n\n                   2. However, keep in mind that these features are primarily\n                   available to support macro programming.\n                }}})\n\n      (rows :sep 4 8\n            (:h2 \"Quotes vs syntax quotes\")\n            (:div \n              #md {{{\n                    We have seen quotes a few times now.  It starts with the single quote character followed\n                    by any expression.\n\n                    ```clojure\n                    (+ 1 2 3)\n                    ;; =\u003e 6\n\n                    \u0027(+ 1 2 3)\n                    ;; =\u003e (+ 1 2 3)\n\n                    `(f 1 2 (g :a :b))\n                    ;; =\u003e (f 1 2 (g :a :b))\n                    ```\n                    \u003e Quotes suppress function evaluation. Its effect applies to nested lists.\n                    }}})\n\n\n              #md {{{\n                    Syntax quote uses backtick character \u003cspan style=\"font-size:200%;font-weight:bold;border:thin solid black\"\u003e\\`\u003c/span\u003e\n                  }}}\n              (image \"backtick.png\")\n\n              (:h2 \"Syntax quote\")\n              #md {{{\n                  The syntax quote also surppresses any function evaluations, but\n                  it does a few additional transformations to the quoted expression.\n\n                  - Symbols are resolved to their fully namespace-qualified names.\n                  - Evalues expressions that are unquoted or sliceing-unquoted.\n                  - Generate symbols that ends with `#`.\n                  }}}\n\n              (:h2 \"Examples of syntax quotes\")\n              #md {{{\n                   ```clojure\n                   `(+ 1 2 3)\n                   ;; =\u003e (clojure.core/+ 1 2 3)\n\n                   `(+ 1 2 (inc 2))\n                   ;; =\u003e (clojure.core/+ 1 2 (clojure.core/inc 2))\n\n                   `(+ 1 2 ~(inc 2))\n                   ;; =\u003e (clojure.core/+ 1 2 3)\n\n                   `(+ ~@(map inc (range 3)))\n                   ;; =\u003e (clojure.core/+ 1 2 3)\n                   ```\n                 }}}\n              ); rows\n); page\n\n(page (:h1 \"Macro Programming in Clojure: Code Template\")\n      #md {{{\n            Let\u0027s see how the language features we have discussed\n            help us to better write Clojure macros.\n            }}}\n\n      (rows :sep 6 6\n            #md {{{\n                   Here is a badly written macro:\n\n                   - It\u0027s difficult to understand the template.\n                   - It\u0027s difficult to debug and maintain.\n                   }}}\n            (code :clojure\n                  {{{\n                  (defmacro print-eval \n                    [expr]\n                    (list \u0027do\n                          (list \u0027println (str expr))\n                          (list \u0027println \"=\u003e\" expr)))\n                  }}})\n\n\n            #md {{{\n                   We can rewrite it using\n                   syntax quotes.\n\n                   \u003e - It\u0027s clear what the generated code will look like.\n                   \u003e - It\u0027s also clear that there are two _evals_ that will\n                   \u003e   occur during compilation.  \n                   }}}\n            (:div \n              (code :clojure\n                  {{{\n                  (defmacro print-eval\n                    [expr]\n                    `(do\n                       (println ~(str expr))\n                       (println \"=\u003e\" ~expr)))\n                  }}})\n              #md {{{\n                   Features used:\n\n                    \u003e   - The first `~(str expr)` will\n                    \u003e   construct the string representation of `expr`.\n                    \u003e   - The second `~expr` places the value of expr (as a s-express)\n                    \u003e   in place of `(println \"=\u003e\" ___)`.\n                   }}})\n            ); rows\n\n      (:h2 \"A better print-eval macro\")\n\n      #md {{{\n            Let\u0027s generalize `print-eval` to support multiple expressions.\n\n            The effect we want is the following:\n\n            ```clojure\n            (print-eval (+ 1 2 3)\n                        (+ 1 (inc 1)))\n            ; Expression #1\n            ; (+ 1 2 3)\n            ; =\u003e 6\n            ; Expression #2\n            ; (+ 1 (inc 1))\n            ; =\u003e 3\n            ```\n          }}}\n\n      (rows :sep 4 8\n\n            (:h2 \"Macro signature\")\n            #md {{{\n                  First, we need change macro function signature:\n\n                  ```clojure\n                  (defmacro print-eval [\u0026 exprs] ...)\n                  ```\n                  \u003e Remember that `exprs` is a list of s-expressions.\n                }}}\n\n\n            (:h2 \"Data transformation as Clojure\")\n            #md {{{\n                  Let\u0027s see how we might achieve the Clojure code\n                  to print the expressions.\n\n                  ```clojure\n                  (for [[i expr] (map vector (range) exprs)]\n                    (println \"Expression #\" i)\n                    (println (str expr)))\n                  ```\n                }}}\n\n            (:h2 \"Data transformation as Clojure macro\")\n            #md {{{\n                   Let\u0027s turn this into macro programming with the help\n                   of syntax quoting.\n\n                   ```clojure\n                   (defmacro print-eval [\u0026 exprs]\n                     `(do\n                        ~@(for [[i expr] (map vector (range) exprs)]\n                            `(do\n                               (println \"Expressin\" ~i)\n                               (println ~(str expr))\n                               ~expr))))\n                   ```\n                   \u003e Note the usage of sliceing-unquote vs unquote.\n                }}}\n            ); rows\n      ); page\n\n(page (:h1 \"Macro Programming in Clojure: Symbol Generation\")\n      #md {{{\n            Consider a macro that is to display the result of\n            an expression multiple times.\n\n            ```clojure\n            (discuss (apply + (for [i (range 10)] (* i i))))\n\n            ; The expression (apply + (for [i (range 10)] (* i i)))\n            ; evaluates to 285, and 285 is a large number.\n            ```\n          }}}\n\n      (rows :sep 4 8\n            #md {{{\n                   # Desired generated code\n\n                   We want to generate the code that prints\n                   a message with both the expression (as s-expression code)\n                   and the result.\n                   }}}\n            (code :sm :clojure\n                  {{{\n                    (let [result expr]\n                      (println \"The expression\" (str expr)\n                               \"evaluates to\" result\n                               \", and\" result\n                               \"is a large number.\"))\n                  }}})\n\n            #md {{{\n                   This is an \u003cspan style=color:red\u003eincorrect\u003c/span\u003e\n                   implementation of the macro:\n                   }}}\n\n            (err\n              (code :clojure\n                    {{{\n                     (defmacro discuss [expr]\n                       `(let [result ~expr]\n                          (println \"The expression\" ~(str expr)\n                                   \"evaluates to\" result\n                                   \", and\" result\n                                   \"is a large number.\")))\n                    }}}))\n\n            (:h2 \"Why not?\")\n            #md {{{\n                 \u003e This will not compile because syntax quote\n                 converts all symbols to the namespace qualified names.\n                 So, it produces runtime-code fragment of:\n                 \u003e\n                 \u003e ```clojure\n                 \u003e (let [user/result ___]\n                 \u003e   (clojure.core/println ...))\n                 \u003e ```\n                 }}}\n\n\n            #md {{{\n                  ## Meet gensym\n\n                  Clojure supports dynamic generation of symbols.  The form\n                  `(gensym)` generates a **fresh** symbol (not namespace qualitified)\n                  that is guaranteed to be unused before.\n                  }}}\n            (code :clojure\n                  {{{\n                  (gensym)\n                  ;;=\u003e G__20\n                  (gensym)\n                  ;;=\u003e G__27\n                  (gensym \"x\")\n                  ;;=\u003e x30\n                  (gensym \"x\")\n                  ;;=\u003e x34\n                  ```\n                  }}})\n\n            (:h2 \"Using gensym\")\n            (:div \n              (code :clojure\n                  {{{\n                    (defmacro discuss [expr]\n                      (let [result-symb (gensym)]\n                        `(let [~result-symb ~expr]\n                           (println \"The expression\" ~(str expr)\n                                    \"evaluates to\" ~result-symb\n                                    \", and\" ~result-symb\n                                    \"is a large number.\"))))\n                    }}})\n              #md {{{\n                  \u003e Make sure that you understand the usage of unquoted `~result-symb`.\n                  }}})\n            ); rows\n\n      #md {{{\n            The need to repeatedly unquoting `result-symb` is undesirable\n            because the code template looks a bit odd.\n            }}}\n      (rows :sep 4 8\n            #md {{{\n            Syntax quoting has a nice feature:\n\n            \u003e Symbols ending with `#` will be expanded to a *consistent*\n            fresh symbol.\n            }}}\n            (code :clojure\n                  {{{\n                    `x#\n                    ;;=\u003e x__48__auto__\n\n                    `(let [x# \"hello\"]\n                       (println x#))\n                    ;;=\u003e (clojure.core/let [x__29__auto__ \"hello\"]\n                    ;;=\u003e   (clojure.core/println x__29__auto__))\n                    ```\n                  }}})\n            #md {{{\n                  So, we can rewrite `discuss` macro as follows:\n                  }}}\n            (code :clojure\n                  {{{\n                  (defmacro discuss [expr]\n                    `(let [result# ~expr]\n                       (println \"The expression\" ~(str expr)\n                                \"evalutes to\" result#\n                                \", and\" result#\n                                \"is a large number.\")))\n                  }}})\n            ); rows\n      ); page\n\n(page (:h1 \"Summary\")\n      #md {{{ \n             Reader converts syntax to s-expressions.\n             }}}\n      (--*--)\n\n      #md {{{\n         Macros are special functions in Lisp that\n         transforms certain forms in the s-expression programs\n         to executable forms.\n         }}}\n\n      (--*--)\n\n      #md {{{ \n             Clojure supports user-defined macros but not user-defined readers.\n\n              - `(defmacro ...)`\n              - Syntax quoting `` `...``\n              - Unquoting `` `(... ~...) ``\n              - Slicing-unquoting `` `(... ~@...)``\n              - Symbol generation `` `(... symb# ...)``\n          }}})\n\n", "istop": false, "path": "2-Clojure/7-macros"}, "2-Clojure/8-tools": {"children": [], "content": "{:title \"Compilation Tools\"\n :status :draft\n :summary #md {{{\n                 We introduce _Leiningen_, a project\n                 management tool to develop large scale projects.\n\n                 Leiningen helps us to:\n\n                 - Manage third-party libraries\n                 - Compile the project\n                 - Support unit tests\n                 - Provide interactive REPL-driven development\n                 }}}\n }\n\n(page (:h1 \"About\")\n\n      \n      (rows :sep 4 8\n            (:h2 \"What is leiningen?\")\n            #md {{{\n                   _Leiningen_ is a community maintained compilation tool for Clojure.\n\n                   - https://leiningen.org/\n                   - Created by Phil Hagelberg (https://github.com/technomancy)\n                   - It\u0027s over 10 years old.\n                     \u003e Very mature, and best supported compilation tool.\n                   }}}\n            (:h2 \"Why compilation tool? (1)\")\n            (:div #md {{{ \n                         Clojure supports native interoperability with Java.\n\n                         \u003e Did you know Java libraries (as .jar files) can\n                         be used by Clojure directly?\n                         }}}\n\n\n                  #md {{{\n                         Maven https://mvnrepository.com/ hosts over 10 million\n                         usable Java artifacts.\n\n                         Clojars https://clojars.org/projects hosts over 23,000\n                         pure clojure libraries.\n                         }}}\n                  #md {{{\n                         A compilation tool allows painless importing Java/clojure\n                         libraries from the Internet.\n                         }}})\n\n            (:h2 \"Why compilation tool? (2)\")\n            (:div #md {{{\n                         Running program or programs with many dependencies can be very difficult.\n\n                         - CLASSPATH\n                         - JVM start-up\n                         - program entry-point and arguments\n                         }}}\n                  #md {{{\n                         A compilation tool can help with:\n\n                         - easy execution starting at a user-specified **entry-point**.\n                         }}}\n                  )\n            (:h2 \"Why compilation tool? (3)\")\n            (:div #md {{{\n                         A project consists of _many_ files.\n\n                         - Source files across different namespaces\n                         - Various dependency libraries (as .jar files)\n                         - Resources files (such as images and text files)\n                         - Test cases\n                         - Configuration files for runtime (e.g. database credential)\n                         }}}\n                  #md {{{\n                         A compilation tool standardizes the project layout\n                         and helps to generate a bundle which is more portable\n                         for deployment.\n                         }}}\n                  )\n\n            (:h2 \"Why compilation tools? (4)\")\n            (:div #md {{{\n                         As the language grows, and more libraries become available\n                         to extend the language, we want more and more toolchains\n                         for specialized workflow.\n\n                         E.g. web development requies:\n\n                         - Server start-up, and reload upon code change.\n                         - Client-side compilation, and reload upon code change.\n                            - Transcompilation to Javascript\n                            - Link to other Javascript libraries\n                            - Bundle all the Javascript code using a code optimizer\n                         }}}\n                  #md {{{\n                         A compilation tool supports new workflows through plugins, so users\n                         can still enjoy automation even for new language features and\n                         libraries.\n                         }}}\n                  )\n            )\n\n      #md {{{\n             Leiningen provides all the essential functionalities of a compilation tool and more.\n             }}}\n      )\n\n(page (:h1 \"Installing Leiningen\")\n      (rows :sep 4 8\n            (:h2 \"Requirements\")\n            #md {{{\n                   - JRE 8 (don\u0027t use JRE 9  *yet*)\n                   }}}\n            (:h2 \"Installation\")\n            #md {{{\n                   - https://leiningen.org/#install\n                   - Save the script in some directory in your `$PATH`\n                   - Run it.  It will self-install.\n                   - No *root* priviledge required.\n                   }}}\n            )\n      )\n\n(page (:h1 \"Abstraction of Leiningen projects\")\n      (rows :sep 4 8\n            (:h2 \"Project name\")\n            #md {{{\n                   A project name needs to be a legal namespace prefix.\n                   }}}\n\n            (:h2 \"Clojure runtime\")\n            #md {{{\n                   Clojure has had many releases.  A project must be\n                   based on a unique runtime.\n\n                   \u003e One can change the runtime release.\n                   }}}\n\n            (:h2 \"Dependencies\")\n            #md {{{\n                   A project can declare dependencies on third-party\n                   Clojure or Java libraries.\n\n                   Each dependency is given as an artifact, given as:\n\n                   1. artifact organization (optional)\n                   2. artifact ID\n                   3. version\n                   }}}\n\n            (:h2 \"Entry-point\")\n            #md {{{\n                   A project typically has one main entry-point to start\n                   the execution.\n\n                   The main entry-point is to be specified as\n                   a function.\n                   }}}\n            )\n      )\n\n(page (:h1 \"Project layout\")\n\n      (rows :sep 4 8\n            (:h2 \"Files of a minimal project\")\n            (:div (code {{{\n                           $ lein new hello_world\n                           }}})\n                  #md {{{\n                      ```\n                      hello_world\n                      \u251c\u2500\u2500 project.clj\n                      \u251c\u2500\u2500 resources\n                      \u251c\u2500\u2500 src\n                      \u2502\u00a0\u00a0 \u2514\u2500\u2500 hello_world\n                      \u2502\u00a0\u00a0     \u2514\u2500\u2500 core.clj\n                      \u2514\u2500\u2500 test\n                          \u2514\u2500\u2500 hello_world\n                                  \u2514\u2500\u2500 core_test.clj\n                      ```\n                      }}})\n\n            (:h2 \"project.clj\")\n            (:div (code :clojure\n                        {{{\n                            (defproject hello-world \"0.1.0-SNAPSHOT\"\n                              :description \"FIXME: write description\"\n                              :url \"http://example.com/FIXME\"\n                              :license {:name \"Eclipse Public License\"\n                                        :url \"http://www.eclipse.org/legal/epl-v10.html\"}\n                              :dependencies [[org.clojure/clojure \"1.8.0\"]])\n                           }}})\n                  #md {{{\n                         The _project.clj_ is a configuration file\n                         that describes the Leiningen project in Clojure.\n\n                         All projects must have at least one dependency\n                         on the Clojure runtime.\n                         }}})\n\n            )\n      )\n\n(page (:h1 \"Basic Clojure\")\n\n      (rows :sep 4 8\n            (:h2 \"Write code\")\n\n            (:div (code {:label \"src/hello_world/core.clj\"\n                         :lang :clojure}\n                        {{{\n                           (ns hello-world.core)\n\n                           (defn f [a b]\n                             (+ a b))\n\n                           (defn main []\n                             (let [a 100\n                                   b 200]\n                               (println (f a b))))\n                           }}}\n                        )\n                  )\n\n            (:h2 \"Running the code\")\n\n            #md {{{\n                   We can run the code by specifying the entry-point\n                   manually.\n\n                   ```\n                   $ lein run -m hello-world.core/main\n                   ```\n                   }}}\n\n            (:h2 \"Use project.clj\")\n            (:div #md {{{\n                         We can specify a _default_ entry-point\n                         in project.clj.\n                         }}}\n                  (code :clojure\n                        :line-number\n                        {{{\n                           (defproject hello-world \"0.1.0-SNAPSHOT\"\n                              :description \"FIXME: write description\"\n                              :url \"http://example.com/FIXME\"\n                              :license {:name \"Eclipse Public License\"\n                                        :url \"http://www.eclipse.org/legal/epl-v10.html\"}\n                              :dependencies [[org.clojure/clojure \"1.8.0\"]]\n                              :main hello-world.core/main     ; \u003c=======\n                              )\n                           }}})\n                  #md {{{\n                         Now, we can run the code more simply as:\n\n                         \u003e ```\n                         \u003e $ lein run\n                         \u003e ```\n\n                         This is a lot more reproducible because you no longer\n                         need to remember the name of the entry-point function.\n                         }}})\n            )\n      )\n\n(page (:h1 \"Multiple namespaces\")\n      #md {{{\n             Leiningen makes it straight-forward to organize your code into\n             multiple namespaces.\n\n             - All the .clj files go under `./src/`.\n             - The namespace derived from the path.\n             }}}\n      (rows :sep 4 8\n            (:h2 \"Matching files to namespaces\")\n            (:div #md {{{\n                         Matching namespace to files:\n\n                         The relative path of from `./src` must match the namespace name\n                         by the following rules:\n\n                         1. path separator `/` is replaced with `.` in the namespace name.\n                         1. underscopres `_` is replaced with \u0027-` in the namespace name.\n                         }}}\n\n                  (code {:clojure true\n                         :label \"./src/hello_world/helper/messages.clj\"}\n                        {{{\n                           (ns hello-world.helper.messages)\n\n                           (defn greeting [] \"Hi, world.\")\n                           (defn bye [] \"See you later, world.\")\n                           }}})\n\n                  (code {:clojure true\n                         :label \"./src/hello_world/say.clj\"}\n                        {{{\n                           (ns hello-world.say)\n\n                           (defn in-english [message]\n                             (println message))\n                           }}})\n                  )\n\n            (:h2 \"Importing other namespaces\")\n            (:div #md {{{\n                         We already have seen how other namespaces can be\n                         imported.}}}\n                  (code :clojure\n                        {{{\n                         (require \u0027[hello-world.helper.messages :as message])\n                         (require \u0027[hello-world.helper.say :as say])\n                         }}})\n                  #md {{{\n                         Clojure has a more idiomatic form.  The `(ns ...)`\n                         supports requiring other namespaces and other features.\n                         }}}\n\n                  (code :clojure\n                        {:label \"./src/hello_world/core.clj\"}\n                        {{{\n                           (ns hello-world.core\n                             (:require [hello-world.helper.messages :as messages]\n                                       [hello-world.say :as say]))\n\n                           (defn main []\n                             (do (say/in-english messages/greeting)\n                                 (say/in-french messages/bye)))\n                           }}})\n                  )\n\n            )\n      )\n\n(page (:h1 \"Utilizing 3rd party libraries\")\n      #md {{{\n             Clojure is a powerful language for many tasks due to its large\n             repositories of libraries.\n\n             - Web development\n             - File parsing\n             - Scientific computation\n             - **GUI Programming**\n             }}}\n\n      (rows :sep 4 8\n            (:h2 \"Finding useful libraries\")\n            (:div #md {{{\n                         https://clojars.org is one of many repositories that Leiningen\n                         can import libraries from.}}}\n                  #md {{{\n                         https://clojars.org/seesaw is a wrapper around Java Swing\n                         GUI toolkit.\n\n                         ```\n                         [seesaw \"1.5.0\"]\n                         ```}}}\n                  )\n\n            (:h2 \"Declaring in project.clj\")\n            (code :clojure\n                  :line-number\n                  {{{\n                     (defproject hello-world \"0.1.0-SNAPSHOT\"\n                        :description \"FIXME: write description\"\n                        :url \"http://example.com/FIXME\"\n                        :license {:name \"Eclipse Public License\"\n                                  :url \"http://www.eclipse.org/legal/epl-v10.html\"}\n                        :dependencies [[org.clojure/clojure \"1.8.0\"]\n                                       [seesaw \"1.5.0\"]]   ;; \u003c======\n                        :main hello-world.core/main\n                        )\n                     }}})\n\n            (:h2 \"Download the dependencies\")\n            (:div (:code {{{\n                            $ lein deps\n                            }}})\n                  #md {{{\n                         Downloads all the dependencies to\n                         `$HOME/.m2` cache.\n\n                         Now, we can program GUI in Clojure.\n                         }}}\n                  )\n\n            (:h2 \"Programming the GUI\")\n            (:div (code :clojure\n                        :line-number\n                        {:label \"./src/hello_world/say.clj\"}\n                        {{{\n\t\t\t\t\t\t\t(ns hello-world.say\n\t\t\t\t\t\t\t  (:require [seesaw.core :as seesaw]\n\t\t\t\t\t\t\t\t\t\t[seesaw.font :as font]))\n\n\t\t\t\t\t\t\t(defn in-english [m]\n\t\t\t\t\t\t\t  (let [l (seesaw/label :text m\n\t\t\t\t\t\t\t\t\t\t\t\t\t:font (font/font :name :monospaced \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t :size 58))\n\t\t\t\t\t\t\t\t\tf (seesaw/frame :title \"English\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t:on-close :exit\n\t\t\t\t\t\t\t\t\t\t\t\t\t:content l)]\n\t\t\t\t\t\t\t\t(-\u003e f seesaw/pack! seesaw/show!)))\n\n                           }}})\n                  )\n            )\n      )\n", "istop": false, "path": "2-Clojure/8-tools"}, "3-Scala": {"children": ["3-Scala/1-pure-oop", "3-Scala/2-scala-programming", "3-Scala/2-syntax", "3-Scala/3-types", "3-Scala/4-general-programming"], "content": "{:title \"Scala: Strongly Typed\"\n :summary #md {{{\n                 In this section, we will work with __Scala__,\n                 a pure object-oriented language that comes with\n                 a strict and powerful type system.\n\n                 We will explore various topics on programming\n                 with types, and details of the Scala language.\n                 We will also discuss the new Android programming\n                 language __Kotlin__ which is a direct derivative\n                 of Scala.\n              }}}}\n", "istop": false, "path": "3-Scala"}, "3-Scala/1-pure-oop": {"children": [], "content": "{:title \"Pure Object-Oriented Programming\"\n :author #md {{{\n                - Ken Pu\n                - Faculty of Science / Computer Science\n                - University of Ontario Institute of Technology\n                - September 2017\n             }}}\n :summary #md {{{\n                 Java is impure as an object-oriented programming language.\n                 Scala is invented to benefit from Java but stay faithful\n                 to the principles of OOP.  Namely, types are classes and\n                 data are objects.  All execution are done by object methods.\n              }}}}\n\n(page (:h1 \"The Impurities of Java\")\n\n      #md {{{\n            Object oriented programming is a paradigm that has proven to be\n            highly effective in building _scalable_ and _reliable_ software.\n\n            Here are some properties and advantages of an OOP language.\n\n            \u003e 1. Data is typed.\n            \u003e 2. Types are classes.\n            \u003e 3. Data are objects.\n            \u003e 4. Computations are _always_ in the form of _method_ invocation.\n          }}}\n\n      #md {{{\n            Java is arguably the most successful _object oriented programming_ language.\n            Yet, Java is violates many design principles of OOP.\n\n            Java satisfies (1) - _Data is always typed_.\n          }}}\n\n      (row 6 6\n        #md {{{\n               Java types are not always classes.  Primitive types in Java\n               are `int`, `float`, `double`, `char`, `bool`, and they\n               are not classes.\n\n               If you try to treat `int` as a class, the code will fail to\n               compile.\n            }}}\n        (code :java :no-nu\n              {{{\n                 List\u003cint\u003e grades = new List\u003cint\u003e();\n              }}}))\n\n      (row 6 6\n           #md {{{\n                  Java data may not be objects.  Data with primitive types\n                  are not objects.  Code that assumeds that `3.1415` as an\n                  object will fail to compile.\n               }}}\n           (code :java :no-nu\n                 {{{\n                    java.lang.Object data = 3.1415;\n                 }}}))\n\n      (row 6 6\n           #md {{{\n                  Some Java computations are not method invocations.\n                  For instance integer arithmetics are not methods\n                  because integer values are not objects.\n               }}}\n           (code :java :no-nu\n                 {{{\n                    int x = 1.+(2);\n                 }}}))\n      (row 6 6\n           #md {{{\n                  Java arrays are quite messy.  They are not objects\n                  but have some members.\n               }}}\n           (code :java\n                 :no-nu\n                 {{{\n                    int[] numbers = new int[10]; /* \u2714 */\n                    int count = numbers.length;  /* \u2714 */\n\n                    int first = numbers.get(0);  /* \u2717 */\n                 }}}))\n      ); page\n\n(page (:h1 \"Why bother with OOP purity\")\n      #md {{{\n             Having none object-oriented language features\n             creates cumbersome \"exceptions\" for the whole language.\n          }}}\n\n      (row 4 8\n        #md {{{\n               - Since arrays are not generic classes,\n               we have to declare them differently.\n\n               - If we want to extend the functionality of \n               arrays, we cannot rely on the class hierarchy\n               feature of Java.\n            }}}\n        (:div\n          (:h2 \"This is Java\")\n          (code :java :no-nu\n                {{{\n                   Student[] students = new Student[n];\n\n                   class MyClass extends java.util.List\u003cStudent\u003e\n                   { ... }\n                }}})\n          (:h2 \"Would like to have\")\n          (code :java :no-nu\n                {{{\n                   var students = new Array\u003cStudent\u003e(n);\n\n                   class MyClass extends Array\u003cStudent\u003e\n                   { ... }\n                }}})))\n\n      (row 4 8\n           #md {{{\n                  - Since primitive data types are not Java classes,\n                  they cannot be directly in generic containers.\n               }}}\n           (:div\n             (:h2 \"This is Java\")\n             (code :java :no-nu\n                    {{{\n                       HashMap\u003cCharacter, Integer\u003e asciiCode \n                                    = new HashMap\u003cCharacter, Integer\u003e();\n                    }}})\n             (:h2 \"Would like to have\")\n             (code :java :no-nu\n                    {{{\n                       HashMap\u003cchar, int\u003e asciiCode \n                                    = new HashMap\u003cchar, int\u003e();\n                    }}}))\n           )\n\n      #md {{{\n             This are just the superficial inconveniences of not having a\n             pure OOP language.  More are to come over the discussions\n             of Scala.\n          }}}\n      ); page\n\n(:h1 \"Scala\")\n \n(page (:h1 \"Principles of Scala\")\n\n      #md {{{\n             - All data are objects, belonging to some class.\n\n             - All computation occurs in some method invocation.\n          }}}\n\n      (:h2 \"Fixing Java\")\n\n      #md {{{\n             - Primitive types are classes.\n\n             - No distinction between `static` vs non-static\n             classes and methods.\n\n             - No distinction between members and methods.\n\n             - More flexible inheritance\n\n             - Functional concepts including:\n\n                - Lambda functions\n                - Immutable data\n                - Closure\n                - Function as values\n\n             - A lot more features, but never breaking\n              away from the pure OOP principles.\n          }}}\n      )\n\n(page (:h1 \"Symbols and bindings\")\n      #md {{{\n             _Review_:\n\n             \u003e - Symbol: a name of a variable that refers to some data\n             \u003e - Binding: an association of a symbol to some specific data\n             \u003e - Scope: a set of bindings such that each symbol is\n             associated to a unique data value.\n          }}}\n      #md {{{\n             Scala symbols are declared and must be initialized during\n             declaration.\n\n             Scala supports two types of bindings.\n\n             - Variable:\n\n                ```\n                var age : Int = 42\n                ```\n\n             - Value:\n\n                ```\n                val gender : String = \"male\"\n                ```\n\n             A var symbol\u0027s binding can be updated.  Namely `age` can be bound\n             to another integer other than 42.  But a var symbol\u0027s binding is fixed.\n             The symbol `gender` is forever bound to the string `\"male\"`.\n          }}}\n\n      #md {{{\n             Which of the two code fragments are permitted by Scala?\n          }}}\n      (row 8 4\n           (code :scala\n                 {{{\n                  var age : Int = 42\n                  age += 1\n                 }}})\n           (toggle #md {{{ _Ok_ }}})\n           )\n      (row 8 4\n           (code :scala\n                 {{{\n                  val gender : String = \"male\"\n                  gender = \"Unknown\"\n                 }}})\n           (toggle #md {{{ _Not permitted_ }}})\n           )\n      )\n\n(page (:h1 \"Simple Scala Classes\")\n      (row 5 7\n        #md {{{\n               A basic class is defined by\n\n               - A name\n               - A set of fields\n               - A set of methods\n               - One or more constructors\n               }}}\n\n        (code :scala\n              :sm\n              :no-nu\n              {{{\n                 class Car {\n                   private var milesDriven: Int = 0\n                   def miles() = milesDriven\n                   def drive(distance: Int) {\n                       milesDriven += Math.abs(distance)\n                   }\n                 }\n              }}}))\n      ); page\n\n(page (:h1 \"Scala Classes As Functions\")\n      (row 5 7\n           #md {{{\n                  A class in Scala is really an _executable_ function\n                  that is invoked as _new Class(...)_, and returns\n                  an object of the type.\n\n                  Like functions, it can have parameters, and in the body,\n                  it can have executable statements.\n\n                  This is called the _primary_ constructor of a class.\n                  }}}\n           (code :scala\n                 :no-nu\n                 :sm\n                 {{{\n                    class Car(year:Int, miles: Int) {\n                        // Initialize the object fields\n                        public val yearOfCar = year\n                        public var milesDriven = miles\n\n                        // Print a message\n                        println(\"Constructing a car\", year, miles)\n\n                        def drive(distance: Int) {\n                            milesDriven += Math.abs(distance)\n                        }\n                    }\n                 }}}))\n      (:h2 \"Constructing objects\")\n\n      (row 5 7\n           #md {{{\n                  We can construct an object by invoking the primary\n                  constructor with the _new_ keyword.\n\n                  The parameters of the constructor must be supplied.\n                  }}}\n           (code :scala\n                 :no-nu\n                 :sm\n                 {{{\n                    val car = new Car(2016, 5000)\n                    car.drive(120)\n                    }}}))\n      ); page\n\n(page (:h1 \"Fields, Methods and Constructors\")\n      \n      (rows :separate 5 7\n           #md {{{\n                  If the arguments of the _primary_ constructor\n                  is prefixed with `val` or `var`, then\n                  they are both the constructor arguments\n                  *and* fields of the class.\n                  }}}\n           (code :scala :sm :no-nu\n                 {{{\n                    class Car(val year: Int, var milesDriven: Int) {\n                        def drive(distance: Int) {\n                            milesDriven += Math.abs(distance)\n                        }\n                    }\n                    }}})\n\n           #md {{{\n                  Additional fields and methods can be defined.\n\n                  - Methods can be an expression or a block of code.\n\n                  - Fields can be `var` or `val`, and they\n                  must be initialized.  \n                  }}}\n           (code :scala\n                 :sm\n                 :no-nu\n                 {{{\n                    class Car(val year: Int,\n                              var milesDriven: Int,\n                              maker_: String) {\n                        var maker: String = if (maker_ == \"GM\") \n                                                \"General Motors\" \n                                            else\n                                                maker_\n\n                        def drive(distance: Int) {\n                            milesDriven += Math.abs(distance)\n                        }\n\n                        def requiresEmissionTest : Boolean = \n                            milesDriven \u003e 100000\n                    }\n                 }}})\n\n           #md {{{\n                  Secondary constructors can be provided\n                  as `def this(...)`.\n\n                  Secondary constructors must invoke some\n                  defined constructors.\n                  }}}\n           (code :scala\n                 :sm\n                 :no-nu\n                 {{{\n                    class Car(val year: Int,\n                              var milesDriven: Int,\n                              maker_: String) {\n\n                        def this(year_:Int, miles: Int) {\n                           this(year, miles, \"GM\")\n                        }\n\n                        def this(year_:Int, maker_: String) {\n                           this(year_, 0, maker_)\n                        }\n\n                        def this(year_:Int) {\n                           this(year_, \"GM\")\n                        }\n\n                        /* The rest ... */\n                    }\n                 }}})\n           #md {{{\n                  We can use any of the constructors\n                  in the `new` construct.\n\n                  Regardless which constructor we invoke,\n                  the _primary_ constructor will always\n                  be executed.  (Why?)\n                  }}}\n           (code :scala\n                 :sm\n                 :no-nu\n                 {{{\n                    val newCar = new Car(2017, 0, \"GM\")\n                    val gmCar = new Car(2017, 0)\n                    val vintageCar = new Car(1960, 3000)\n                    }}})\n           ); rows\n      ); page\n\n(page (:h1 \"Extending a Class\")\n\n      #md {{{\n             Building a hierarchy of classes through\n             inheritance is a key feature of OOP.\n\n             Like Java, Scala uses the `extends` keyword\n             for inheritance.\n\n             But there are some key differences.\n             }}}\n\n      (rows 6 6\n            #md {{{\n                   A class does not extend just a class name,\n                   but rather that class **and** one\n                   of its constructors.\n\n                   Since `Car` has **four** different constructors,\n                   we can choose to extend any of them.\n\n                   Furthermore, we can provide arguments\n                   to the constructor we use for the extension.\n                   }}}\n            (code :scala :no-nu :sm\n                  {{{\n                     class Tesla(year: Int) \n                       extends Car(year, \"Tesla Motor\")\n                       }}}))\n\n      ); page\n\n(:h1 \"Singleton\")\n\n(page (:h1 \"Why is singleton special?\")\n\n      #md {{{\n             *Definition*:\n\n             \u003e A singleton is an object that is the *only*\n             instance of the its class.\n             }}}\n\n      #md {{{\n             An singleton:\n\n             1. is an object.\n             2. has a class.\n             3. its class cannot have any other instances.\n             }}}\n\n      (:h2 \"Java\u0027s treatment\")\n\n      (rows :sep 5 7 \n            #md {{{\n                   Java introduces the _static_ keyword.\n\n                   By annotating fields and methods of a class to\n                   be _static_, they can be used without instantiating\n                   the class.\n                   }}}\n            (code :java :no-nu :sm\n                  {:label \"Java\"}\n                  {{{\n                     class AlbertEinstein {\n                         static String message;\n                         static void say() {\n                            println(AlbertEinstein.message);\n                         }\n                     }\n                     }}})\n\n            #md {{{\n                   Java\u0027s way allows you to think\n                   of the _Class_ itself as the\n                   _instance of the class_.  (It\u0027s confusing, and impure).\n                   }}}\n            (code :java :sm :no-nu\n                  {{{\n                     AlbertEinstein.message = \"Speed of light\";\n                     AlbertEinstein.say()\n                     }}})\n\n            #md {{{\n                   But many things are _weird_ with `static`\n                   way of implementing singletons.\n\n                   - The notion of `this` is broken.\n                   - It does not stop someone to instantiate\n                   another instance of AlbertEinstein.\n                   }}}\n            (code :java :sm :no-nu\n                  {{{\n                     class AlbertEinstein {\n                        static void say() {\n                           println(this.message); // NOT ALLOWED\n                        }\n                     }\n\n                     AlbertEinstein copy = new AlbertEinstein(); // ALLOWED\n                     }}})\n            ); rows\n      ); page\n\n(page (:h1 \"Scala\u0027s singleton object\")\n\n      #md {{{\n             Scala supports singleton by its language feature\n             of declaration of singleton objects.\n\n             Scala allows you to declare the _object_\n             directly without the declaration of its class.\n             }}}\n\n      (rows :sep 5 7\n            #md {{{\n                   We describe an object by describing its class.\n                   The declaration of an object is different\n                   from that of a class:\n\n                   1. The declaration of object cannot have any\n                   constructors.  This is because the declaration\n                   already instantiates the object.\n\n                   2. The declaration is done using `object` keyword\n                   instead of the usual `class` keyword.\n                   }}}\n            (code :java :sm :no-nu\n                  {{{\n                     object AlbertEinstein {\n                        var message: String = \"\"\n                        def say() {\n                            println(this.message)\n                        }\n                     }\n                     }}})\n            #md {{{\n                   Because there is *no* class called _AlbertEinstein_\n                   declared, we cannot instantiate another\n                   object of the same class.\n                   }}}\n            (code :java :sm :no-nu\n                  {{{\n                     val copy = new AlbertEinstein() // NOT ALLOWED\n                     }}})\n            ); rows\n      ); page\n\n(page (:h1 \"The Factory pattern in Java\")\n\n      (rows :sep 5 7\n            #md {{{\n                   In Java, a common programming style known\n                   as the _factory_ pattern is often used.\n\n                   In the _factory pattern_, instead of invoking\n                   class constructors to instantiate objects,\n                   we invoke some static method of the class\n                   that returns objects.\n                   }}}\n\n            (code :java :sm :no-nu\n                  {{{\n                     class Pet {\n                        static Vector\u003cPet\u003e allPets = ...;\n                        static Pet adopt(String name) {\n                            if(name != null)\n                               Pet friend = new Pet(name);\n                               allPets.add(friend);\n                               return friend;\n                            else\n                               throw new Exception();\n                        }\n                        private Pet(String name) {\n                          ...\n                        }\n                     }\n                   }}})\n\n\n\n            (:h2 \"Why bother with factorys\")\n            (:div #md {{{\n                          We can control the code that proceeds\n                         and follows the object constructor.\n\n                          In the previous example, we add\n                          the new object to an array, and also check for\n                          precondition on creating the object.\n                         }}}\n\n                  (code :java :sm :no-nu\n                        {{{\n                           try {\n                              Pet friend = Pet.adopt(\"Woof\");\n                              println(\"Now we have: \" + Pet.allPets.size())\n                           } catch(Exception e) {\n                              ...;\n                           }\n                           }}}))\n            );\n      (:h2 \"Why not Java\u0027s way?\")\n      #md {{{\n             Again, Java breaks away from the pure object-oriented\n             programming.  The invocation of\n             `Pet.adopt(...)` is *not* a method of an object.\n             }}}\n      ); page\n\n(page (:h1 \"Scala Companion Object\")\n      #md {{{\n             Remember that Scala can declare an object\n             without declaring it\u0027s class.\n             }}}\n      (rows 6 6 \n            (:div\n            #md {{{ \n                   It turns out that Scala allows separate declarations\n                   of both an object *and* a class with the _same name_.\n                   }}}\n            #md {{{\n                   The object is called the _companion object_\n                   of the class.\n                   }}})\n            (code :scala :sm :no-nu\n                  {{{\n                     class Pet private(val name: String) {\n                        override def toString() = name\n                     }\n\n                     object Pet {\n                        def adopt(name: String): Pet \n                          = new Pet(name)\n                     }\n                     }}})\n\n            #md {{{\n                   The rules on _companion objects_ are:\n\n                   1. The object is *not* an instance\n                   of the class.\n\n                   2. But the methods of the companion object\n                   can access all private members and fields\n                   of instances of the class,\n                   including the private constructors of\n                   that class.\n                   }}}\n            (code :scala :sm :no-nu\n                  {{{\n                     val friend = Pet.adopt(\"Woof\")\n                     }}})\n            ); rows\n\n      (:h1 \"Comparing with Java\")\n\n      (row 6 6 \n           #md {{{\n                  ## Java\n\n                  ```\n                  friend = Pet.adopt(...)\n                  ```\n\n                  This is not an object method invocation\n                  because `Pet` is not an object.\n                  }}}\n           #md {{{\n                  ## Scala\n\n                  ```\n                  friend = Pet.adopt(...)\n                  ```\n\n                  This is an object method invocation because\n                  `Pet` is a singleton object, that happens to\n                  also be the companion object of `Pet` class.\n                  }}}\n           ); row\n      ); page\n\n", "istop": false, "path": "3-Scala/1-pure-oop"}, "3-Scala/2-scala-programming": {"children": [], "content": "{:title \"Scala Programming\"\n :status :ready\n :summary #md {{{\n                 The general programming in Scala\n                 is done as a mixture of procedural\n                 and functional constructs.  It turns\n                 out that all of the general programming\n                 is built on top of object-oriented programming.}}}\n }\n\n(page (:h1 \"Introduction\")\n\n      #md {{{\n             We will introduce the elements of Scala programming.\n             For now, we will not discuss the object-oriented framework\n             around Scala\u0027s programming constructs.  While they do\n             not seem very object oriented, we will later explain\n             how so much of Scala programming is object oriented\n             programming in disguise.\n             }}})\n\n(page (:h1 \"Symbols and bindings\")\n      #md {{{\n             We can declare symbols as either\n             a `var` or a `val`.\n             }}}\n\n      (rows :sep 6 6 \n            #md {{{ \n                   `var` symbols have bindings that can be updated.\n                   }}}\n            (code :scala :sm \n                  {{{\n                     var i = 10\n                     i = 20\n                     }}})\n            #md {{{\n                   `val` is a symbol that can only be bound\n                   _once_, and the binding can never be updated.\n                   }}}\n            (code :scala :sm \n                  {{{\n                     val i = 10\n                     i = 20 // Not allowed\n                     }}})))\n\n(:h1 \"Expressions, Data and Data Structures\")\n\n(page (:h1 \"Expressions\")\n      #md {{{\n             Scala is a modern language in which *everything*\n             is an expression.  So (almost) everything evaluates to some\n             _value_, and has a _type_.\n             }}}\n      (rows :sep 6 6\n            #md {{{\n                   Declaration statements are not expressions.\n                   All other statements evaluates to data.\n                   }}}\n            (code :scala :sm \n                  {{{\n                     val x = 100\n                     val y = println(\"x=\" + x)\n                     // y = (): Unit\n                     }}})\n\n            #md {{{\n                   A block of statements is an _expression_.\n                   It is evaluated to the _last_ expression\n                   in the block.\n                   }}}\n            (code :scala :sm \n                  {{{\n                     val x = 100\n                     val y = 200\n                     val z = {\n                         println(x)\n                         println(y)\n                         x + y\n                     }\n                     // z = 300: Int\n                     }}})\n            ); rows\n      ); page\n\n(page (:h1 \"Data Structures\")\n\n      #md {{{\n             Scala embraces both (functional) immutable and (imperative)\n             mutable data structures.\n             }}}\n\n      (rows :sep 6 6\n            (:div\n                  #md {{{\n                         All linear collections have the same interface, and can be used\n                         interchangably.  This improves on Java\u0027s issue that arrays are\n                         incompatible with other list implementations.\n                         }}}\n                  #md {{{\n                          **Note**:\n\n                          - Scala uses `(index)`\n                          to address\n                          the elements in a linear collection.\n\n                              \u003e This shows that indexing is\n                          also a method invocation.\n\n                          - Java\u0027s `[index]`\n\n                          }}})\n            (:div (code :scala\n                  {{{\n                     val array = Array(1,2,3,4)\n                     val list  = List(1,2,3,4)\n                     println(\"First element:\" + array(0))\n                     println(\"First element:\" + list(0))\n                     }}}))\n\n            #md {{{\n                   ## Immutable data structures\n                   \n                   Data is *not* mutable.  Once it\u0027s defined, the data\n                   remains constant.  Functions must be used to\n                   tranform data.  So while data cannot change, new and different\n                   data can be constructed based on the existing ones.\n                   }}}\n\n            #md {{{\n                   ## Mutable data structures\n\n                   Data can be updated.  Programs are not restricted to construct\n                   new data, but rather, they can make changes to existing data.\n                   }}})\n\n      #md {{{\n             Q: What\u0027s the difference?\n\n             A: Consider the case of appending an element `3` to the list\n             of `(0, 1, 2)`.  Compare how immutable list append vs mutable\n             list append differ.\n             }}})\n\n(page (:h1 \"Immutable collections\")\n\n      (rows :sep 6 6\n\n            #md {{{\n                   We can use `Array` companion object\n                   to construct _immutable_ arrays.\n\n                   Type inference can automatically fill-in\n                   the type of the array constructed\n                   based on the types of its elements.\n                   }}}\n\n            (code :scala :sm\n                  {{{\n                     val names = Array(\"Jack\", \"Mary\", \"Joe\")\n                     // names : Array[String]\n                     }}})\n\n            #md {{{\n                   How do we _add_ an element to an array?\n\n                   \u003e We cannot because the default arrays are\n                   immutable.\n\n                   **Note**:\n\n                   \u003e Actually elements of the array can be updated,\n                   but not the size of the array.\n\n                   To append,\n\n                   - Invoke the append function with the array\n                   and the new element as arguments.\n\n                   - The append function will construct a _new_ array\n                   with the additional new element.\n                   }}}\n\n            (code :scala :sm\n                  {{{\n                     var x = Array(\"Jack\", \"Mary\")\n                     var y = x :+ \"Joe\"\n                     println(\"x=\" + x.mkString(\"; \"))\n                     println(\"y=\" + y.mkString(\"; \"))\n                     }}})\n\n            #md {{{\n                   Scala provides an immutable linked-list data structure.\n\n                   It\u0027s quite similar to arrays.  However, the implementation\n                   is more efficient to perform functional appends.\n\n                   The companion object `List` constructs the linked-list.\n\n                   The `::` _prepends_ elements to the head of the list.\n                   }}}\n            (code :scala :sm\n                  {{{\n                     var x = List(\"Jack\", \"Mary\")\n                     // x : List[String]\n\n                     var y = \"Joe\" :: x\n                     // y : List[String]\n\n                     println(x.mkString(\", \"))\n                     println(y.mkString(\", \"))\n\n\n                     // Alternatively\n\n                     var x = \"Jack\" :: \"Mary\" :: Nil\n                     var y = \"Joe\" :: x\n                     }}})\n            ); rows\n      ); page\n\n(page (:h1 \"Mutable collections\")\n\n      #md {{{\n             In Scala, mutable collections are known as _buffers_.\n\n             Their implementations are given in `scala.collection.mutable.*`,\n             so to use them, we have to import the namespace.\n\n             ```scala\n             import scala.collection.mutable.ArrayBuffer\n             import scala.collection.mutable.ListBuffer\n             ```\n             }}}\n\n      (rows 5 7\n            #md {{{\n                   `ArrayBuffer` supports dynamic resizing, so you can efficiently\n                   insert elements into an array buffer.\n                   }}}\n            (code :scala\n                  {{{\n                     import scala.collection.mutable.ArrayBuffer\n                     val a = ArrayBuffer(1,2,3)\n                     a += 100\n                     println(a.mkString(\", \"))\n\n                     \u003e 1, 2, 3, 100\n                     }}})\n\n\n            #md {{{\n                   `ListBuffer` is a mutable linked list implementation.\n                   }}}\n            (code :scala\n                  {{{\n                     import scala.collection.mutable.ListBuffer\n                     val a = ListBuffer(1,2,3)\n                     a += 100\n                     println(a.mkString(\", \"))\n\n                     \u003e 1, 2, 3, 100\n                     }}})\n            ); rows\n      ); page\n\n(page (:h1 \"Scala Hashmaps\")\n\n      #md {{{\n             Scala comes with associative collections, such as _hash map_.\n             }}}\n\n      (:h2 \"Immutable Maps\")\n\n      (rows :sep 6 6\n            #md {{{\n                   There is a constructor function to create new\n                   _immutable_ maps.\n                   }}}\n            (code :scala :sm\n                  {{{\n                     val grades = Map(\"Mary\" -\u003e 90,\n                                      \"Jack\" -\u003e 80,\n                                      \"Joe\" -\u003e 76)\n                     }}})\n\n            #md {{{\n                   We can search for the value using the key.\n                   }}}\n            (code :scala :sm\n                  {{{\n                     val gradeOfMary: Int = grades(\"Mary\")\n                     }}})\n\n            #md {{{\n                   Immutable maps cannot be updated in anyway:\n\n                   - It cannot have more key/value pairs\n                   added, and\n                   - the values of an existing key cannot be changed.\n                   }}}\n            (code :scala :sm\n                  {{{\n                     grades(\"Joe\") = 100 // NOT ALLOWED\n                     }}})\n            )\n\n      (:h2 \"Mutable Maps\")\n\n      #md {{{\n             Mutable map implementation is given in\n             `scala.collection.mutable.Map`.\n             }}}\n\n      (rows :sep 5 7\n            #md {{{\n                   We can create a mutable map by\n                   calling the constructor function\n                   using the fully qualified\n                   path name.\n                   }}}\n            (code :scala :sm\n                  {{{\n                     val grades = scala.collection.mutable.Map(\n                                    \"Mary\" -\u003e 90,\n                                    \"Jack\" -\u003e 80,\n                                    \"Joe\" -\u003e 76\n                                  )\n                     }}})\n\n            #md {{{\n                   Since the constructed map is mutable,\n                   we are able to add, delete and modify\n                   key/value pairs.\n                   }}}\n            (code :scala :sm\n                  {{{\n                     grades += (\"Bob\" -\u003e 98)\n\n                     grades.remove(\"Joe\")\n\n                     grades(\"Jack\") = 85\n                     }}})\n            ); rows\n      ); page\n\n(:h1 \"Control Structures in Scala\")\n\n\n(page (:h1 \"while-loop\")\n      #md {{{\n             Scala comes with the standard _while_-loop.\n             }}}\n      (rows 6 6\n            #md {{{\n                   While loop iterates\n                   until the loop condition is no longer\n                   true.\n                   }}}\n            (code :scala :sm \n                  {{{\n                     var i = 0\n                     while(i \u003c 100) {\n                         i += 1\n                         println(\"\u003e\" + i)\n                     }\n                  }}})\n            #md {{{\n                   The while loop evaluates to\n                   the `(): Unit` value.\n                   }}}\n            ); rows\n\n      #md {{{\n             Scala does not have _break_.\n             }}}\n      ); page\n\n(page (:h1 \"for-loop\")\n      #md {{{\n             The for-loop in Scala is a very powerful\n             construct.\n             }}}\n      (rows :sep 6 6\n            #md {{{\n                   The most basic form of _for_ loop\n                   in Scala is iteration over a range.\n                   }}}\n            (code :scala :sm\n                  {{{\n                     for(i \u003c- 0 to 5)\n                         println(i)\n                     \u003e 0\n                     \u003e 1\n                     \u003e 2\n                     \u003e 3\n                     \u003e 4\n                     \u003e 5\n                     }}})\n\n            #md {{{\n                   - `0 to 5` generates a list 0, 1, 2, 3, 4, 5.\n\n                   - `0 until 5` generates a list of 0, 1, 2, 3, 4.\n                   }}}\n            (code :scala :sm\n                  {{{\n                     for(i \u003c- 0 to 4)\n                        println(i)\n                    }}})\n\n            #md {{{\n                   For-loop allows iteration through arbitrary collections.\n                   }}}\n            (code :scala :sm\n                  {{{\n                     val studentNames = Array(\"Jack\", \"Mary\", \"Joe\")\n                     for(name \u003c- studentNames) {\n                         println(name)\n                     }\n                     }}})\n\n            #md {{{\n                   What if we want to skip certain elements during the iteration?\n\n                   For-loop supports `if` construct.\n                   }}}\n            (:div\n              (code :scala :sm\n                    {{{\n                       // Traditional filter, \n                       // not very functional\n                       for(name \u003c- studentNames) {\n                           if(name.startsWith(\"J\"))\n                             println(name)\n                       }\n                       }}})\n              (code :scala :sm\n                    {{{\n                       for(name \u003c- studentNames \n                                if name.startsWith(\"J\")) {\n                           println(name)\n                       }\n                       }}}))\n            ); rows\n      ); page\n", "istop": false, "path": "3-Scala/2-scala-programming"}, "3-Scala/2-syntax": {"children": [], "content": "{:title \"Scala Syntax Rules\"\n :author #md {{{\n                - Ken Pu\n                - Faculty of Science, UOIT\n                - Copyright, 2017\n                }}}\n :summary #md {{{\n                 Scala appears extensible due to its syntax rules.\n                 }}}\n }\n\n(page (:h1 \"Methods as operators\")\n\n      (file :scala \"ex1.scala\")\n\n\n      (:h2 \"Objects and methods with one argument\")\n\n      (row 6 6\n        (code :scala\n              {:label \"Without syntax sugar\"}\n              {{{\n                 val x = point1.add(point2)\n                 println(x)\n                 // 0.0, 1.0\n                 }}})\n        (code :scala\n              {:label \"Syntax sugar\"}\n              {{{\n                 val x = point1 add point2\n                 println(x)\n                 // 0.0, 1.0\n                 }}}))\n\n      (--*--)\n\n      (:h2 \"Unary operators\")\n\n      #md {{{\n             We can define unary operators:\n\n             ```scala\n             class Point2D (...) {\n               def unary_-() = new Point2D(-x, -y)\n             }\n             ```\n             }}}\n      (row 6 6\n        (code :scala\n              {:label \"Without syntax sugar\"}\n              {{{\n                 point1.unary_-()\n                 // -1.0, -2.0\n                 }}})\n        (code :scala\n              {:label \"Syntax sugar\"}\n              {{{\n                 -point1\n                 // -1.0, -2.0\n                 }}}))\n      (--*--)\n\n      (:h2 \"Apply method is magical\")\n\n      #md {{{\n             The _apply_ method makes the object into a\n             function.\n\n             ```\n             x.apply(....)\n             ```\n\n             becomes\n\n             ```\n             x(...)\n             ```\n             }}}\n\n      (row 6 6\n           (code :scala {:label \"Without syntax sugar\"}\n                 {{{\n                    val x = point1.apply(0)\n                    val xsum = point1.apply(0) + point2.apply(0)\n                    }}})\n           (code :scala {:label \"Syntax sugar\"}\n                 {{{\n                    val x = point1(0)\n                    val xsum = point1(0) + point2(0)\n                    }}}))\n      ); page\n\n(page (:h1 \"Deciphering Scala Syntax\")\n\n      (:h2 \"Arithemtics of primitives are method invocations\")\n      (rows :sep 6 6\n\n            (code :scala\n                  {{{\n                     1 + 2.3\n                     }}})\n            (code :scala\n                  {{{\n                     class Int {\n                       ...\n                       def +(x : Double) : Double = ...\n                     }\n\n                     1.+(2.3)\n                     }}})\n            ); rows\n\n      (:h2 \"The Syntax of Array Construction\")\n\n      (rows :sep 4 8\n            #md {{{\n                   Scala defines arrays with an array\n                   constructor function.\n                   }}}\n            (code :scala\n                  {:label \"Syntactic sugar\"}\n                  {{{\n                     val names = Array(\"Jack\", \"Joe\", \"Mary\")\n                     }}})\n\n            #md {{{\n                   This is actually a method invocation of an object.\n                   The syntax is possible with a number of OOP features:\n\n                   1. Type inference\n                   2. Companion object\n                   3. Apply method syntax sugar\n                   }}}\n            (:div\n              (note :side\n                    #md {{{\n                           Array is the _generic_ data structure that\n                           describes static arrays of elements.\n                           }}})\n              (code :scala\n                    {{{\n                       class Array[T] private(...) {\n                         ...\n                       }\n                       }}})\n\n              (note :side\n                    #md {{{\n                           In order to support `Array(...)`, we\n                           need a singleton object `Array` with\n                           `apply` method.\n                           }}})\n              (code :scala\n                    {{{\n                       object Array {\n                         def apply[T](elements : T*) : Array[T] = {\n                           //\n                           // new Array[T]()\n                           //\n                         }\n                       }\n                       }}})\n\n              (code :scala\n                    {:label \"Pure OOP syntactic\"}\n                    {{{\n                       val names : Array[String]\n                         = Array.apply[String](\"Jack\", \"Joe\", \"Mary\")\n                       }}})\n              )\n            ); rows\n      \n      (:h2 \"The syntax of Map construction\")\n\n      (rows :sep 4 8\n            #md {{{\n                   Scala defines hash-map data structure\n                   with the `Map` constructor.  \n                   }}}\n            (code :scala\n                  {{{\n                     val grades = Map(\"Jack\" -\u003e 70,\n                                      \"Joe\" -\u003e 80,\n                                      \"Mary\" -\u003e 90)\n                     }}})\n\n            #md {{{\n                   This is made possible by:\n\n                   - Type inference\n                   - Companion object\n                   - Apply method\n                   - Method as operator \n                   }}}\n            (:div \n              (note :side\n                    #md {{{\n                           - The `Entry` is a single key-value pair.\n                           - Map\n                           }}})\n              (code :scala\n                    {{{\n                       class Entry[K,V](key : K, value : V)\n\n                       class Map[K,V] private(entries : List[Entry]) {\n                         ...\n                       }\n                       }}})\n\n              (note :side\n                    #md {{{\n                           We can create `Entry` from any objects.\n                           }}})\n              (code :scala\n                    {{{\n                       class Any {\n                         def -\u003e[T](x : T) = new Entry(this, x)\n                       }\n                       }}})\n\n              (note :side\n                    #md {{{\n                           One can construct an entry with the syntax.\n                           }}})\n              (code :scala\n                    {{{\n                       val x : Entry[String, Int] = \"Jack\" -\u003e 70\n                       }}})\n\n              (note :side\n                    #md {{{\n                           By creating a companion object to `Map`\n                           that has an `apply` method that has a\n                           variadic arguments, we get\n                           the `Map` constructor.\n                           }}})\n              (code :scala\n                    {{{\n                       object Map {\n                         def apply[K,V](elements : Entry[K,V]*) = {\n                           ...\n                         }\n                       }\n                       }}})\n\n              (code :scala\n                    {:label \"With syntax sugar\"}\n                    {{{\n                       val e1 = \"Jack\" -\u003e 70\n                       val e2 = \"Joe\" -\u003e 80\n                       val e3 = \"Mary\" -\u003e 90\n                       val grades = Map(e1, e2, e3)\n                       }}})\n\n              (code :scala\n                    {:label \"Without syntax sugar\"}\n                    {{{\n                       val e1 = \"Jack\".-\u003e(70)\n                       val e2 = \"Joe\".-\u003e(80)\n                       val e3 = \"Mary\".-\u003e(90)\n                       val grades = Map.apply(e1, e2, e3)\n                       }}})\n              )\n          ); rows\n      ); page\n\n(page (:h1 \"Many Other Syntax Sugars\")\n\n      (:h2 \"Updater\")\n\n      (row 6 6\n        (code :scala\n              {{{\n                 grades(\"Jack\") = 100\n                 }}})\n        (code :scala\n              {{{\n                 grades.update(\"Jack\", 100)\n                 }}}))\n\n      (:h2 \"Setter\")\n      (row 6 6\n           (code :scala\n                 {{{\n                    person.age = 20\n                    }}})\n           (code :scala\n                 {{{\n                    person.age_=(20)\n                    }}}))\n\n      (:h2 \"Code as data\")\n\n      (rows :sep 4 8\n            #md {{{\n                   Scala supports _lazy evaluation_.\n                   A syntax feature allows a block of\n                   code to be treated as __data__.\n                   }}}\n            (code :scala\n                  {{{\n                     // The code will run only\n                     // when n is used for the\n                     // first time.\n                     lazy val n : Int = {\n                        println(\"CODE IS RUNNING\")\n                        var sum = 0\n                        for(i \u003c- 1 to 100) sum += i\n                        sum\n                     }\n\n                     println(n+n+n+n)\n                     }}})\n\n            #md {{{\n                   Scala allows the _lazy evaluated_ code\n                   block to be passed to a method as\n                   a parameter.\n\n                   This is known as _named parameter_.\n                   }}}\n            (code :scala\n                  {{{\n                     def runTwice(code : =\u003e Int) : Int = {\n                       code + code\n                     }\n                     }}})\n\n            #md {{{\n                   ## Implementing while-loop.\n\n                   \u003e We can use the lazy evaluation by\n                   \u003e _named parameter_ of methods to implement\n                   \u003e language features like the while-loop.\n                   }}}\n            (code :scala\n                  {{{\n                     def whileLoop(cond : =\u003eBoolean, body : =\u003eUnit) : Unit = {\n                       if(cond) {\n                         body\n                         whileLoop(cond, body)\n                       }\n                     }\n                     }}})\n            ); rows\n      ); page\n\n(page (:h1 \"Summary\")\n      #md {{{\n             - Scala does not have special syntax beyond OOP.\n             - But Scala has syntactic sugars to make the syntax _extensible_.\n             }}}\n      (--*--)\n      #md {{{\n             Scala supports extensively functional programming.\n             }}})\n", "istop": false, "path": "3-Scala/2-syntax"}, "3-Scala/3-types": {"children": [], "content": "{:title \"More On The Type System\"\n :status :ready\n :summary #md {{{\n                 Scala is a strongly typed language.  Its type system\n                 makes it a fundamentally _safer_ language than\n                 dynamic languages such as Clojure and Python. We\n                 will study the type systems of Scala and see how\n                 it helps to catch software bugs.\n                 }}}\n }\n\n(:h1 \"Types and Type Inference\")\n\n(page (:h1 \"Types of values and symbols\")\n\n      (rows :sep 5 7 \n            #md {{{ \n                   In Scala, types are _classes_.\n\n                   Symbols are bound to values that are _typed_.\n\n                   Scala allows the source code to specify\n                   the _type_ of values that a symbol is allowed\n                   to be bound to.\n\n                   Scala also allows one to specify the type\n                   of the value (as opposed to the symbol).\n                   }}}\n            (code :scala\n                  {{{\n                     var age: Int = 10 // Okay\n                     age = 20          // Okay\n                     age = 3.1415      // Not okay\n\n                     10:Double\n                     age = 10:Double   // Not okay\n                     }}})\n\n\n            #md {{{\n                   Every value has a type.\n                   This means that everything has\n                   a method `.getClass()`\n                   to get the type (which is always a class).\n                   }}}\n            (code :scala\n                  {{{\n                     age.getClass()\n                     age.getClass\n\n                     1.getClass\n                     1.0.getClass\n                     Array(1.0).getClass\n\n                     (1:Double).getClass\n                     }}})\n\n\n            #md {{{\n                   Scala also supports _type inference_.\n                   If you leave out the type specification during\n                   the symbol declaration, scala will use the value\n                   of the binding to figure out the missing\n                   type spec.\n                   }}}\n            (code :scala\n                  {{{\n                     val message = \"Hello world\"\n                     message.getClass  // String\n                     }}})\n            ); rows\n      ); page\n\n(page (:h1 \"Generics\")\n\n      (rows :sep 5 7\n            #md {{{\n                   Java supports generic programming (quite well).\n\n                   Here is the official tutorial on \n                   \u003ca href=\"https://docs.oracle.com/javase/tutorial/java/generics/index.html\"\n                      class=\"label label-default\"\u003eJava Generics\u003c/a\u003e.\n                   }}}\n            (code :sm :java\n                  {{{\n                     // Java\n                     Map\u003cString, Float\u003e grades \n                                        = new HashMap\u003cString, Float\u003e();\n                     grades.put(\"Mary\", 90.0f);\n                     grades.put(\"Jack\", 80.0f);\n                     grades.put(\"Joe\", 76.0f);\n                     }}})\n\n            #md {{{\n                   Scala cleans up the syntax somewhat, and with a more\n                   powerful type inference, generic programming\n                   is a lot more sensible.\n                   }}}\n            (code :sm :scala\n                  {{{\n                     // Scala\n                     val grades: Map[String, Float] \n                         = new Map(\"Mary\" -\u003e 90,\n                                   \"Jack\" -\u003e 80,\n                                   \"Joe\" -\u003e 76)\n                     }}})\n\n            #md {{{\n                   Type inference works with generic types as well.\n                   }}}\n            (code :sm :scala\n                  {{{\n                     var grades = new Map(\"Mary\" -\u003e 90,\n                                          \"Jack\" -\u003e 80,\n                                          \"Joe\" -\u003e 76)\n                     }}})\n            \n            #md {{{ \n                   Scala\u0027s type inference works by assigning the _most specific_ \n                   type to missing type signatures so that there is no type error.\n\n                   If we create an array of string and integer without specifying the\n                   generic type, then Scala uses the most specific type to avoid\n                   type error.  The most specific type that can be either `String`\n                   or `Integer` is their common super class `Any`.\n                   }}}\n            (code :sm :scala\n                  {{{\n                     val x = Array(\"Hello\", 42)\n\n                     // x: Array[Any]\n                     }}})\n\n            #md {{{\n                   Generics apply to both classes\n                   and methods.\n                   }}}\n            (code :sm :scala\n                  {{{\n                     class Person\n                     class Student extends Person\n                     class Faculty extends Person\n\n                     class SocialNetwork {\n                       def beFriend[T \u003c: Person](p1: T, p2: T) {\n                         ...\n                       }\n                     }\n                     }}})\n            ); rows\n      ); page\n\n\n(page (:h1 \"Type Hierarchy\")\n\n      (rows 6 6\n            #md {{{\n                   Types form a hierarchy.  For example, a class `Student`\n                   is a sub-class of `Person`.  This means that all students\n                   can be used in a place that `Person` is expected.\n                   }}}\n            (image \"type-hierarchy.png\")\n\n            #md {{{\n                   `Any` is a super type of all other types.\n\n                   - An object of a subclass can be used as an\n                   object of a superclass.\n\n                   - Any data can be used as an instance of `Any`.\n                   }}}\n            (code :scala :sm\n                  {{{\n                     val myInt : Int = 10\n                     val myNum : Number = myInt  // Okay\n                     val anotherInt: Int = myNum // Not okay\n                     val anything: Any = myNum   // Okay\n                     }}})\n            ); rows\n      ); page\n\n(:h1 \"Functions and Function Types\")\n\n(page (:h1 \"Methods vs function values\")\n      (rows :sep 5 7\n            #md {{{\n                   Scala allows one to define methods to a\n                   _default_ object.\n                   }}}\n            (code :scala :sm\n                  {{{\n                     def sumOfSquares(a: Double, b: Double): Double \n                         =  a*a + b*b\n                    }}})\n\n\n            #md {{{\n                   Recall that type inference tries to\n                   fill in missing type signatures.\n\n                   We don\u0027t have to explicitly state the return\n                   type of the method `sumOfSquare`.\n                   }}}\n            (code :sm :scala\n                  {{{\n                     def sumOfSquares(a: Double, b: Double): Double \n                         =  a*a + b*b\n\n                     sumOfSquare(10, 20)\n                     }}})\n\n\n            #md {{{\n                   Methods are *not* functions.\n\n                   - Functions are objects of classes that represent\n                   functional types.\n\n                   - Methods are *not* objects.\n                   }}}\n            (code :sm :scala\n                  {{{\n                     sumOfSquare.getClass  // Not ok\n                     }}})\n\n            ); rows\n      ); page\n\n(page (:h1 \"Scala is functional\")\n      #md {{{\n             Scala is remarkable.\n\n             - It is purely object-oriented.\n             - It uses syntactic sugars to support pure functional programming.\n             - It uses syntactic sugars to support imperative programming\u0027s\n             control structures.\n\n             Let\u0027s look at the functional constructs.\n             }}}\n\n      (rows :sep 5 7 \n            #md {{{ \n                   Scala\u0027s functions are *objects*.  But we will not need to \n                   invoke their methods manually.  They acts as if they \n                   are methods themselves.\n                   }}}\n            (code :sm :scala\n                  {{{\n                     (a:Int, b:Int) =\u003e a*a*a + b*b*b\n\n                     \u003e (Int, Int) =\u003e Int\n                     }}})\n\n\n            #md {{{\n                   We can use the function value as a function.\n                   }}}\n            (code :sm :scala\n                  {{{\n                     ((a: Int, b: Int) =\u003e a*a*a + b*b*b)(10, 20)\n                     }}})\n\n\n            #md {{{\n                   Since function values are just data (objects), we\n                   can bind them to symbols.\n                   }}}\n\n            (code :tiny :scala\n                  {{{\n                     val sumOfCubes = (a:Int, b:Int) =\u003e a*a*a + b*b*b\n\n                     println(sumOfCubes(100, 200))\n                     }}})\n            ); rows\n      ); pages\n\n(page (:h1 \"Higher order functional programming\")\n      #md {{{\n             As we have learned from functional programming in Clojure,\n             once we can have functions as values, it\u0027s possible\n             to construct functions that operate on functions.\n\n             Higher order functions are extremely powerful\n             programming constructs.\n             }}}\n\n\n      (rows 4 8\n            #md {{{\n                   Consider the method that composes two functions\n                   through generic programming and functions as values.\n                   }}}\n            (code :scala\n                  {{{\n                     def compose[U,V,W](f:U =\u003e V, g: V =\u003e W): U=\u003eW\n                     = (x:U) =\u003e g(f(x))\n                     }}})\n            ); rows\n      ); page\n\n(:h1 \"Abstract Classes \u0026 Traits\")\n\n(page (:h1 \"Abstract class\")\n      \n      (rows :sep 4 8\n            #md {{{\n                   An abstract class can have:\n\n                   - members\n                   - method declarations (aka abstract methods)\n                   - method implementations (aka concret methods)\n                   }}}\n            (code :scala\n                  {{{\n                     abstract class Person {\n                       val name: String = \"\"\n                       def work(): Unit\n                       def hello() = println(\"Hello there.\")\n                     }\n                     }}})\n\n\n            #md {{{\n                   One cannot instantiate an abstract class.\n                   }}}\n            (err (code :scala\n                       {{{\n                          val friend = new Person\n                          }}}))\n\n\n            #md {{{\n                   One can extend an abstract class\n                   in order to:\n\n                   1. Implement abstract methods\n                   2. Modify concret methods (aka override)\n                   }}}\n            (code :scala\n                  {{{\n                     class NiceGuy extends Person {\n                        def work() = println(\"Helping people\")\n                        override def hello() \n                            = println(\"Hello there. Can I help you?\")\n                     }\n                  }}})\n            ); rows\n\n      #md {{{\n             When class `A` is a sub-class of `B`, we write\n             `A \u003c: B`.  This means that `A`-objects can be\n             used as `B`-objects.\n\n             For example:\n\n             ```\n             Lawyer \u003c: Person\n             ```\n             }}}\n\n      #md {{{\n             The opposite is:\n\n             `B \u003e: A`\n\n             So, we have\n\n             ```\n             Person \u003e: Lawyer\n             ```\n             }}}\n\n      #md {{{\n             Sometimes though, there are two different ways\n             to view an entity.  We might have multiple\n             hierarchies of classes.\n\n             ```\n             Person \u003e: Nice\n             ```\n\n             ```\n             Person \u003e: Canadian\n\n             ```\n\n             ```\n             Person :\u003e Legal :\u003e Lawyer\n             ```\n             }}}\n\n      (box  #md {{{\n                   ## Limitations of class hierarchy\n\n                   Q: Multiple hierarchy \n\n                   \u003e How do we build a class that abstracts the type\n                   of individuals how are _nice_ who works\n                   as a _lawyer_, and happen to belong to the indigenous\n                   people.\n                   }}}\n            #md {{{\n                   A: Java fails at doing this.\n\n                   \u003e Each class can only extend _one_ other class.\n                   }}}\n            \n            #md {{{\n                   Java\u0027s solution:\n\n                   \u003e Java uses _interfaces_, but interfaces *cannot*\n                   contain _any_ concret methods.  This leads to a great deal of\n                   increased burden on the implementing class.\n                   }}})\n      ); page\n\n(page (:h1 \"Traits\")\n\n      #md {{{\n             Scala supports a feature called _traits_ to help with mixing\n             multiple hierarchies.\n             }}}\n\n      (rows :sep 4 8\n\n            (:h2 \"About traits\")\n\n            #md {{{\n                   The concept of _traits_ was invented in 1987 by an OOP\n                   programming language called _Self_ \n                   (which itself is a dialet of the first OOP language _Smalltalk_).\n                   }}}\n\n            #md {{{\n                   On the surface, traits look just like abstract classes:\n\n                   - members\n                   - abstract methods\n                   - concret methods\n                   - can extend other classes or traits\n\n                   **In fact: abstract classes are traits.**\n                   }}}\n            (code :scala\n                  {{{\n                   abstract class Person {\n                     val name: String\n                     def say = println(s\"My name is $name\")\n                   }\n\n                   trait Canadian extends Person {\n                     override def say = {\n                       super.say\n                       println(\"Eh?\")\n                     }\n                   }\n                   }}})\n\n\n\n            #md {{{\n                   However, traits are powerful abstractions for building\n                   complex, yet well-defined, hierarchies.\n\n                   Scala supports multiple trait inheritance:\n\n                   - A class can have multiple traits.\n\n                   - An object can be instantiated with multiple traits.\n\n                   }}}\n\n            (:div (code :scala\n                        {{{\n                         class \u003cClass\u003e extends \u003cSuperClass\u003e\n                            with \u003cTrait1\u003e with \u003cTrai2\u003e ...\n                           }}})\n                  (code :scala\n                        {{{\n                           val x = new \u003cClass\u003e(...) with \u003cTrait1\u003e\n                                                    with \u003cTrait2\u003e\n                           }}})\n                  )\n            ); rows\n      ); page\n\n(page (:h1 \"A complete example\")\n\n      #md {{{\n             Let\u0027s go through the example in\n             detail.\n             }}}\n\n      (rows :sep 5 7\n            #md {{{\n                   Let\u0027s start with a base class, called `Person`.\n                   A person has a name, and can say something.\n\n                   - It\u0027s a concret class.\n                   - It needs a name to be instantiated.\n                   - It doesn\u0027t say much...\n                   }}}\n            (code :scala :sm\n                  {{{\n                     class Person(val name: String) {\n                         def say: Unit \n                             = println(s\"My name is $name\")\n                     }\n                     }}})\n\n\n            #md {{{\n                   Now, let\u0027s how _nice_ people are.\n\n                   \u003e We don\u0027t want to build the hierarchy\n                   using class inheritance because a\n                   person can be nice **and** something else\n                   entirely.\n\n                   Let\u0027s model it as a _nice trait_.\n                   }}}\n            (:div (code :scala :sm\n                        {{{\n                           trait Nice extends Person {\n                             override def say = {\n                               super.say\n                               println(\"Can I help you?\")\n                             }\n                           }\n                           }}})\n                  (note :sm \n                        #md {{{\n                               Note: \n\n                               - The trait extends `Person`,\n                               so it can only be applied\n                               to instances of `Person`.\n\n                               - The trait modifies the `say`\n                               method to say something **more**.\n                            }}}))\n\n\n            #md {{{\n                   Let\u0027s model the legal professionals.\n                   We want to establish the following hierarchy:\n\n                   ```\n                   Person \u003e: Legal \u003e: Lawyer\n                   ```\n                   }}}\n            (:div (code :sm :scala\n                        {{{\n                           trait Legal extends Person {\n                             val hourlyRate: Float = 0f\n                             override def say = {\n                               super.say\n                               println(\n                                s\"In legal terms, my rate is $hourlyRate\")\n                             }\n                           }\n                        }}})\n                  (note :sm\n                        #md {{{\n                               Note:\n\n                               - The trait extends `Person`, but it\n                               does not extend `Nice`.\n\n                               - It modifies the `say` message.\n\n                               - It introduces a new member `hourlyRate`.\n                               }}}))\n\n\n            #md {{{\n                   Let\u0027s make a lawyer trait.\n\n                   It extends the `Legal` trait.\n                   }}}\n            (:div (code :sm :scala\n                        {{{\n                           trait Lawyer extends Legal {\n                             override hourlyRate = 500.0f\n                             override def say = {\n                               super.say\n                               println(\n                                s\"I am your lawyer.\")\n                             }\n                           }\n                           }}})\n                  (note :sm\n                        #md {{{\n                               Note:\n\n                               - It overrides `hourlyRate`, but\n                               we don\u0027t need to specify the type, thanks\n                               to type inference.\n\n                               - It overrides the `say` behaviour.\n                               }}}))\n\n\n              #md {{{\n                     Let\u0027s have one more trait of `Canadian`.\n                     }}}\n              (code :sm :scala\n                    {{{\n                       trait Canadian extends Person {\n                         override def say = {\n                           super.say\n                           println(\"Eh?\")\n                         }\n                       }\n                       }}})\n            ); rows\n\n      #md {{{\n             Now, we can create interesting objects (or classes).\n             }}}\n      (rows :sep 3 9\n            #md {{{\n                   A person }}}\n            (code :scala\n                  {{{\n                     val x = new Person(\"Jack\")\n                     x.say\n                     }}})\n\n            #md {{{\n                   A nice person\n                   }}}\n            (code :scala\n                  {{{\n                     val x = new Person(\"Jack\") with Nice\n                     x.say\n                     }}})\n\n\n            #md {{{\n                   Some nice canadian persons\n\n                   Note the difference between `x` and `y`,\n                   and observe the output of their `say`\n                   method.\n                   }}}\n            (code :scala\n                  {{{\n                     val x = new Person(\"Jack\") with Nice with Canadian\n                     x.say\n\n                     val y = new Person(\"Jack\") with Canadian with Nice\n                     y.say\n                     }}})\n\n\n            #md {{{\n                   A canadian legal person.\n\n                   Note `x` has an `hourlyRate`.\n                   }}}\n            (code :scala\n                  {{{\n                     val x = new Person(\"Jack\") with Legal with Canadian\n                     x.say\n                     println(\"Rate:\" + x.hourlyRate)\n                     }}})\n\n            #md {{{\n                   A Canadian lawyer who is also a nice person.\n\n                   This mixes *three* different hierarchies.\n                   }}}\n\n            (code :scala\n                  {{{\n                     val x = new Person(\"Jack\")\n                                 with Nice\n                                 with Canadian\n                                 with Lawyer\n                     x.say\n                     }}})\n            ); rows;\n      ); page\n\n(page (:h1 \"Linearization of methods\")\n\n      #md {{{\n             Q:\n             \n             \u003e How does Scala determine the sequence of method\n             invocation for `say`?\n\n             A:\n\n             \u003e Linearization\n             }}}\n\n      #md {{{\n             Let\u0027s consider:\n\n             ```\n             new Person(\"Jack\") with Nice\n                                with Canadian\n                                with Lawyer\n             ```\n             }}}\n\n      (rows :sep 5 7\n            #md {{{\n                   Each applied trait has it\u0027s own hierarchy.\n                   }}}\n            #md {{{\n                   1. `Person \u003e: Nice`\n\n                   1. `Person \u003e: Legal \u003e: Lawyer`\n\n                   2. `Person \u003e: Canadian`\n                   }}}\n\n\n\n            #md {{{\n                   The traits are applied in a particular sequence.\n                   }}}\n            #md {{{\n                   1. `Person`, and then\n                   2. `Nice`, and then\n                   3. `Canadian`, and then\n                   4. `Lawyer`\n                   }}}\n\n\n            #md {{{\n                   What happens when we call the method?\n\n                   ```\n                   x.say\n                   ```\n                   }}}\n            (:div #md {{{\n                   Scala performs __linearization__:\n\n                   *Linearization*:\n\n                   \u003e The traits are ordered into a\n                   \u003e linear sequence according to the following\n                   \u003e rules:\n                   \u003e\n                   \u003e - The traits applied later comes later in the sequece.\n                   \u003e - The super-classes come before the sub-classes.\n                   }}}\n                  #md {{{\n                         - The first in the sequence is `Person`.\n                         - Then it\u0027s the trait `Nice`.\n                         - Then it\u0027s the trait `Canadian`.\n                         - Then it\u0027s the super-trait `Legal`.\n                         - Then it\u0027s then sub-trait `Lawyer`.\n                         }}}\n                  #md {{{\n                         - `x.say` refers to the _last_ type that has the method `say:Unit`.\n                         - `super` refers to the previous type in the linearized sequence.\n                         }}})\n\n            (code :sm :scala\n                  {{{\n                   (new Person(\"Jack\")\n                        with Nice\n                        with Canadian\n                        with Lawyer).say\n                   }}})\n            (code :scala :tiny\n                  {{{\n                     My name is Jack                   // Person.say\n                     Can I help you?                   // Nice.say\n                     Eh?                               // Canadian.say\n                     In legal terms, my rate is 500.0  // Legal.say\n                     I am your lawyer.                 // Lawyer.say\n                     }}})\n                  \n\n            ); rows\n\n      ); page\n\n(:h1 \"Summary\")\n\n\n(page (:h1 \"Static Type\")\n      #md {{{\n             All type information on all\n             symbols must be _figured_ out\n             by the compiler during compilation time.\n             }}}\n      #md {{{\n             This makes Scala fundamentally different\n             from Clojure.\n\n             Scala:\n\n             \u003e Type information is determined at compile\n             time.\n\n             Clojure:\n\n             \u003e Type information is determined at run-time.\n             }}}\n\n      (--*--)\n\n      (:h1 \"Type Inference\")\n      #md {{{\n             Whenever possible, Scala will fill in the unspecified\n             type information to avoid type error.\n\n             So, Scala programs do not need overly verbose\n             type specifications as is the case for Java and C++.\n             }}}\n\n      (--*--)\n\n      (:h1 \"Functional Types\")\n      #md {{{\n             Scala supports functional types and functional values.\n             So, functional programming patterns we use in Clojure\n             can be applied in Scala with ease.\n             }}}\n\n      (--*--)\n\n      (:h1 \"Traits\")\n      #md {{{\n             Scala supports _traits_.  \n             \n             - A class can inherit multiple traits.\n\n             - An object can be instantiated with multiple traits.\n\n             - Dynamic method dispatch is done by _linearization_.\n             }}}\n      ); page\n\n", "istop": false, "path": "3-Scala/3-types"}, "3-Scala/4-general-programming": {"children": [], "content": "{:title \"A case study with Scala\"\n :summary #md {{{\n                 We present a code walk of working with Scala.\n                 }}}\n }\n\n(file :codewalk \"codewalk/Makefile\")\n", "istop": false, "path": "3-Scala/4-general-programming"}};
    var root_path = "./programming-languages";
    var reload_path = window.origin + root_path;
    console.log("app.core.main()");
    app.core.main();
</script>
</body>

<!-- Mirrored from db.science.uoit.ca/library/teaching/programming-languages by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 06 Apr 2020 22:46:02 GMT -->
</html>